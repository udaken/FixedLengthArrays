//#define GENERATE_ALL_FIELDS
//#define GENERATE_ENUMERABLE
//#define GENERATE_CTOR
#define GENERATE_ASSPAN

#if !GENERATE_ALL_FIELDS
	#if GENERATE_CTOR
	#error Configuration Error
	#endif
	#if GENERATE_ENUMERABLE
	#error Configuration Error
	#endif
#endif

using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;

namespace FixedLengthArray
{
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 2 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray2
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray2 _Zero = default;
		public static ref readonly FixedLengthByteArray2 Zero => ref _Zero;

		public const int ConstLength = 2;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray2(
			Byte field0
			, Byte field1
		)
		{
			Field0 = field0;
			Field1 = field1;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray2) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray2)other);

        public readonly bool Equals(in FixedLengthByteArray2 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray2 left, in FixedLengthByteArray2 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray2 left, in FixedLengthByteArray2 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray2 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray2 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray2 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray2 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray2 array1, in FixedLengthByteArray2 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray2 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray2 array1, in FixedLengthByteArray2 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray2 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray2 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray2 array1, in FixedLengthByteArray2 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray2 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray2 array1, in FixedLengthByteArray2 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray2 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 3 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray3
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray3 _Zero = default;
		public static ref readonly FixedLengthByteArray3 Zero => ref _Zero;

		public const int ConstLength = 3;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray3(
			Byte field0
			, Byte field1
			, Byte field2
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray3) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray3)other);

        public readonly bool Equals(in FixedLengthByteArray3 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray3 left, in FixedLengthByteArray3 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray3 left, in FixedLengthByteArray3 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray3 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray3 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray3 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray3 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray3 array1, in FixedLengthByteArray3 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray3 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray3 array1, in FixedLengthByteArray3 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray3 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray3 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray3 array1, in FixedLengthByteArray3 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray3 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray3 array1, in FixedLengthByteArray3 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray3 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 4 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray4
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray4 _Zero = default;
		public static ref readonly FixedLengthByteArray4 Zero => ref _Zero;

		public const int ConstLength = 4;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray4(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray4) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray4)other);

        public readonly bool Equals(in FixedLengthByteArray4 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray4 left, in FixedLengthByteArray4 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray4 left, in FixedLengthByteArray4 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray4 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray4 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray4 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray4 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray4 array1, in FixedLengthByteArray4 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray4 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray4 array1, in FixedLengthByteArray4 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray4 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray4 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray4 array1, in FixedLengthByteArray4 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray4 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray4 array1, in FixedLengthByteArray4 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray4 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 5 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray5
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray5 _Zero = default;
		public static ref readonly FixedLengthByteArray5 Zero => ref _Zero;

		public const int ConstLength = 5;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray5(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray5) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray5)other);

        public readonly bool Equals(in FixedLengthByteArray5 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray5 left, in FixedLengthByteArray5 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray5 left, in FixedLengthByteArray5 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray5 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray5 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray5 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray5 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray5 array1, in FixedLengthByteArray5 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray5 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray5 array1, in FixedLengthByteArray5 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray5 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray5 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray5 array1, in FixedLengthByteArray5 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray5 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray5 array1, in FixedLengthByteArray5 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray5 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 6 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray6
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray6 _Zero = default;
		public static ref readonly FixedLengthByteArray6 Zero => ref _Zero;

		public const int ConstLength = 6;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray6(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray6) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray6)other);

        public readonly bool Equals(in FixedLengthByteArray6 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray6 left, in FixedLengthByteArray6 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray6 left, in FixedLengthByteArray6 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray6 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray6 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray6 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray6 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray6 array1, in FixedLengthByteArray6 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray6 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray6 array1, in FixedLengthByteArray6 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray6 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray6 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray6 array1, in FixedLengthByteArray6 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray6 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray6 array1, in FixedLengthByteArray6 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray6 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 7 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray7
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray7 _Zero = default;
		public static ref readonly FixedLengthByteArray7 Zero => ref _Zero;

		public const int ConstLength = 7;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray7(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray7) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray7)other);

        public readonly bool Equals(in FixedLengthByteArray7 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray7 left, in FixedLengthByteArray7 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray7 left, in FixedLengthByteArray7 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray7 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray7 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray7 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray7 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray7 array1, in FixedLengthByteArray7 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray7 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray7 array1, in FixedLengthByteArray7 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray7 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray7 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray7 array1, in FixedLengthByteArray7 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray7 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray7 array1, in FixedLengthByteArray7 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray7 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 8 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray8
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray8 _Zero = default;
		public static ref readonly FixedLengthByteArray8 Zero => ref _Zero;

		public const int ConstLength = 8;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray8(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray8) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray8)other);

        public readonly bool Equals(in FixedLengthByteArray8 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray8 left, in FixedLengthByteArray8 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray8 left, in FixedLengthByteArray8 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray8 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray8 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray8 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray8 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray8 array1, in FixedLengthByteArray8 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray8 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray8 array1, in FixedLengthByteArray8 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray8 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray8 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray8 array1, in FixedLengthByteArray8 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray8 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray8 array1, in FixedLengthByteArray8 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray8 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 9 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray9
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray9 _Zero = default;
		public static ref readonly FixedLengthByteArray9 Zero => ref _Zero;

		public const int ConstLength = 9;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray9(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray9) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray9)other);

        public readonly bool Equals(in FixedLengthByteArray9 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray9 left, in FixedLengthByteArray9 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray9 left, in FixedLengthByteArray9 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray9 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray9 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray9 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray9 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray9 array1, in FixedLengthByteArray9 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray9 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray9 array1, in FixedLengthByteArray9 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray9 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray9 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray9 array1, in FixedLengthByteArray9 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray9 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray9 array1, in FixedLengthByteArray9 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray9 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 10 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray10
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray10 _Zero = default;
		public static ref readonly FixedLengthByteArray10 Zero => ref _Zero;

		public const int ConstLength = 10;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray10(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray10) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray10)other);

        public readonly bool Equals(in FixedLengthByteArray10 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray10 left, in FixedLengthByteArray10 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray10 left, in FixedLengthByteArray10 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray10 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray10 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray10 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray10 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray10 array1, in FixedLengthByteArray10 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray10 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray10 array1, in FixedLengthByteArray10 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray10 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray10 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray10 array1, in FixedLengthByteArray10 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray10 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray10 array1, in FixedLengthByteArray10 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray10 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 11 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray11
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray11 _Zero = default;
		public static ref readonly FixedLengthByteArray11 Zero => ref _Zero;

		public const int ConstLength = 11;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray11(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray11) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray11)other);

        public readonly bool Equals(in FixedLengthByteArray11 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray11 left, in FixedLengthByteArray11 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray11 left, in FixedLengthByteArray11 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray11 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray11 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray11 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray11 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray11 array1, in FixedLengthByteArray11 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray11 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray11 array1, in FixedLengthByteArray11 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray11 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray11 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray11 array1, in FixedLengthByteArray11 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray11 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray11 array1, in FixedLengthByteArray11 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray11 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 12 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray12
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray12 _Zero = default;
		public static ref readonly FixedLengthByteArray12 Zero => ref _Zero;

		public const int ConstLength = 12;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray12(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray12) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray12)other);

        public readonly bool Equals(in FixedLengthByteArray12 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray12 left, in FixedLengthByteArray12 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray12 left, in FixedLengthByteArray12 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray12 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray12 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray12 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray12 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray12 array1, in FixedLengthByteArray12 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray12 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray12 array1, in FixedLengthByteArray12 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray12 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray12 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray12 array1, in FixedLengthByteArray12 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray12 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray12 array1, in FixedLengthByteArray12 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray12 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 13 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray13
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray13 _Zero = default;
		public static ref readonly FixedLengthByteArray13 Zero => ref _Zero;

		public const int ConstLength = 13;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray13(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray13) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray13)other);

        public readonly bool Equals(in FixedLengthByteArray13 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray13 left, in FixedLengthByteArray13 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray13 left, in FixedLengthByteArray13 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray13 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray13 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray13 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray13 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray13 array1, in FixedLengthByteArray13 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray13 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray13 array1, in FixedLengthByteArray13 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray13 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray13 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray13 array1, in FixedLengthByteArray13 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray13 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray13 array1, in FixedLengthByteArray13 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray13 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 14 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray14
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray14 _Zero = default;
		public static ref readonly FixedLengthByteArray14 Zero => ref _Zero;

		public const int ConstLength = 14;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray14(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray14) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray14)other);

        public readonly bool Equals(in FixedLengthByteArray14 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray14 left, in FixedLengthByteArray14 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray14 left, in FixedLengthByteArray14 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray14 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray14 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray14 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray14 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray14 array1, in FixedLengthByteArray14 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray14 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray14 array1, in FixedLengthByteArray14 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray14 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray14 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray14 array1, in FixedLengthByteArray14 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray14 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray14 array1, in FixedLengthByteArray14 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray14 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 15 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray15
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray15 _Zero = default;
		public static ref readonly FixedLengthByteArray15 Zero => ref _Zero;

		public const int ConstLength = 15;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray15(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray15) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray15)other);

        public readonly bool Equals(in FixedLengthByteArray15 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray15 left, in FixedLengthByteArray15 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray15 left, in FixedLengthByteArray15 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray15 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray15 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray15 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray15 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray15 array1, in FixedLengthByteArray15 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray15 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray15 array1, in FixedLengthByteArray15 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray15 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray15 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray15 array1, in FixedLengthByteArray15 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray15 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray15 array1, in FixedLengthByteArray15 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray15 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 16 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray16
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray16 _Zero = default;
		public static ref readonly FixedLengthByteArray16 Zero => ref _Zero;

		public const int ConstLength = 16;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray16(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray16) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray16)other);

        public readonly bool Equals(in FixedLengthByteArray16 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray16 left, in FixedLengthByteArray16 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray16 left, in FixedLengthByteArray16 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray16 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray16 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray16 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray16 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray16 array1, in FixedLengthByteArray16 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray16 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray16 array1, in FixedLengthByteArray16 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray16 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray16 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray16 array1, in FixedLengthByteArray16 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray16 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray16 array1, in FixedLengthByteArray16 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray16 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 17 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray17
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray17 _Zero = default;
		public static ref readonly FixedLengthByteArray17 Zero => ref _Zero;

		public const int ConstLength = 17;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray17(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray17) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray17)other);

        public readonly bool Equals(in FixedLengthByteArray17 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray17 left, in FixedLengthByteArray17 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray17 left, in FixedLengthByteArray17 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray17 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray17 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray17 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray17 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray17 array1, in FixedLengthByteArray17 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray17 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray17 array1, in FixedLengthByteArray17 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray17 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray17 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray17 array1, in FixedLengthByteArray17 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray17 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray17 array1, in FixedLengthByteArray17 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray17 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 18 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray18
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray18 _Zero = default;
		public static ref readonly FixedLengthByteArray18 Zero => ref _Zero;

		public const int ConstLength = 18;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray18(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray18) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray18)other);

        public readonly bool Equals(in FixedLengthByteArray18 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray18 left, in FixedLengthByteArray18 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray18 left, in FixedLengthByteArray18 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray18 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray18 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray18 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray18 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray18 array1, in FixedLengthByteArray18 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray18 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray18 array1, in FixedLengthByteArray18 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray18 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray18 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray18 array1, in FixedLengthByteArray18 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray18 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray18 array1, in FixedLengthByteArray18 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray18 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 19 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray19
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray19 _Zero = default;
		public static ref readonly FixedLengthByteArray19 Zero => ref _Zero;

		public const int ConstLength = 19;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray19(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray19) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray19)other);

        public readonly bool Equals(in FixedLengthByteArray19 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray19 left, in FixedLengthByteArray19 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray19 left, in FixedLengthByteArray19 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray19 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray19 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray19 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray19 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray19 array1, in FixedLengthByteArray19 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray19 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray19 array1, in FixedLengthByteArray19 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray19 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray19 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray19 array1, in FixedLengthByteArray19 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray19 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray19 array1, in FixedLengthByteArray19 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray19 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 20 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray20
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray20 _Zero = default;
		public static ref readonly FixedLengthByteArray20 Zero => ref _Zero;

		public const int ConstLength = 20;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray20(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray20) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray20)other);

        public readonly bool Equals(in FixedLengthByteArray20 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray20 left, in FixedLengthByteArray20 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray20 left, in FixedLengthByteArray20 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray20 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray20 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray20 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray20 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray20 array1, in FixedLengthByteArray20 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray20 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray20 array1, in FixedLengthByteArray20 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray20 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray20 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray20 array1, in FixedLengthByteArray20 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray20 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray20 array1, in FixedLengthByteArray20 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray20 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 21 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray21
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray21 _Zero = default;
		public static ref readonly FixedLengthByteArray21 Zero => ref _Zero;

		public const int ConstLength = 21;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray21(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray21) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray21)other);

        public readonly bool Equals(in FixedLengthByteArray21 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray21 left, in FixedLengthByteArray21 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray21 left, in FixedLengthByteArray21 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray21 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray21 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray21 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray21 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray21 array1, in FixedLengthByteArray21 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray21 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray21 array1, in FixedLengthByteArray21 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray21 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray21 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray21 array1, in FixedLengthByteArray21 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray21 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray21 array1, in FixedLengthByteArray21 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray21 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 22 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray22
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray22 _Zero = default;
		public static ref readonly FixedLengthByteArray22 Zero => ref _Zero;

		public const int ConstLength = 22;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray22(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray22) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray22)other);

        public readonly bool Equals(in FixedLengthByteArray22 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray22 left, in FixedLengthByteArray22 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray22 left, in FixedLengthByteArray22 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray22 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray22 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray22 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray22 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray22 array1, in FixedLengthByteArray22 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray22 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray22 array1, in FixedLengthByteArray22 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray22 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray22 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray22 array1, in FixedLengthByteArray22 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray22 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray22 array1, in FixedLengthByteArray22 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray22 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 23 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray23
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray23 _Zero = default;
		public static ref readonly FixedLengthByteArray23 Zero => ref _Zero;

		public const int ConstLength = 23;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray23(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray23) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray23)other);

        public readonly bool Equals(in FixedLengthByteArray23 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray23 left, in FixedLengthByteArray23 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray23 left, in FixedLengthByteArray23 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray23 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray23 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray23 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray23 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray23 array1, in FixedLengthByteArray23 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray23 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray23 array1, in FixedLengthByteArray23 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray23 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray23 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray23 array1, in FixedLengthByteArray23 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray23 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray23 array1, in FixedLengthByteArray23 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray23 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 24 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray24
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray24 _Zero = default;
		public static ref readonly FixedLengthByteArray24 Zero => ref _Zero;

		public const int ConstLength = 24;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray24(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray24) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray24)other);

        public readonly bool Equals(in FixedLengthByteArray24 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray24 left, in FixedLengthByteArray24 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray24 left, in FixedLengthByteArray24 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray24 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray24 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray24 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray24 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray24 array1, in FixedLengthByteArray24 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray24 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray24 array1, in FixedLengthByteArray24 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray24 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray24 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray24 array1, in FixedLengthByteArray24 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray24 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray24 array1, in FixedLengthByteArray24 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray24 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 25 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray25
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray25 _Zero = default;
		public static ref readonly FixedLengthByteArray25 Zero => ref _Zero;

		public const int ConstLength = 25;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray25(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray25) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray25)other);

        public readonly bool Equals(in FixedLengthByteArray25 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray25 left, in FixedLengthByteArray25 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray25 left, in FixedLengthByteArray25 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray25 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray25 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray25 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray25 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray25 array1, in FixedLengthByteArray25 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray25 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray25 array1, in FixedLengthByteArray25 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray25 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray25 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray25 array1, in FixedLengthByteArray25 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray25 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray25 array1, in FixedLengthByteArray25 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray25 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 26 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray26
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray26 _Zero = default;
		public static ref readonly FixedLengthByteArray26 Zero => ref _Zero;

		public const int ConstLength = 26;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray26(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
			, Byte field25
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
		public Byte Field25;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray26) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray26)other);

        public readonly bool Equals(in FixedLengthByteArray26 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray26 left, in FixedLengthByteArray26 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray26 left, in FixedLengthByteArray26 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray26 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray26 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray26 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray26 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray26 array1, in FixedLengthByteArray26 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray26 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray26 array1, in FixedLengthByteArray26 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray26 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray26 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray26 array1, in FixedLengthByteArray26 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray26 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray26 array1, in FixedLengthByteArray26 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray26 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 27 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray27
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray27 _Zero = default;
		public static ref readonly FixedLengthByteArray27 Zero => ref _Zero;

		public const int ConstLength = 27;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray27(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
			, Byte field25
			, Byte field26
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
		public Byte Field25;
		public Byte Field26;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray27) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray27)other);

        public readonly bool Equals(in FixedLengthByteArray27 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray27 left, in FixedLengthByteArray27 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray27 left, in FixedLengthByteArray27 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray27 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray27 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray27 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray27 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray27 array1, in FixedLengthByteArray27 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray27 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray27 array1, in FixedLengthByteArray27 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray27 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray27 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray27 array1, in FixedLengthByteArray27 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray27 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray27 array1, in FixedLengthByteArray27 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray27 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 28 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray28
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray28 _Zero = default;
		public static ref readonly FixedLengthByteArray28 Zero => ref _Zero;

		public const int ConstLength = 28;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray28(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
			, Byte field25
			, Byte field26
			, Byte field27
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
		public Byte Field25;
		public Byte Field26;
		public Byte Field27;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray28) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray28)other);

        public readonly bool Equals(in FixedLengthByteArray28 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray28 left, in FixedLengthByteArray28 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray28 left, in FixedLengthByteArray28 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray28 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray28 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray28 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray28 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray28 array1, in FixedLengthByteArray28 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray28 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray28 array1, in FixedLengthByteArray28 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray28 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray28 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray28 array1, in FixedLengthByteArray28 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray28 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray28 array1, in FixedLengthByteArray28 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray28 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 29 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray29
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray29 _Zero = default;
		public static ref readonly FixedLengthByteArray29 Zero => ref _Zero;

		public const int ConstLength = 29;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray29(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
			, Byte field25
			, Byte field26
			, Byte field27
			, Byte field28
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
		public Byte Field25;
		public Byte Field26;
		public Byte Field27;
		public Byte Field28;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray29) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray29)other);

        public readonly bool Equals(in FixedLengthByteArray29 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray29 left, in FixedLengthByteArray29 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray29 left, in FixedLengthByteArray29 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray29 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray29 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray29 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray29 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray29 array1, in FixedLengthByteArray29 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray29 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray29 array1, in FixedLengthByteArray29 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray29 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray29 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray29 array1, in FixedLengthByteArray29 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray29 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray29 array1, in FixedLengthByteArray29 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray29 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 30 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray30
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray30 _Zero = default;
		public static ref readonly FixedLengthByteArray30 Zero => ref _Zero;

		public const int ConstLength = 30;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray30(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
			, Byte field25
			, Byte field26
			, Byte field27
			, Byte field28
			, Byte field29
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
		public Byte Field25;
		public Byte Field26;
		public Byte Field27;
		public Byte Field28;
		public Byte Field29;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray30) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray30)other);

        public readonly bool Equals(in FixedLengthByteArray30 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray30 left, in FixedLengthByteArray30 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray30 left, in FixedLengthByteArray30 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray30 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray30 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray30 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray30 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray30 array1, in FixedLengthByteArray30 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray30 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray30 array1, in FixedLengthByteArray30 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray30 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray30 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray30 array1, in FixedLengthByteArray30 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray30 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray30 array1, in FixedLengthByteArray30 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray30 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 31 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray31
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray31 _Zero = default;
		public static ref readonly FixedLengthByteArray31 Zero => ref _Zero;

		public const int ConstLength = 31;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray31(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
			, Byte field25
			, Byte field26
			, Byte field27
			, Byte field28
			, Byte field29
			, Byte field30
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
		public Byte Field25;
		public Byte Field26;
		public Byte Field27;
		public Byte Field28;
		public Byte Field29;
		public Byte Field30;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray31) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray31)other);

        public readonly bool Equals(in FixedLengthByteArray31 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray31 left, in FixedLengthByteArray31 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray31 left, in FixedLengthByteArray31 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray31 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray31 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray31 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray31 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray31 array1, in FixedLengthByteArray31 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray31 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray31 array1, in FixedLengthByteArray31 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray31 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray31 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray31 array1, in FixedLengthByteArray31 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray31 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray31 array1, in FixedLengthByteArray31 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray31 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 32 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray32
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray32 _Zero = default;
		public static ref readonly FixedLengthByteArray32 Zero => ref _Zero;

		public const int ConstLength = 32;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray32(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
			, Byte field25
			, Byte field26
			, Byte field27
			, Byte field28
			, Byte field29
			, Byte field30
			, Byte field31
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
		public Byte Field25;
		public Byte Field26;
		public Byte Field27;
		public Byte Field28;
		public Byte Field29;
		public Byte Field30;
		public Byte Field31;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray32) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray32)other);

        public readonly bool Equals(in FixedLengthByteArray32 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray32 left, in FixedLengthByteArray32 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray32 left, in FixedLengthByteArray32 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray32 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray32 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray32 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray32 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray32 array1, in FixedLengthByteArray32 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray32 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray32 array1, in FixedLengthByteArray32 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray32 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray32 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray32 array1, in FixedLengthByteArray32 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray32 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray32 array1, in FixedLengthByteArray32 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray32 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 33 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray33
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray33 _Zero = default;
		public static ref readonly FixedLengthByteArray33 Zero => ref _Zero;

		public const int ConstLength = 33;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray33(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
			, Byte field25
			, Byte field26
			, Byte field27
			, Byte field28
			, Byte field29
			, Byte field30
			, Byte field31
			, Byte field32
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
		public Byte Field25;
		public Byte Field26;
		public Byte Field27;
		public Byte Field28;
		public Byte Field29;
		public Byte Field30;
		public Byte Field31;
		public Byte Field32;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray33) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray33)other);

        public readonly bool Equals(in FixedLengthByteArray33 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray33 left, in FixedLengthByteArray33 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray33 left, in FixedLengthByteArray33 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray33 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray33 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray33 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray33 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray33 array1, in FixedLengthByteArray33 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray33 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray33 array1, in FixedLengthByteArray33 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray33 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray33 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray33 array1, in FixedLengthByteArray33 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray33 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray33 array1, in FixedLengthByteArray33 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray33 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 34 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray34
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray34 _Zero = default;
		public static ref readonly FixedLengthByteArray34 Zero => ref _Zero;

		public const int ConstLength = 34;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray34(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
			, Byte field25
			, Byte field26
			, Byte field27
			, Byte field28
			, Byte field29
			, Byte field30
			, Byte field31
			, Byte field32
			, Byte field33
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
		public Byte Field25;
		public Byte Field26;
		public Byte Field27;
		public Byte Field28;
		public Byte Field29;
		public Byte Field30;
		public Byte Field31;
		public Byte Field32;
		public Byte Field33;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray34) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray34)other);

        public readonly bool Equals(in FixedLengthByteArray34 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray34 left, in FixedLengthByteArray34 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray34 left, in FixedLengthByteArray34 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray34 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray34 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray34 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray34 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray34 array1, in FixedLengthByteArray34 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray34 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray34 array1, in FixedLengthByteArray34 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray34 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray34 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray34 array1, in FixedLengthByteArray34 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray34 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray34 array1, in FixedLengthByteArray34 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray34 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 35 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray35
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray35 _Zero = default;
		public static ref readonly FixedLengthByteArray35 Zero => ref _Zero;

		public const int ConstLength = 35;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray35(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
			, Byte field25
			, Byte field26
			, Byte field27
			, Byte field28
			, Byte field29
			, Byte field30
			, Byte field31
			, Byte field32
			, Byte field33
			, Byte field34
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
		public Byte Field25;
		public Byte Field26;
		public Byte Field27;
		public Byte Field28;
		public Byte Field29;
		public Byte Field30;
		public Byte Field31;
		public Byte Field32;
		public Byte Field33;
		public Byte Field34;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray35) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray35)other);

        public readonly bool Equals(in FixedLengthByteArray35 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray35 left, in FixedLengthByteArray35 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray35 left, in FixedLengthByteArray35 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray35 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray35 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray35 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray35 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray35 array1, in FixedLengthByteArray35 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray35 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray35 array1, in FixedLengthByteArray35 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray35 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray35 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray35 array1, in FixedLengthByteArray35 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray35 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray35 array1, in FixedLengthByteArray35 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray35 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 36 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray36
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray36 _Zero = default;
		public static ref readonly FixedLengthByteArray36 Zero => ref _Zero;

		public const int ConstLength = 36;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray36(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
			, Byte field25
			, Byte field26
			, Byte field27
			, Byte field28
			, Byte field29
			, Byte field30
			, Byte field31
			, Byte field32
			, Byte field33
			, Byte field34
			, Byte field35
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
		public Byte Field25;
		public Byte Field26;
		public Byte Field27;
		public Byte Field28;
		public Byte Field29;
		public Byte Field30;
		public Byte Field31;
		public Byte Field32;
		public Byte Field33;
		public Byte Field34;
		public Byte Field35;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray36) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray36)other);

        public readonly bool Equals(in FixedLengthByteArray36 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray36 left, in FixedLengthByteArray36 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray36 left, in FixedLengthByteArray36 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray36 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray36 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray36 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray36 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray36 array1, in FixedLengthByteArray36 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray36 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray36 array1, in FixedLengthByteArray36 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray36 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray36 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray36 array1, in FixedLengthByteArray36 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray36 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray36 array1, in FixedLengthByteArray36 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray36 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 37 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray37
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray37 _Zero = default;
		public static ref readonly FixedLengthByteArray37 Zero => ref _Zero;

		public const int ConstLength = 37;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray37(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
			, Byte field25
			, Byte field26
			, Byte field27
			, Byte field28
			, Byte field29
			, Byte field30
			, Byte field31
			, Byte field32
			, Byte field33
			, Byte field34
			, Byte field35
			, Byte field36
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
		public Byte Field25;
		public Byte Field26;
		public Byte Field27;
		public Byte Field28;
		public Byte Field29;
		public Byte Field30;
		public Byte Field31;
		public Byte Field32;
		public Byte Field33;
		public Byte Field34;
		public Byte Field35;
		public Byte Field36;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray37) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray37)other);

        public readonly bool Equals(in FixedLengthByteArray37 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray37 left, in FixedLengthByteArray37 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray37 left, in FixedLengthByteArray37 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray37 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray37 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray37 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray37 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray37 array1, in FixedLengthByteArray37 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray37 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray37 array1, in FixedLengthByteArray37 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray37 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray37 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray37 array1, in FixedLengthByteArray37 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray37 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray37 array1, in FixedLengthByteArray37 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray37 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 38 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray38
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray38 _Zero = default;
		public static ref readonly FixedLengthByteArray38 Zero => ref _Zero;

		public const int ConstLength = 38;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray38(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
			, Byte field25
			, Byte field26
			, Byte field27
			, Byte field28
			, Byte field29
			, Byte field30
			, Byte field31
			, Byte field32
			, Byte field33
			, Byte field34
			, Byte field35
			, Byte field36
			, Byte field37
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
		public Byte Field25;
		public Byte Field26;
		public Byte Field27;
		public Byte Field28;
		public Byte Field29;
		public Byte Field30;
		public Byte Field31;
		public Byte Field32;
		public Byte Field33;
		public Byte Field34;
		public Byte Field35;
		public Byte Field36;
		public Byte Field37;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray38) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray38)other);

        public readonly bool Equals(in FixedLengthByteArray38 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray38 left, in FixedLengthByteArray38 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray38 left, in FixedLengthByteArray38 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray38 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray38 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray38 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray38 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray38 array1, in FixedLengthByteArray38 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray38 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray38 array1, in FixedLengthByteArray38 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray38 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray38 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray38 array1, in FixedLengthByteArray38 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray38 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray38 array1, in FixedLengthByteArray38 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray38 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 39 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray39
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray39 _Zero = default;
		public static ref readonly FixedLengthByteArray39 Zero => ref _Zero;

		public const int ConstLength = 39;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray39(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
			, Byte field25
			, Byte field26
			, Byte field27
			, Byte field28
			, Byte field29
			, Byte field30
			, Byte field31
			, Byte field32
			, Byte field33
			, Byte field34
			, Byte field35
			, Byte field36
			, Byte field37
			, Byte field38
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
		public Byte Field25;
		public Byte Field26;
		public Byte Field27;
		public Byte Field28;
		public Byte Field29;
		public Byte Field30;
		public Byte Field31;
		public Byte Field32;
		public Byte Field33;
		public Byte Field34;
		public Byte Field35;
		public Byte Field36;
		public Byte Field37;
		public Byte Field38;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray39) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray39)other);

        public readonly bool Equals(in FixedLengthByteArray39 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray39 left, in FixedLengthByteArray39 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray39 left, in FixedLengthByteArray39 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray39 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray39 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray39 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray39 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray39 array1, in FixedLengthByteArray39 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray39 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray39 array1, in FixedLengthByteArray39 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray39 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray39 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray39 array1, in FixedLengthByteArray39 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray39 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray39 array1, in FixedLengthByteArray39 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray39 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 40 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray40
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray40 _Zero = default;
		public static ref readonly FixedLengthByteArray40 Zero => ref _Zero;

		public const int ConstLength = 40;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray40(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
			, Byte field25
			, Byte field26
			, Byte field27
			, Byte field28
			, Byte field29
			, Byte field30
			, Byte field31
			, Byte field32
			, Byte field33
			, Byte field34
			, Byte field35
			, Byte field36
			, Byte field37
			, Byte field38
			, Byte field39
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
		public Byte Field25;
		public Byte Field26;
		public Byte Field27;
		public Byte Field28;
		public Byte Field29;
		public Byte Field30;
		public Byte Field31;
		public Byte Field32;
		public Byte Field33;
		public Byte Field34;
		public Byte Field35;
		public Byte Field36;
		public Byte Field37;
		public Byte Field38;
		public Byte Field39;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray40) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray40)other);

        public readonly bool Equals(in FixedLengthByteArray40 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray40 left, in FixedLengthByteArray40 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray40 left, in FixedLengthByteArray40 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray40 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray40 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray40 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray40 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray40 array1, in FixedLengthByteArray40 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray40 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray40 array1, in FixedLengthByteArray40 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray40 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray40 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray40 array1, in FixedLengthByteArray40 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray40 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray40 array1, in FixedLengthByteArray40 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray40 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 41 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray41
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray41 _Zero = default;
		public static ref readonly FixedLengthByteArray41 Zero => ref _Zero;

		public const int ConstLength = 41;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray41(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
			, Byte field25
			, Byte field26
			, Byte field27
			, Byte field28
			, Byte field29
			, Byte field30
			, Byte field31
			, Byte field32
			, Byte field33
			, Byte field34
			, Byte field35
			, Byte field36
			, Byte field37
			, Byte field38
			, Byte field39
			, Byte field40
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
		public Byte Field25;
		public Byte Field26;
		public Byte Field27;
		public Byte Field28;
		public Byte Field29;
		public Byte Field30;
		public Byte Field31;
		public Byte Field32;
		public Byte Field33;
		public Byte Field34;
		public Byte Field35;
		public Byte Field36;
		public Byte Field37;
		public Byte Field38;
		public Byte Field39;
		public Byte Field40;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray41) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray41)other);

        public readonly bool Equals(in FixedLengthByteArray41 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray41 left, in FixedLengthByteArray41 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray41 left, in FixedLengthByteArray41 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray41 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray41 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray41 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray41 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray41 array1, in FixedLengthByteArray41 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray41 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray41 array1, in FixedLengthByteArray41 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray41 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray41 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray41 array1, in FixedLengthByteArray41 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray41 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray41 array1, in FixedLengthByteArray41 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray41 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 42 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray42
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray42 _Zero = default;
		public static ref readonly FixedLengthByteArray42 Zero => ref _Zero;

		public const int ConstLength = 42;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray42(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
			, Byte field25
			, Byte field26
			, Byte field27
			, Byte field28
			, Byte field29
			, Byte field30
			, Byte field31
			, Byte field32
			, Byte field33
			, Byte field34
			, Byte field35
			, Byte field36
			, Byte field37
			, Byte field38
			, Byte field39
			, Byte field40
			, Byte field41
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
		public Byte Field25;
		public Byte Field26;
		public Byte Field27;
		public Byte Field28;
		public Byte Field29;
		public Byte Field30;
		public Byte Field31;
		public Byte Field32;
		public Byte Field33;
		public Byte Field34;
		public Byte Field35;
		public Byte Field36;
		public Byte Field37;
		public Byte Field38;
		public Byte Field39;
		public Byte Field40;
		public Byte Field41;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray42) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray42)other);

        public readonly bool Equals(in FixedLengthByteArray42 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray42 left, in FixedLengthByteArray42 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray42 left, in FixedLengthByteArray42 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray42 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray42 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray42 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray42 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray42 array1, in FixedLengthByteArray42 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray42 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray42 array1, in FixedLengthByteArray42 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray42 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray42 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray42 array1, in FixedLengthByteArray42 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray42 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray42 array1, in FixedLengthByteArray42 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray42 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 43 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray43
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray43 _Zero = default;
		public static ref readonly FixedLengthByteArray43 Zero => ref _Zero;

		public const int ConstLength = 43;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray43(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
			, Byte field25
			, Byte field26
			, Byte field27
			, Byte field28
			, Byte field29
			, Byte field30
			, Byte field31
			, Byte field32
			, Byte field33
			, Byte field34
			, Byte field35
			, Byte field36
			, Byte field37
			, Byte field38
			, Byte field39
			, Byte field40
			, Byte field41
			, Byte field42
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
		public Byte Field25;
		public Byte Field26;
		public Byte Field27;
		public Byte Field28;
		public Byte Field29;
		public Byte Field30;
		public Byte Field31;
		public Byte Field32;
		public Byte Field33;
		public Byte Field34;
		public Byte Field35;
		public Byte Field36;
		public Byte Field37;
		public Byte Field38;
		public Byte Field39;
		public Byte Field40;
		public Byte Field41;
		public Byte Field42;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray43) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray43)other);

        public readonly bool Equals(in FixedLengthByteArray43 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray43 left, in FixedLengthByteArray43 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray43 left, in FixedLengthByteArray43 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray43 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray43 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray43 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray43 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray43 array1, in FixedLengthByteArray43 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray43 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray43 array1, in FixedLengthByteArray43 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray43 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray43 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray43 array1, in FixedLengthByteArray43 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray43 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray43 array1, in FixedLengthByteArray43 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray43 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 44 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray44
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray44 _Zero = default;
		public static ref readonly FixedLengthByteArray44 Zero => ref _Zero;

		public const int ConstLength = 44;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray44(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
			, Byte field25
			, Byte field26
			, Byte field27
			, Byte field28
			, Byte field29
			, Byte field30
			, Byte field31
			, Byte field32
			, Byte field33
			, Byte field34
			, Byte field35
			, Byte field36
			, Byte field37
			, Byte field38
			, Byte field39
			, Byte field40
			, Byte field41
			, Byte field42
			, Byte field43
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
		public Byte Field25;
		public Byte Field26;
		public Byte Field27;
		public Byte Field28;
		public Byte Field29;
		public Byte Field30;
		public Byte Field31;
		public Byte Field32;
		public Byte Field33;
		public Byte Field34;
		public Byte Field35;
		public Byte Field36;
		public Byte Field37;
		public Byte Field38;
		public Byte Field39;
		public Byte Field40;
		public Byte Field41;
		public Byte Field42;
		public Byte Field43;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray44) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray44)other);

        public readonly bool Equals(in FixedLengthByteArray44 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray44 left, in FixedLengthByteArray44 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray44 left, in FixedLengthByteArray44 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray44 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray44 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray44 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray44 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray44 array1, in FixedLengthByteArray44 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray44 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray44 array1, in FixedLengthByteArray44 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray44 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray44 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray44 array1, in FixedLengthByteArray44 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray44 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray44 array1, in FixedLengthByteArray44 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray44 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 45 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray45
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray45 _Zero = default;
		public static ref readonly FixedLengthByteArray45 Zero => ref _Zero;

		public const int ConstLength = 45;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray45(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
			, Byte field25
			, Byte field26
			, Byte field27
			, Byte field28
			, Byte field29
			, Byte field30
			, Byte field31
			, Byte field32
			, Byte field33
			, Byte field34
			, Byte field35
			, Byte field36
			, Byte field37
			, Byte field38
			, Byte field39
			, Byte field40
			, Byte field41
			, Byte field42
			, Byte field43
			, Byte field44
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
		public Byte Field25;
		public Byte Field26;
		public Byte Field27;
		public Byte Field28;
		public Byte Field29;
		public Byte Field30;
		public Byte Field31;
		public Byte Field32;
		public Byte Field33;
		public Byte Field34;
		public Byte Field35;
		public Byte Field36;
		public Byte Field37;
		public Byte Field38;
		public Byte Field39;
		public Byte Field40;
		public Byte Field41;
		public Byte Field42;
		public Byte Field43;
		public Byte Field44;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray45) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray45)other);

        public readonly bool Equals(in FixedLengthByteArray45 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray45 left, in FixedLengthByteArray45 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray45 left, in FixedLengthByteArray45 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray45 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray45 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray45 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray45 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray45 array1, in FixedLengthByteArray45 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray45 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray45 array1, in FixedLengthByteArray45 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray45 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray45 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray45 array1, in FixedLengthByteArray45 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray45 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray45 array1, in FixedLengthByteArray45 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray45 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 46 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray46
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray46 _Zero = default;
		public static ref readonly FixedLengthByteArray46 Zero => ref _Zero;

		public const int ConstLength = 46;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray46(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
			, Byte field25
			, Byte field26
			, Byte field27
			, Byte field28
			, Byte field29
			, Byte field30
			, Byte field31
			, Byte field32
			, Byte field33
			, Byte field34
			, Byte field35
			, Byte field36
			, Byte field37
			, Byte field38
			, Byte field39
			, Byte field40
			, Byte field41
			, Byte field42
			, Byte field43
			, Byte field44
			, Byte field45
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
		public Byte Field25;
		public Byte Field26;
		public Byte Field27;
		public Byte Field28;
		public Byte Field29;
		public Byte Field30;
		public Byte Field31;
		public Byte Field32;
		public Byte Field33;
		public Byte Field34;
		public Byte Field35;
		public Byte Field36;
		public Byte Field37;
		public Byte Field38;
		public Byte Field39;
		public Byte Field40;
		public Byte Field41;
		public Byte Field42;
		public Byte Field43;
		public Byte Field44;
		public Byte Field45;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray46) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray46)other);

        public readonly bool Equals(in FixedLengthByteArray46 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray46 left, in FixedLengthByteArray46 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray46 left, in FixedLengthByteArray46 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray46 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray46 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray46 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray46 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray46 array1, in FixedLengthByteArray46 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray46 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray46 array1, in FixedLengthByteArray46 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray46 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray46 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray46 array1, in FixedLengthByteArray46 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray46 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray46 array1, in FixedLengthByteArray46 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray46 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 47 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray47
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray47 _Zero = default;
		public static ref readonly FixedLengthByteArray47 Zero => ref _Zero;

		public const int ConstLength = 47;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray47(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
			, Byte field25
			, Byte field26
			, Byte field27
			, Byte field28
			, Byte field29
			, Byte field30
			, Byte field31
			, Byte field32
			, Byte field33
			, Byte field34
			, Byte field35
			, Byte field36
			, Byte field37
			, Byte field38
			, Byte field39
			, Byte field40
			, Byte field41
			, Byte field42
			, Byte field43
			, Byte field44
			, Byte field45
			, Byte field46
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
			Field46 = field46;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
		public Byte Field25;
		public Byte Field26;
		public Byte Field27;
		public Byte Field28;
		public Byte Field29;
		public Byte Field30;
		public Byte Field31;
		public Byte Field32;
		public Byte Field33;
		public Byte Field34;
		public Byte Field35;
		public Byte Field36;
		public Byte Field37;
		public Byte Field38;
		public Byte Field39;
		public Byte Field40;
		public Byte Field41;
		public Byte Field42;
		public Byte Field43;
		public Byte Field44;
		public Byte Field45;
		public Byte Field46;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                46 => Field46,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
                    case 46: Field46 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray47) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray47)other);

        public readonly bool Equals(in FixedLengthByteArray47 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray47 left, in FixedLengthByteArray47 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray47 left, in FixedLengthByteArray47 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
              yield return Field46;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray47 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray47 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray47 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray47 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
                case 46: return ref array.Field46;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray47 array1, in FixedLengthByteArray47 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray47 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray47 array1, in FixedLengthByteArray47 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray47 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray47 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray47 array1, in FixedLengthByteArray47 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray47 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray47 array1, in FixedLengthByteArray47 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray47 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 48 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray48
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray48 _Zero = default;
		public static ref readonly FixedLengthByteArray48 Zero => ref _Zero;

		public const int ConstLength = 48;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray48(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
			, Byte field25
			, Byte field26
			, Byte field27
			, Byte field28
			, Byte field29
			, Byte field30
			, Byte field31
			, Byte field32
			, Byte field33
			, Byte field34
			, Byte field35
			, Byte field36
			, Byte field37
			, Byte field38
			, Byte field39
			, Byte field40
			, Byte field41
			, Byte field42
			, Byte field43
			, Byte field44
			, Byte field45
			, Byte field46
			, Byte field47
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
			Field46 = field46;
			Field47 = field47;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
		public Byte Field25;
		public Byte Field26;
		public Byte Field27;
		public Byte Field28;
		public Byte Field29;
		public Byte Field30;
		public Byte Field31;
		public Byte Field32;
		public Byte Field33;
		public Byte Field34;
		public Byte Field35;
		public Byte Field36;
		public Byte Field37;
		public Byte Field38;
		public Byte Field39;
		public Byte Field40;
		public Byte Field41;
		public Byte Field42;
		public Byte Field43;
		public Byte Field44;
		public Byte Field45;
		public Byte Field46;
		public Byte Field47;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                46 => Field46,
                47 => Field47,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
                    case 46: Field46 = value; break;
                    case 47: Field47 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray48) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray48)other);

        public readonly bool Equals(in FixedLengthByteArray48 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray48 left, in FixedLengthByteArray48 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray48 left, in FixedLengthByteArray48 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
              yield return Field46;
              yield return Field47;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray48 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray48 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray48 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray48 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
                case 46: return ref array.Field46;
                case 47: return ref array.Field47;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray48 array1, in FixedLengthByteArray48 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray48 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray48 array1, in FixedLengthByteArray48 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray48 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray48 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray48 array1, in FixedLengthByteArray48 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray48 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray48 array1, in FixedLengthByteArray48 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray48 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 49 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray49
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray49 _Zero = default;
		public static ref readonly FixedLengthByteArray49 Zero => ref _Zero;

		public const int ConstLength = 49;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray49(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
			, Byte field25
			, Byte field26
			, Byte field27
			, Byte field28
			, Byte field29
			, Byte field30
			, Byte field31
			, Byte field32
			, Byte field33
			, Byte field34
			, Byte field35
			, Byte field36
			, Byte field37
			, Byte field38
			, Byte field39
			, Byte field40
			, Byte field41
			, Byte field42
			, Byte field43
			, Byte field44
			, Byte field45
			, Byte field46
			, Byte field47
			, Byte field48
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
			Field46 = field46;
			Field47 = field47;
			Field48 = field48;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
		public Byte Field25;
		public Byte Field26;
		public Byte Field27;
		public Byte Field28;
		public Byte Field29;
		public Byte Field30;
		public Byte Field31;
		public Byte Field32;
		public Byte Field33;
		public Byte Field34;
		public Byte Field35;
		public Byte Field36;
		public Byte Field37;
		public Byte Field38;
		public Byte Field39;
		public Byte Field40;
		public Byte Field41;
		public Byte Field42;
		public Byte Field43;
		public Byte Field44;
		public Byte Field45;
		public Byte Field46;
		public Byte Field47;
		public Byte Field48;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                46 => Field46,
                47 => Field47,
                48 => Field48,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
                    case 46: Field46 = value; break;
                    case 47: Field47 = value; break;
                    case 48: Field48 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray49) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray49)other);

        public readonly bool Equals(in FixedLengthByteArray49 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray49 left, in FixedLengthByteArray49 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray49 left, in FixedLengthByteArray49 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
              yield return Field46;
              yield return Field47;
              yield return Field48;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray49 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray49 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray49 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray49 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
                case 46: return ref array.Field46;
                case 47: return ref array.Field47;
                case 48: return ref array.Field48;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray49 array1, in FixedLengthByteArray49 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray49 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray49 array1, in FixedLengthByteArray49 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray49 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray49 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray49 array1, in FixedLengthByteArray49 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray49 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray49 array1, in FixedLengthByteArray49 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray49 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 50 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray50
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray50 _Zero = default;
		public static ref readonly FixedLengthByteArray50 Zero => ref _Zero;

		public const int ConstLength = 50;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray50(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
			, Byte field25
			, Byte field26
			, Byte field27
			, Byte field28
			, Byte field29
			, Byte field30
			, Byte field31
			, Byte field32
			, Byte field33
			, Byte field34
			, Byte field35
			, Byte field36
			, Byte field37
			, Byte field38
			, Byte field39
			, Byte field40
			, Byte field41
			, Byte field42
			, Byte field43
			, Byte field44
			, Byte field45
			, Byte field46
			, Byte field47
			, Byte field48
			, Byte field49
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
			Field46 = field46;
			Field47 = field47;
			Field48 = field48;
			Field49 = field49;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
		public Byte Field25;
		public Byte Field26;
		public Byte Field27;
		public Byte Field28;
		public Byte Field29;
		public Byte Field30;
		public Byte Field31;
		public Byte Field32;
		public Byte Field33;
		public Byte Field34;
		public Byte Field35;
		public Byte Field36;
		public Byte Field37;
		public Byte Field38;
		public Byte Field39;
		public Byte Field40;
		public Byte Field41;
		public Byte Field42;
		public Byte Field43;
		public Byte Field44;
		public Byte Field45;
		public Byte Field46;
		public Byte Field47;
		public Byte Field48;
		public Byte Field49;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                46 => Field46,
                47 => Field47,
                48 => Field48,
                49 => Field49,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
                    case 46: Field46 = value; break;
                    case 47: Field47 = value; break;
                    case 48: Field48 = value; break;
                    case 49: Field49 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray50) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray50)other);

        public readonly bool Equals(in FixedLengthByteArray50 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray50 left, in FixedLengthByteArray50 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray50 left, in FixedLengthByteArray50 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
              yield return Field46;
              yield return Field47;
              yield return Field48;
              yield return Field49;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray50 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray50 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray50 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray50 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
                case 46: return ref array.Field46;
                case 47: return ref array.Field47;
                case 48: return ref array.Field48;
                case 49: return ref array.Field49;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray50 array1, in FixedLengthByteArray50 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray50 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray50 array1, in FixedLengthByteArray50 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray50 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray50 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray50 array1, in FixedLengthByteArray50 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray50 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray50 array1, in FixedLengthByteArray50 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray50 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 51 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray51
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray51 _Zero = default;
		public static ref readonly FixedLengthByteArray51 Zero => ref _Zero;

		public const int ConstLength = 51;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray51(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
			, Byte field25
			, Byte field26
			, Byte field27
			, Byte field28
			, Byte field29
			, Byte field30
			, Byte field31
			, Byte field32
			, Byte field33
			, Byte field34
			, Byte field35
			, Byte field36
			, Byte field37
			, Byte field38
			, Byte field39
			, Byte field40
			, Byte field41
			, Byte field42
			, Byte field43
			, Byte field44
			, Byte field45
			, Byte field46
			, Byte field47
			, Byte field48
			, Byte field49
			, Byte field50
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
			Field46 = field46;
			Field47 = field47;
			Field48 = field48;
			Field49 = field49;
			Field50 = field50;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
		public Byte Field25;
		public Byte Field26;
		public Byte Field27;
		public Byte Field28;
		public Byte Field29;
		public Byte Field30;
		public Byte Field31;
		public Byte Field32;
		public Byte Field33;
		public Byte Field34;
		public Byte Field35;
		public Byte Field36;
		public Byte Field37;
		public Byte Field38;
		public Byte Field39;
		public Byte Field40;
		public Byte Field41;
		public Byte Field42;
		public Byte Field43;
		public Byte Field44;
		public Byte Field45;
		public Byte Field46;
		public Byte Field47;
		public Byte Field48;
		public Byte Field49;
		public Byte Field50;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                46 => Field46,
                47 => Field47,
                48 => Field48,
                49 => Field49,
                50 => Field50,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
                    case 46: Field46 = value; break;
                    case 47: Field47 = value; break;
                    case 48: Field48 = value; break;
                    case 49: Field49 = value; break;
                    case 50: Field50 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray51) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray51)other);

        public readonly bool Equals(in FixedLengthByteArray51 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray51 left, in FixedLengthByteArray51 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray51 left, in FixedLengthByteArray51 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
              yield return Field46;
              yield return Field47;
              yield return Field48;
              yield return Field49;
              yield return Field50;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray51 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray51 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray51 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray51 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
                case 46: return ref array.Field46;
                case 47: return ref array.Field47;
                case 48: return ref array.Field48;
                case 49: return ref array.Field49;
                case 50: return ref array.Field50;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray51 array1, in FixedLengthByteArray51 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray51 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray51 array1, in FixedLengthByteArray51 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray51 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray51 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray51 array1, in FixedLengthByteArray51 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray51 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray51 array1, in FixedLengthByteArray51 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray51 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 52 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray52
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray52 _Zero = default;
		public static ref readonly FixedLengthByteArray52 Zero => ref _Zero;

		public const int ConstLength = 52;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray52(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
			, Byte field25
			, Byte field26
			, Byte field27
			, Byte field28
			, Byte field29
			, Byte field30
			, Byte field31
			, Byte field32
			, Byte field33
			, Byte field34
			, Byte field35
			, Byte field36
			, Byte field37
			, Byte field38
			, Byte field39
			, Byte field40
			, Byte field41
			, Byte field42
			, Byte field43
			, Byte field44
			, Byte field45
			, Byte field46
			, Byte field47
			, Byte field48
			, Byte field49
			, Byte field50
			, Byte field51
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
			Field46 = field46;
			Field47 = field47;
			Field48 = field48;
			Field49 = field49;
			Field50 = field50;
			Field51 = field51;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
		public Byte Field25;
		public Byte Field26;
		public Byte Field27;
		public Byte Field28;
		public Byte Field29;
		public Byte Field30;
		public Byte Field31;
		public Byte Field32;
		public Byte Field33;
		public Byte Field34;
		public Byte Field35;
		public Byte Field36;
		public Byte Field37;
		public Byte Field38;
		public Byte Field39;
		public Byte Field40;
		public Byte Field41;
		public Byte Field42;
		public Byte Field43;
		public Byte Field44;
		public Byte Field45;
		public Byte Field46;
		public Byte Field47;
		public Byte Field48;
		public Byte Field49;
		public Byte Field50;
		public Byte Field51;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                46 => Field46,
                47 => Field47,
                48 => Field48,
                49 => Field49,
                50 => Field50,
                51 => Field51,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
                    case 46: Field46 = value; break;
                    case 47: Field47 = value; break;
                    case 48: Field48 = value; break;
                    case 49: Field49 = value; break;
                    case 50: Field50 = value; break;
                    case 51: Field51 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray52) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray52)other);

        public readonly bool Equals(in FixedLengthByteArray52 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray52 left, in FixedLengthByteArray52 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray52 left, in FixedLengthByteArray52 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
              yield return Field46;
              yield return Field47;
              yield return Field48;
              yield return Field49;
              yield return Field50;
              yield return Field51;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray52 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray52 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray52 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray52 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
                case 46: return ref array.Field46;
                case 47: return ref array.Field47;
                case 48: return ref array.Field48;
                case 49: return ref array.Field49;
                case 50: return ref array.Field50;
                case 51: return ref array.Field51;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray52 array1, in FixedLengthByteArray52 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray52 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray52 array1, in FixedLengthByteArray52 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray52 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray52 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray52 array1, in FixedLengthByteArray52 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray52 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray52 array1, in FixedLengthByteArray52 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray52 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 53 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray53
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray53 _Zero = default;
		public static ref readonly FixedLengthByteArray53 Zero => ref _Zero;

		public const int ConstLength = 53;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray53(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
			, Byte field25
			, Byte field26
			, Byte field27
			, Byte field28
			, Byte field29
			, Byte field30
			, Byte field31
			, Byte field32
			, Byte field33
			, Byte field34
			, Byte field35
			, Byte field36
			, Byte field37
			, Byte field38
			, Byte field39
			, Byte field40
			, Byte field41
			, Byte field42
			, Byte field43
			, Byte field44
			, Byte field45
			, Byte field46
			, Byte field47
			, Byte field48
			, Byte field49
			, Byte field50
			, Byte field51
			, Byte field52
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
			Field46 = field46;
			Field47 = field47;
			Field48 = field48;
			Field49 = field49;
			Field50 = field50;
			Field51 = field51;
			Field52 = field52;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
		public Byte Field25;
		public Byte Field26;
		public Byte Field27;
		public Byte Field28;
		public Byte Field29;
		public Byte Field30;
		public Byte Field31;
		public Byte Field32;
		public Byte Field33;
		public Byte Field34;
		public Byte Field35;
		public Byte Field36;
		public Byte Field37;
		public Byte Field38;
		public Byte Field39;
		public Byte Field40;
		public Byte Field41;
		public Byte Field42;
		public Byte Field43;
		public Byte Field44;
		public Byte Field45;
		public Byte Field46;
		public Byte Field47;
		public Byte Field48;
		public Byte Field49;
		public Byte Field50;
		public Byte Field51;
		public Byte Field52;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                46 => Field46,
                47 => Field47,
                48 => Field48,
                49 => Field49,
                50 => Field50,
                51 => Field51,
                52 => Field52,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
                    case 46: Field46 = value; break;
                    case 47: Field47 = value; break;
                    case 48: Field48 = value; break;
                    case 49: Field49 = value; break;
                    case 50: Field50 = value; break;
                    case 51: Field51 = value; break;
                    case 52: Field52 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray53) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray53)other);

        public readonly bool Equals(in FixedLengthByteArray53 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray53 left, in FixedLengthByteArray53 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray53 left, in FixedLengthByteArray53 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
              yield return Field46;
              yield return Field47;
              yield return Field48;
              yield return Field49;
              yield return Field50;
              yield return Field51;
              yield return Field52;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray53 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray53 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray53 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray53 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
                case 46: return ref array.Field46;
                case 47: return ref array.Field47;
                case 48: return ref array.Field48;
                case 49: return ref array.Field49;
                case 50: return ref array.Field50;
                case 51: return ref array.Field51;
                case 52: return ref array.Field52;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray53 array1, in FixedLengthByteArray53 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray53 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray53 array1, in FixedLengthByteArray53 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray53 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray53 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray53 array1, in FixedLengthByteArray53 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray53 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray53 array1, in FixedLengthByteArray53 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray53 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 54 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray54
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray54 _Zero = default;
		public static ref readonly FixedLengthByteArray54 Zero => ref _Zero;

		public const int ConstLength = 54;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray54(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
			, Byte field25
			, Byte field26
			, Byte field27
			, Byte field28
			, Byte field29
			, Byte field30
			, Byte field31
			, Byte field32
			, Byte field33
			, Byte field34
			, Byte field35
			, Byte field36
			, Byte field37
			, Byte field38
			, Byte field39
			, Byte field40
			, Byte field41
			, Byte field42
			, Byte field43
			, Byte field44
			, Byte field45
			, Byte field46
			, Byte field47
			, Byte field48
			, Byte field49
			, Byte field50
			, Byte field51
			, Byte field52
			, Byte field53
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
			Field46 = field46;
			Field47 = field47;
			Field48 = field48;
			Field49 = field49;
			Field50 = field50;
			Field51 = field51;
			Field52 = field52;
			Field53 = field53;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
		public Byte Field25;
		public Byte Field26;
		public Byte Field27;
		public Byte Field28;
		public Byte Field29;
		public Byte Field30;
		public Byte Field31;
		public Byte Field32;
		public Byte Field33;
		public Byte Field34;
		public Byte Field35;
		public Byte Field36;
		public Byte Field37;
		public Byte Field38;
		public Byte Field39;
		public Byte Field40;
		public Byte Field41;
		public Byte Field42;
		public Byte Field43;
		public Byte Field44;
		public Byte Field45;
		public Byte Field46;
		public Byte Field47;
		public Byte Field48;
		public Byte Field49;
		public Byte Field50;
		public Byte Field51;
		public Byte Field52;
		public Byte Field53;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                46 => Field46,
                47 => Field47,
                48 => Field48,
                49 => Field49,
                50 => Field50,
                51 => Field51,
                52 => Field52,
                53 => Field53,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
                    case 46: Field46 = value; break;
                    case 47: Field47 = value; break;
                    case 48: Field48 = value; break;
                    case 49: Field49 = value; break;
                    case 50: Field50 = value; break;
                    case 51: Field51 = value; break;
                    case 52: Field52 = value; break;
                    case 53: Field53 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray54) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray54)other);

        public readonly bool Equals(in FixedLengthByteArray54 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray54 left, in FixedLengthByteArray54 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray54 left, in FixedLengthByteArray54 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
              yield return Field46;
              yield return Field47;
              yield return Field48;
              yield return Field49;
              yield return Field50;
              yield return Field51;
              yield return Field52;
              yield return Field53;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray54 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray54 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray54 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray54 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
                case 46: return ref array.Field46;
                case 47: return ref array.Field47;
                case 48: return ref array.Field48;
                case 49: return ref array.Field49;
                case 50: return ref array.Field50;
                case 51: return ref array.Field51;
                case 52: return ref array.Field52;
                case 53: return ref array.Field53;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray54 array1, in FixedLengthByteArray54 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray54 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray54 array1, in FixedLengthByteArray54 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray54 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray54 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray54 array1, in FixedLengthByteArray54 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray54 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray54 array1, in FixedLengthByteArray54 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray54 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 55 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray55
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray55 _Zero = default;
		public static ref readonly FixedLengthByteArray55 Zero => ref _Zero;

		public const int ConstLength = 55;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray55(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
			, Byte field25
			, Byte field26
			, Byte field27
			, Byte field28
			, Byte field29
			, Byte field30
			, Byte field31
			, Byte field32
			, Byte field33
			, Byte field34
			, Byte field35
			, Byte field36
			, Byte field37
			, Byte field38
			, Byte field39
			, Byte field40
			, Byte field41
			, Byte field42
			, Byte field43
			, Byte field44
			, Byte field45
			, Byte field46
			, Byte field47
			, Byte field48
			, Byte field49
			, Byte field50
			, Byte field51
			, Byte field52
			, Byte field53
			, Byte field54
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
			Field46 = field46;
			Field47 = field47;
			Field48 = field48;
			Field49 = field49;
			Field50 = field50;
			Field51 = field51;
			Field52 = field52;
			Field53 = field53;
			Field54 = field54;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
		public Byte Field25;
		public Byte Field26;
		public Byte Field27;
		public Byte Field28;
		public Byte Field29;
		public Byte Field30;
		public Byte Field31;
		public Byte Field32;
		public Byte Field33;
		public Byte Field34;
		public Byte Field35;
		public Byte Field36;
		public Byte Field37;
		public Byte Field38;
		public Byte Field39;
		public Byte Field40;
		public Byte Field41;
		public Byte Field42;
		public Byte Field43;
		public Byte Field44;
		public Byte Field45;
		public Byte Field46;
		public Byte Field47;
		public Byte Field48;
		public Byte Field49;
		public Byte Field50;
		public Byte Field51;
		public Byte Field52;
		public Byte Field53;
		public Byte Field54;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                46 => Field46,
                47 => Field47,
                48 => Field48,
                49 => Field49,
                50 => Field50,
                51 => Field51,
                52 => Field52,
                53 => Field53,
                54 => Field54,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
                    case 46: Field46 = value; break;
                    case 47: Field47 = value; break;
                    case 48: Field48 = value; break;
                    case 49: Field49 = value; break;
                    case 50: Field50 = value; break;
                    case 51: Field51 = value; break;
                    case 52: Field52 = value; break;
                    case 53: Field53 = value; break;
                    case 54: Field54 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray55) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray55)other);

        public readonly bool Equals(in FixedLengthByteArray55 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray55 left, in FixedLengthByteArray55 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray55 left, in FixedLengthByteArray55 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
              yield return Field46;
              yield return Field47;
              yield return Field48;
              yield return Field49;
              yield return Field50;
              yield return Field51;
              yield return Field52;
              yield return Field53;
              yield return Field54;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray55 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray55 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray55 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray55 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
                case 46: return ref array.Field46;
                case 47: return ref array.Field47;
                case 48: return ref array.Field48;
                case 49: return ref array.Field49;
                case 50: return ref array.Field50;
                case 51: return ref array.Field51;
                case 52: return ref array.Field52;
                case 53: return ref array.Field53;
                case 54: return ref array.Field54;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray55 array1, in FixedLengthByteArray55 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray55 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray55 array1, in FixedLengthByteArray55 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray55 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray55 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray55 array1, in FixedLengthByteArray55 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray55 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray55 array1, in FixedLengthByteArray55 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray55 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 56 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray56
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray56 _Zero = default;
		public static ref readonly FixedLengthByteArray56 Zero => ref _Zero;

		public const int ConstLength = 56;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray56(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
			, Byte field25
			, Byte field26
			, Byte field27
			, Byte field28
			, Byte field29
			, Byte field30
			, Byte field31
			, Byte field32
			, Byte field33
			, Byte field34
			, Byte field35
			, Byte field36
			, Byte field37
			, Byte field38
			, Byte field39
			, Byte field40
			, Byte field41
			, Byte field42
			, Byte field43
			, Byte field44
			, Byte field45
			, Byte field46
			, Byte field47
			, Byte field48
			, Byte field49
			, Byte field50
			, Byte field51
			, Byte field52
			, Byte field53
			, Byte field54
			, Byte field55
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
			Field46 = field46;
			Field47 = field47;
			Field48 = field48;
			Field49 = field49;
			Field50 = field50;
			Field51 = field51;
			Field52 = field52;
			Field53 = field53;
			Field54 = field54;
			Field55 = field55;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
		public Byte Field25;
		public Byte Field26;
		public Byte Field27;
		public Byte Field28;
		public Byte Field29;
		public Byte Field30;
		public Byte Field31;
		public Byte Field32;
		public Byte Field33;
		public Byte Field34;
		public Byte Field35;
		public Byte Field36;
		public Byte Field37;
		public Byte Field38;
		public Byte Field39;
		public Byte Field40;
		public Byte Field41;
		public Byte Field42;
		public Byte Field43;
		public Byte Field44;
		public Byte Field45;
		public Byte Field46;
		public Byte Field47;
		public Byte Field48;
		public Byte Field49;
		public Byte Field50;
		public Byte Field51;
		public Byte Field52;
		public Byte Field53;
		public Byte Field54;
		public Byte Field55;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                46 => Field46,
                47 => Field47,
                48 => Field48,
                49 => Field49,
                50 => Field50,
                51 => Field51,
                52 => Field52,
                53 => Field53,
                54 => Field54,
                55 => Field55,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
                    case 46: Field46 = value; break;
                    case 47: Field47 = value; break;
                    case 48: Field48 = value; break;
                    case 49: Field49 = value; break;
                    case 50: Field50 = value; break;
                    case 51: Field51 = value; break;
                    case 52: Field52 = value; break;
                    case 53: Field53 = value; break;
                    case 54: Field54 = value; break;
                    case 55: Field55 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray56) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray56)other);

        public readonly bool Equals(in FixedLengthByteArray56 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray56 left, in FixedLengthByteArray56 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray56 left, in FixedLengthByteArray56 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
              yield return Field46;
              yield return Field47;
              yield return Field48;
              yield return Field49;
              yield return Field50;
              yield return Field51;
              yield return Field52;
              yield return Field53;
              yield return Field54;
              yield return Field55;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray56 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray56 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray56 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray56 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
                case 46: return ref array.Field46;
                case 47: return ref array.Field47;
                case 48: return ref array.Field48;
                case 49: return ref array.Field49;
                case 50: return ref array.Field50;
                case 51: return ref array.Field51;
                case 52: return ref array.Field52;
                case 53: return ref array.Field53;
                case 54: return ref array.Field54;
                case 55: return ref array.Field55;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray56 array1, in FixedLengthByteArray56 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray56 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray56 array1, in FixedLengthByteArray56 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray56 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray56 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray56 array1, in FixedLengthByteArray56 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray56 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray56 array1, in FixedLengthByteArray56 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray56 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 57 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray57
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray57 _Zero = default;
		public static ref readonly FixedLengthByteArray57 Zero => ref _Zero;

		public const int ConstLength = 57;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray57(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
			, Byte field25
			, Byte field26
			, Byte field27
			, Byte field28
			, Byte field29
			, Byte field30
			, Byte field31
			, Byte field32
			, Byte field33
			, Byte field34
			, Byte field35
			, Byte field36
			, Byte field37
			, Byte field38
			, Byte field39
			, Byte field40
			, Byte field41
			, Byte field42
			, Byte field43
			, Byte field44
			, Byte field45
			, Byte field46
			, Byte field47
			, Byte field48
			, Byte field49
			, Byte field50
			, Byte field51
			, Byte field52
			, Byte field53
			, Byte field54
			, Byte field55
			, Byte field56
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
			Field46 = field46;
			Field47 = field47;
			Field48 = field48;
			Field49 = field49;
			Field50 = field50;
			Field51 = field51;
			Field52 = field52;
			Field53 = field53;
			Field54 = field54;
			Field55 = field55;
			Field56 = field56;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
		public Byte Field25;
		public Byte Field26;
		public Byte Field27;
		public Byte Field28;
		public Byte Field29;
		public Byte Field30;
		public Byte Field31;
		public Byte Field32;
		public Byte Field33;
		public Byte Field34;
		public Byte Field35;
		public Byte Field36;
		public Byte Field37;
		public Byte Field38;
		public Byte Field39;
		public Byte Field40;
		public Byte Field41;
		public Byte Field42;
		public Byte Field43;
		public Byte Field44;
		public Byte Field45;
		public Byte Field46;
		public Byte Field47;
		public Byte Field48;
		public Byte Field49;
		public Byte Field50;
		public Byte Field51;
		public Byte Field52;
		public Byte Field53;
		public Byte Field54;
		public Byte Field55;
		public Byte Field56;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                46 => Field46,
                47 => Field47,
                48 => Field48,
                49 => Field49,
                50 => Field50,
                51 => Field51,
                52 => Field52,
                53 => Field53,
                54 => Field54,
                55 => Field55,
                56 => Field56,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
                    case 46: Field46 = value; break;
                    case 47: Field47 = value; break;
                    case 48: Field48 = value; break;
                    case 49: Field49 = value; break;
                    case 50: Field50 = value; break;
                    case 51: Field51 = value; break;
                    case 52: Field52 = value; break;
                    case 53: Field53 = value; break;
                    case 54: Field54 = value; break;
                    case 55: Field55 = value; break;
                    case 56: Field56 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray57) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray57)other);

        public readonly bool Equals(in FixedLengthByteArray57 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray57 left, in FixedLengthByteArray57 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray57 left, in FixedLengthByteArray57 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
              yield return Field46;
              yield return Field47;
              yield return Field48;
              yield return Field49;
              yield return Field50;
              yield return Field51;
              yield return Field52;
              yield return Field53;
              yield return Field54;
              yield return Field55;
              yield return Field56;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray57 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray57 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray57 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray57 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
                case 46: return ref array.Field46;
                case 47: return ref array.Field47;
                case 48: return ref array.Field48;
                case 49: return ref array.Field49;
                case 50: return ref array.Field50;
                case 51: return ref array.Field51;
                case 52: return ref array.Field52;
                case 53: return ref array.Field53;
                case 54: return ref array.Field54;
                case 55: return ref array.Field55;
                case 56: return ref array.Field56;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray57 array1, in FixedLengthByteArray57 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray57 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray57 array1, in FixedLengthByteArray57 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray57 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray57 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray57 array1, in FixedLengthByteArray57 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray57 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray57 array1, in FixedLengthByteArray57 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray57 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 58 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray58
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray58 _Zero = default;
		public static ref readonly FixedLengthByteArray58 Zero => ref _Zero;

		public const int ConstLength = 58;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray58(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
			, Byte field25
			, Byte field26
			, Byte field27
			, Byte field28
			, Byte field29
			, Byte field30
			, Byte field31
			, Byte field32
			, Byte field33
			, Byte field34
			, Byte field35
			, Byte field36
			, Byte field37
			, Byte field38
			, Byte field39
			, Byte field40
			, Byte field41
			, Byte field42
			, Byte field43
			, Byte field44
			, Byte field45
			, Byte field46
			, Byte field47
			, Byte field48
			, Byte field49
			, Byte field50
			, Byte field51
			, Byte field52
			, Byte field53
			, Byte field54
			, Byte field55
			, Byte field56
			, Byte field57
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
			Field46 = field46;
			Field47 = field47;
			Field48 = field48;
			Field49 = field49;
			Field50 = field50;
			Field51 = field51;
			Field52 = field52;
			Field53 = field53;
			Field54 = field54;
			Field55 = field55;
			Field56 = field56;
			Field57 = field57;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
		public Byte Field25;
		public Byte Field26;
		public Byte Field27;
		public Byte Field28;
		public Byte Field29;
		public Byte Field30;
		public Byte Field31;
		public Byte Field32;
		public Byte Field33;
		public Byte Field34;
		public Byte Field35;
		public Byte Field36;
		public Byte Field37;
		public Byte Field38;
		public Byte Field39;
		public Byte Field40;
		public Byte Field41;
		public Byte Field42;
		public Byte Field43;
		public Byte Field44;
		public Byte Field45;
		public Byte Field46;
		public Byte Field47;
		public Byte Field48;
		public Byte Field49;
		public Byte Field50;
		public Byte Field51;
		public Byte Field52;
		public Byte Field53;
		public Byte Field54;
		public Byte Field55;
		public Byte Field56;
		public Byte Field57;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                46 => Field46,
                47 => Field47,
                48 => Field48,
                49 => Field49,
                50 => Field50,
                51 => Field51,
                52 => Field52,
                53 => Field53,
                54 => Field54,
                55 => Field55,
                56 => Field56,
                57 => Field57,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
                    case 46: Field46 = value; break;
                    case 47: Field47 = value; break;
                    case 48: Field48 = value; break;
                    case 49: Field49 = value; break;
                    case 50: Field50 = value; break;
                    case 51: Field51 = value; break;
                    case 52: Field52 = value; break;
                    case 53: Field53 = value; break;
                    case 54: Field54 = value; break;
                    case 55: Field55 = value; break;
                    case 56: Field56 = value; break;
                    case 57: Field57 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray58) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray58)other);

        public readonly bool Equals(in FixedLengthByteArray58 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray58 left, in FixedLengthByteArray58 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray58 left, in FixedLengthByteArray58 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
              yield return Field46;
              yield return Field47;
              yield return Field48;
              yield return Field49;
              yield return Field50;
              yield return Field51;
              yield return Field52;
              yield return Field53;
              yield return Field54;
              yield return Field55;
              yield return Field56;
              yield return Field57;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray58 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray58 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray58 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray58 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
                case 46: return ref array.Field46;
                case 47: return ref array.Field47;
                case 48: return ref array.Field48;
                case 49: return ref array.Field49;
                case 50: return ref array.Field50;
                case 51: return ref array.Field51;
                case 52: return ref array.Field52;
                case 53: return ref array.Field53;
                case 54: return ref array.Field54;
                case 55: return ref array.Field55;
                case 56: return ref array.Field56;
                case 57: return ref array.Field57;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray58 array1, in FixedLengthByteArray58 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray58 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray58 array1, in FixedLengthByteArray58 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray58 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray58 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray58 array1, in FixedLengthByteArray58 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray58 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray58 array1, in FixedLengthByteArray58 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray58 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 59 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray59
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray59 _Zero = default;
		public static ref readonly FixedLengthByteArray59 Zero => ref _Zero;

		public const int ConstLength = 59;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray59(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
			, Byte field25
			, Byte field26
			, Byte field27
			, Byte field28
			, Byte field29
			, Byte field30
			, Byte field31
			, Byte field32
			, Byte field33
			, Byte field34
			, Byte field35
			, Byte field36
			, Byte field37
			, Byte field38
			, Byte field39
			, Byte field40
			, Byte field41
			, Byte field42
			, Byte field43
			, Byte field44
			, Byte field45
			, Byte field46
			, Byte field47
			, Byte field48
			, Byte field49
			, Byte field50
			, Byte field51
			, Byte field52
			, Byte field53
			, Byte field54
			, Byte field55
			, Byte field56
			, Byte field57
			, Byte field58
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
			Field46 = field46;
			Field47 = field47;
			Field48 = field48;
			Field49 = field49;
			Field50 = field50;
			Field51 = field51;
			Field52 = field52;
			Field53 = field53;
			Field54 = field54;
			Field55 = field55;
			Field56 = field56;
			Field57 = field57;
			Field58 = field58;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
		public Byte Field25;
		public Byte Field26;
		public Byte Field27;
		public Byte Field28;
		public Byte Field29;
		public Byte Field30;
		public Byte Field31;
		public Byte Field32;
		public Byte Field33;
		public Byte Field34;
		public Byte Field35;
		public Byte Field36;
		public Byte Field37;
		public Byte Field38;
		public Byte Field39;
		public Byte Field40;
		public Byte Field41;
		public Byte Field42;
		public Byte Field43;
		public Byte Field44;
		public Byte Field45;
		public Byte Field46;
		public Byte Field47;
		public Byte Field48;
		public Byte Field49;
		public Byte Field50;
		public Byte Field51;
		public Byte Field52;
		public Byte Field53;
		public Byte Field54;
		public Byte Field55;
		public Byte Field56;
		public Byte Field57;
		public Byte Field58;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                46 => Field46,
                47 => Field47,
                48 => Field48,
                49 => Field49,
                50 => Field50,
                51 => Field51,
                52 => Field52,
                53 => Field53,
                54 => Field54,
                55 => Field55,
                56 => Field56,
                57 => Field57,
                58 => Field58,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
                    case 46: Field46 = value; break;
                    case 47: Field47 = value; break;
                    case 48: Field48 = value; break;
                    case 49: Field49 = value; break;
                    case 50: Field50 = value; break;
                    case 51: Field51 = value; break;
                    case 52: Field52 = value; break;
                    case 53: Field53 = value; break;
                    case 54: Field54 = value; break;
                    case 55: Field55 = value; break;
                    case 56: Field56 = value; break;
                    case 57: Field57 = value; break;
                    case 58: Field58 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray59) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray59)other);

        public readonly bool Equals(in FixedLengthByteArray59 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray59 left, in FixedLengthByteArray59 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray59 left, in FixedLengthByteArray59 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
              yield return Field46;
              yield return Field47;
              yield return Field48;
              yield return Field49;
              yield return Field50;
              yield return Field51;
              yield return Field52;
              yield return Field53;
              yield return Field54;
              yield return Field55;
              yield return Field56;
              yield return Field57;
              yield return Field58;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray59 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray59 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray59 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray59 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
                case 46: return ref array.Field46;
                case 47: return ref array.Field47;
                case 48: return ref array.Field48;
                case 49: return ref array.Field49;
                case 50: return ref array.Field50;
                case 51: return ref array.Field51;
                case 52: return ref array.Field52;
                case 53: return ref array.Field53;
                case 54: return ref array.Field54;
                case 55: return ref array.Field55;
                case 56: return ref array.Field56;
                case 57: return ref array.Field57;
                case 58: return ref array.Field58;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray59 array1, in FixedLengthByteArray59 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray59 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray59 array1, in FixedLengthByteArray59 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray59 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray59 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray59 array1, in FixedLengthByteArray59 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray59 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray59 array1, in FixedLengthByteArray59 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray59 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 60 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray60
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray60 _Zero = default;
		public static ref readonly FixedLengthByteArray60 Zero => ref _Zero;

		public const int ConstLength = 60;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray60(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
			, Byte field25
			, Byte field26
			, Byte field27
			, Byte field28
			, Byte field29
			, Byte field30
			, Byte field31
			, Byte field32
			, Byte field33
			, Byte field34
			, Byte field35
			, Byte field36
			, Byte field37
			, Byte field38
			, Byte field39
			, Byte field40
			, Byte field41
			, Byte field42
			, Byte field43
			, Byte field44
			, Byte field45
			, Byte field46
			, Byte field47
			, Byte field48
			, Byte field49
			, Byte field50
			, Byte field51
			, Byte field52
			, Byte field53
			, Byte field54
			, Byte field55
			, Byte field56
			, Byte field57
			, Byte field58
			, Byte field59
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
			Field46 = field46;
			Field47 = field47;
			Field48 = field48;
			Field49 = field49;
			Field50 = field50;
			Field51 = field51;
			Field52 = field52;
			Field53 = field53;
			Field54 = field54;
			Field55 = field55;
			Field56 = field56;
			Field57 = field57;
			Field58 = field58;
			Field59 = field59;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
		public Byte Field25;
		public Byte Field26;
		public Byte Field27;
		public Byte Field28;
		public Byte Field29;
		public Byte Field30;
		public Byte Field31;
		public Byte Field32;
		public Byte Field33;
		public Byte Field34;
		public Byte Field35;
		public Byte Field36;
		public Byte Field37;
		public Byte Field38;
		public Byte Field39;
		public Byte Field40;
		public Byte Field41;
		public Byte Field42;
		public Byte Field43;
		public Byte Field44;
		public Byte Field45;
		public Byte Field46;
		public Byte Field47;
		public Byte Field48;
		public Byte Field49;
		public Byte Field50;
		public Byte Field51;
		public Byte Field52;
		public Byte Field53;
		public Byte Field54;
		public Byte Field55;
		public Byte Field56;
		public Byte Field57;
		public Byte Field58;
		public Byte Field59;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                46 => Field46,
                47 => Field47,
                48 => Field48,
                49 => Field49,
                50 => Field50,
                51 => Field51,
                52 => Field52,
                53 => Field53,
                54 => Field54,
                55 => Field55,
                56 => Field56,
                57 => Field57,
                58 => Field58,
                59 => Field59,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
                    case 46: Field46 = value; break;
                    case 47: Field47 = value; break;
                    case 48: Field48 = value; break;
                    case 49: Field49 = value; break;
                    case 50: Field50 = value; break;
                    case 51: Field51 = value; break;
                    case 52: Field52 = value; break;
                    case 53: Field53 = value; break;
                    case 54: Field54 = value; break;
                    case 55: Field55 = value; break;
                    case 56: Field56 = value; break;
                    case 57: Field57 = value; break;
                    case 58: Field58 = value; break;
                    case 59: Field59 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray60) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray60)other);

        public readonly bool Equals(in FixedLengthByteArray60 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray60 left, in FixedLengthByteArray60 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray60 left, in FixedLengthByteArray60 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
              yield return Field46;
              yield return Field47;
              yield return Field48;
              yield return Field49;
              yield return Field50;
              yield return Field51;
              yield return Field52;
              yield return Field53;
              yield return Field54;
              yield return Field55;
              yield return Field56;
              yield return Field57;
              yield return Field58;
              yield return Field59;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray60 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray60 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray60 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray60 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
                case 46: return ref array.Field46;
                case 47: return ref array.Field47;
                case 48: return ref array.Field48;
                case 49: return ref array.Field49;
                case 50: return ref array.Field50;
                case 51: return ref array.Field51;
                case 52: return ref array.Field52;
                case 53: return ref array.Field53;
                case 54: return ref array.Field54;
                case 55: return ref array.Field55;
                case 56: return ref array.Field56;
                case 57: return ref array.Field57;
                case 58: return ref array.Field58;
                case 59: return ref array.Field59;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray60 array1, in FixedLengthByteArray60 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray60 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray60 array1, in FixedLengthByteArray60 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray60 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray60 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray60 array1, in FixedLengthByteArray60 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray60 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray60 array1, in FixedLengthByteArray60 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray60 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 61 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray61
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray61 _Zero = default;
		public static ref readonly FixedLengthByteArray61 Zero => ref _Zero;

		public const int ConstLength = 61;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray61(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
			, Byte field25
			, Byte field26
			, Byte field27
			, Byte field28
			, Byte field29
			, Byte field30
			, Byte field31
			, Byte field32
			, Byte field33
			, Byte field34
			, Byte field35
			, Byte field36
			, Byte field37
			, Byte field38
			, Byte field39
			, Byte field40
			, Byte field41
			, Byte field42
			, Byte field43
			, Byte field44
			, Byte field45
			, Byte field46
			, Byte field47
			, Byte field48
			, Byte field49
			, Byte field50
			, Byte field51
			, Byte field52
			, Byte field53
			, Byte field54
			, Byte field55
			, Byte field56
			, Byte field57
			, Byte field58
			, Byte field59
			, Byte field60
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
			Field46 = field46;
			Field47 = field47;
			Field48 = field48;
			Field49 = field49;
			Field50 = field50;
			Field51 = field51;
			Field52 = field52;
			Field53 = field53;
			Field54 = field54;
			Field55 = field55;
			Field56 = field56;
			Field57 = field57;
			Field58 = field58;
			Field59 = field59;
			Field60 = field60;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
		public Byte Field25;
		public Byte Field26;
		public Byte Field27;
		public Byte Field28;
		public Byte Field29;
		public Byte Field30;
		public Byte Field31;
		public Byte Field32;
		public Byte Field33;
		public Byte Field34;
		public Byte Field35;
		public Byte Field36;
		public Byte Field37;
		public Byte Field38;
		public Byte Field39;
		public Byte Field40;
		public Byte Field41;
		public Byte Field42;
		public Byte Field43;
		public Byte Field44;
		public Byte Field45;
		public Byte Field46;
		public Byte Field47;
		public Byte Field48;
		public Byte Field49;
		public Byte Field50;
		public Byte Field51;
		public Byte Field52;
		public Byte Field53;
		public Byte Field54;
		public Byte Field55;
		public Byte Field56;
		public Byte Field57;
		public Byte Field58;
		public Byte Field59;
		public Byte Field60;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                46 => Field46,
                47 => Field47,
                48 => Field48,
                49 => Field49,
                50 => Field50,
                51 => Field51,
                52 => Field52,
                53 => Field53,
                54 => Field54,
                55 => Field55,
                56 => Field56,
                57 => Field57,
                58 => Field58,
                59 => Field59,
                60 => Field60,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
                    case 46: Field46 = value; break;
                    case 47: Field47 = value; break;
                    case 48: Field48 = value; break;
                    case 49: Field49 = value; break;
                    case 50: Field50 = value; break;
                    case 51: Field51 = value; break;
                    case 52: Field52 = value; break;
                    case 53: Field53 = value; break;
                    case 54: Field54 = value; break;
                    case 55: Field55 = value; break;
                    case 56: Field56 = value; break;
                    case 57: Field57 = value; break;
                    case 58: Field58 = value; break;
                    case 59: Field59 = value; break;
                    case 60: Field60 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray61) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray61)other);

        public readonly bool Equals(in FixedLengthByteArray61 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray61 left, in FixedLengthByteArray61 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray61 left, in FixedLengthByteArray61 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
              yield return Field46;
              yield return Field47;
              yield return Field48;
              yield return Field49;
              yield return Field50;
              yield return Field51;
              yield return Field52;
              yield return Field53;
              yield return Field54;
              yield return Field55;
              yield return Field56;
              yield return Field57;
              yield return Field58;
              yield return Field59;
              yield return Field60;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray61 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray61 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray61 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray61 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
                case 46: return ref array.Field46;
                case 47: return ref array.Field47;
                case 48: return ref array.Field48;
                case 49: return ref array.Field49;
                case 50: return ref array.Field50;
                case 51: return ref array.Field51;
                case 52: return ref array.Field52;
                case 53: return ref array.Field53;
                case 54: return ref array.Field54;
                case 55: return ref array.Field55;
                case 56: return ref array.Field56;
                case 57: return ref array.Field57;
                case 58: return ref array.Field58;
                case 59: return ref array.Field59;
                case 60: return ref array.Field60;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray61 array1, in FixedLengthByteArray61 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray61 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray61 array1, in FixedLengthByteArray61 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray61 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray61 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray61 array1, in FixedLengthByteArray61 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray61 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray61 array1, in FixedLengthByteArray61 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray61 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 62 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray62
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray62 _Zero = default;
		public static ref readonly FixedLengthByteArray62 Zero => ref _Zero;

		public const int ConstLength = 62;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray62(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
			, Byte field25
			, Byte field26
			, Byte field27
			, Byte field28
			, Byte field29
			, Byte field30
			, Byte field31
			, Byte field32
			, Byte field33
			, Byte field34
			, Byte field35
			, Byte field36
			, Byte field37
			, Byte field38
			, Byte field39
			, Byte field40
			, Byte field41
			, Byte field42
			, Byte field43
			, Byte field44
			, Byte field45
			, Byte field46
			, Byte field47
			, Byte field48
			, Byte field49
			, Byte field50
			, Byte field51
			, Byte field52
			, Byte field53
			, Byte field54
			, Byte field55
			, Byte field56
			, Byte field57
			, Byte field58
			, Byte field59
			, Byte field60
			, Byte field61
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
			Field46 = field46;
			Field47 = field47;
			Field48 = field48;
			Field49 = field49;
			Field50 = field50;
			Field51 = field51;
			Field52 = field52;
			Field53 = field53;
			Field54 = field54;
			Field55 = field55;
			Field56 = field56;
			Field57 = field57;
			Field58 = field58;
			Field59 = field59;
			Field60 = field60;
			Field61 = field61;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
		public Byte Field25;
		public Byte Field26;
		public Byte Field27;
		public Byte Field28;
		public Byte Field29;
		public Byte Field30;
		public Byte Field31;
		public Byte Field32;
		public Byte Field33;
		public Byte Field34;
		public Byte Field35;
		public Byte Field36;
		public Byte Field37;
		public Byte Field38;
		public Byte Field39;
		public Byte Field40;
		public Byte Field41;
		public Byte Field42;
		public Byte Field43;
		public Byte Field44;
		public Byte Field45;
		public Byte Field46;
		public Byte Field47;
		public Byte Field48;
		public Byte Field49;
		public Byte Field50;
		public Byte Field51;
		public Byte Field52;
		public Byte Field53;
		public Byte Field54;
		public Byte Field55;
		public Byte Field56;
		public Byte Field57;
		public Byte Field58;
		public Byte Field59;
		public Byte Field60;
		public Byte Field61;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                46 => Field46,
                47 => Field47,
                48 => Field48,
                49 => Field49,
                50 => Field50,
                51 => Field51,
                52 => Field52,
                53 => Field53,
                54 => Field54,
                55 => Field55,
                56 => Field56,
                57 => Field57,
                58 => Field58,
                59 => Field59,
                60 => Field60,
                61 => Field61,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
                    case 46: Field46 = value; break;
                    case 47: Field47 = value; break;
                    case 48: Field48 = value; break;
                    case 49: Field49 = value; break;
                    case 50: Field50 = value; break;
                    case 51: Field51 = value; break;
                    case 52: Field52 = value; break;
                    case 53: Field53 = value; break;
                    case 54: Field54 = value; break;
                    case 55: Field55 = value; break;
                    case 56: Field56 = value; break;
                    case 57: Field57 = value; break;
                    case 58: Field58 = value; break;
                    case 59: Field59 = value; break;
                    case 60: Field60 = value; break;
                    case 61: Field61 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray62) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray62)other);

        public readonly bool Equals(in FixedLengthByteArray62 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray62 left, in FixedLengthByteArray62 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray62 left, in FixedLengthByteArray62 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
              yield return Field46;
              yield return Field47;
              yield return Field48;
              yield return Field49;
              yield return Field50;
              yield return Field51;
              yield return Field52;
              yield return Field53;
              yield return Field54;
              yield return Field55;
              yield return Field56;
              yield return Field57;
              yield return Field58;
              yield return Field59;
              yield return Field60;
              yield return Field61;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray62 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray62 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray62 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray62 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
                case 46: return ref array.Field46;
                case 47: return ref array.Field47;
                case 48: return ref array.Field48;
                case 49: return ref array.Field49;
                case 50: return ref array.Field50;
                case 51: return ref array.Field51;
                case 52: return ref array.Field52;
                case 53: return ref array.Field53;
                case 54: return ref array.Field54;
                case 55: return ref array.Field55;
                case 56: return ref array.Field56;
                case 57: return ref array.Field57;
                case 58: return ref array.Field58;
                case 59: return ref array.Field59;
                case 60: return ref array.Field60;
                case 61: return ref array.Field61;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray62 array1, in FixedLengthByteArray62 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray62 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray62 array1, in FixedLengthByteArray62 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray62 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray62 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray62 array1, in FixedLengthByteArray62 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray62 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray62 array1, in FixedLengthByteArray62 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray62 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 63 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray63
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray63 _Zero = default;
		public static ref readonly FixedLengthByteArray63 Zero => ref _Zero;

		public const int ConstLength = 63;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray63(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
			, Byte field25
			, Byte field26
			, Byte field27
			, Byte field28
			, Byte field29
			, Byte field30
			, Byte field31
			, Byte field32
			, Byte field33
			, Byte field34
			, Byte field35
			, Byte field36
			, Byte field37
			, Byte field38
			, Byte field39
			, Byte field40
			, Byte field41
			, Byte field42
			, Byte field43
			, Byte field44
			, Byte field45
			, Byte field46
			, Byte field47
			, Byte field48
			, Byte field49
			, Byte field50
			, Byte field51
			, Byte field52
			, Byte field53
			, Byte field54
			, Byte field55
			, Byte field56
			, Byte field57
			, Byte field58
			, Byte field59
			, Byte field60
			, Byte field61
			, Byte field62
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
			Field46 = field46;
			Field47 = field47;
			Field48 = field48;
			Field49 = field49;
			Field50 = field50;
			Field51 = field51;
			Field52 = field52;
			Field53 = field53;
			Field54 = field54;
			Field55 = field55;
			Field56 = field56;
			Field57 = field57;
			Field58 = field58;
			Field59 = field59;
			Field60 = field60;
			Field61 = field61;
			Field62 = field62;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
		public Byte Field25;
		public Byte Field26;
		public Byte Field27;
		public Byte Field28;
		public Byte Field29;
		public Byte Field30;
		public Byte Field31;
		public Byte Field32;
		public Byte Field33;
		public Byte Field34;
		public Byte Field35;
		public Byte Field36;
		public Byte Field37;
		public Byte Field38;
		public Byte Field39;
		public Byte Field40;
		public Byte Field41;
		public Byte Field42;
		public Byte Field43;
		public Byte Field44;
		public Byte Field45;
		public Byte Field46;
		public Byte Field47;
		public Byte Field48;
		public Byte Field49;
		public Byte Field50;
		public Byte Field51;
		public Byte Field52;
		public Byte Field53;
		public Byte Field54;
		public Byte Field55;
		public Byte Field56;
		public Byte Field57;
		public Byte Field58;
		public Byte Field59;
		public Byte Field60;
		public Byte Field61;
		public Byte Field62;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                46 => Field46,
                47 => Field47,
                48 => Field48,
                49 => Field49,
                50 => Field50,
                51 => Field51,
                52 => Field52,
                53 => Field53,
                54 => Field54,
                55 => Field55,
                56 => Field56,
                57 => Field57,
                58 => Field58,
                59 => Field59,
                60 => Field60,
                61 => Field61,
                62 => Field62,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
                    case 46: Field46 = value; break;
                    case 47: Field47 = value; break;
                    case 48: Field48 = value; break;
                    case 49: Field49 = value; break;
                    case 50: Field50 = value; break;
                    case 51: Field51 = value; break;
                    case 52: Field52 = value; break;
                    case 53: Field53 = value; break;
                    case 54: Field54 = value; break;
                    case 55: Field55 = value; break;
                    case 56: Field56 = value; break;
                    case 57: Field57 = value; break;
                    case 58: Field58 = value; break;
                    case 59: Field59 = value; break;
                    case 60: Field60 = value; break;
                    case 61: Field61 = value; break;
                    case 62: Field62 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray63) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray63)other);

        public readonly bool Equals(in FixedLengthByteArray63 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray63 left, in FixedLengthByteArray63 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray63 left, in FixedLengthByteArray63 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
              yield return Field46;
              yield return Field47;
              yield return Field48;
              yield return Field49;
              yield return Field50;
              yield return Field51;
              yield return Field52;
              yield return Field53;
              yield return Field54;
              yield return Field55;
              yield return Field56;
              yield return Field57;
              yield return Field58;
              yield return Field59;
              yield return Field60;
              yield return Field61;
              yield return Field62;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray63 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray63 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray63 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray63 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
                case 46: return ref array.Field46;
                case 47: return ref array.Field47;
                case 48: return ref array.Field48;
                case 49: return ref array.Field49;
                case 50: return ref array.Field50;
                case 51: return ref array.Field51;
                case 52: return ref array.Field52;
                case 53: return ref array.Field53;
                case 54: return ref array.Field54;
                case 55: return ref array.Field55;
                case 56: return ref array.Field56;
                case 57: return ref array.Field57;
                case 58: return ref array.Field58;
                case 59: return ref array.Field59;
                case 60: return ref array.Field60;
                case 61: return ref array.Field61;
                case 62: return ref array.Field62;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray63 array1, in FixedLengthByteArray63 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray63 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray63 array1, in FixedLengthByteArray63 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray63 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray63 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray63 array1, in FixedLengthByteArray63 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray63 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray63 array1, in FixedLengthByteArray63 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray63 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 64 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray64
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray64 _Zero = default;
		public static ref readonly FixedLengthByteArray64 Zero => ref _Zero;

		public const int ConstLength = 64;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray64(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
			, Byte field25
			, Byte field26
			, Byte field27
			, Byte field28
			, Byte field29
			, Byte field30
			, Byte field31
			, Byte field32
			, Byte field33
			, Byte field34
			, Byte field35
			, Byte field36
			, Byte field37
			, Byte field38
			, Byte field39
			, Byte field40
			, Byte field41
			, Byte field42
			, Byte field43
			, Byte field44
			, Byte field45
			, Byte field46
			, Byte field47
			, Byte field48
			, Byte field49
			, Byte field50
			, Byte field51
			, Byte field52
			, Byte field53
			, Byte field54
			, Byte field55
			, Byte field56
			, Byte field57
			, Byte field58
			, Byte field59
			, Byte field60
			, Byte field61
			, Byte field62
			, Byte field63
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
			Field46 = field46;
			Field47 = field47;
			Field48 = field48;
			Field49 = field49;
			Field50 = field50;
			Field51 = field51;
			Field52 = field52;
			Field53 = field53;
			Field54 = field54;
			Field55 = field55;
			Field56 = field56;
			Field57 = field57;
			Field58 = field58;
			Field59 = field59;
			Field60 = field60;
			Field61 = field61;
			Field62 = field62;
			Field63 = field63;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
		public Byte Field25;
		public Byte Field26;
		public Byte Field27;
		public Byte Field28;
		public Byte Field29;
		public Byte Field30;
		public Byte Field31;
		public Byte Field32;
		public Byte Field33;
		public Byte Field34;
		public Byte Field35;
		public Byte Field36;
		public Byte Field37;
		public Byte Field38;
		public Byte Field39;
		public Byte Field40;
		public Byte Field41;
		public Byte Field42;
		public Byte Field43;
		public Byte Field44;
		public Byte Field45;
		public Byte Field46;
		public Byte Field47;
		public Byte Field48;
		public Byte Field49;
		public Byte Field50;
		public Byte Field51;
		public Byte Field52;
		public Byte Field53;
		public Byte Field54;
		public Byte Field55;
		public Byte Field56;
		public Byte Field57;
		public Byte Field58;
		public Byte Field59;
		public Byte Field60;
		public Byte Field61;
		public Byte Field62;
		public Byte Field63;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                46 => Field46,
                47 => Field47,
                48 => Field48,
                49 => Field49,
                50 => Field50,
                51 => Field51,
                52 => Field52,
                53 => Field53,
                54 => Field54,
                55 => Field55,
                56 => Field56,
                57 => Field57,
                58 => Field58,
                59 => Field59,
                60 => Field60,
                61 => Field61,
                62 => Field62,
                63 => Field63,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
                    case 46: Field46 = value; break;
                    case 47: Field47 = value; break;
                    case 48: Field48 = value; break;
                    case 49: Field49 = value; break;
                    case 50: Field50 = value; break;
                    case 51: Field51 = value; break;
                    case 52: Field52 = value; break;
                    case 53: Field53 = value; break;
                    case 54: Field54 = value; break;
                    case 55: Field55 = value; break;
                    case 56: Field56 = value; break;
                    case 57: Field57 = value; break;
                    case 58: Field58 = value; break;
                    case 59: Field59 = value; break;
                    case 60: Field60 = value; break;
                    case 61: Field61 = value; break;
                    case 62: Field62 = value; break;
                    case 63: Field63 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray64) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray64)other);

        public readonly bool Equals(in FixedLengthByteArray64 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray64 left, in FixedLengthByteArray64 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray64 left, in FixedLengthByteArray64 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
              yield return Field46;
              yield return Field47;
              yield return Field48;
              yield return Field49;
              yield return Field50;
              yield return Field51;
              yield return Field52;
              yield return Field53;
              yield return Field54;
              yield return Field55;
              yield return Field56;
              yield return Field57;
              yield return Field58;
              yield return Field59;
              yield return Field60;
              yield return Field61;
              yield return Field62;
              yield return Field63;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray64 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray64 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray64 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray64 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
                case 46: return ref array.Field46;
                case 47: return ref array.Field47;
                case 48: return ref array.Field48;
                case 49: return ref array.Field49;
                case 50: return ref array.Field50;
                case 51: return ref array.Field51;
                case 52: return ref array.Field52;
                case 53: return ref array.Field53;
                case 54: return ref array.Field54;
                case 55: return ref array.Field55;
                case 56: return ref array.Field56;
                case 57: return ref array.Field57;
                case 58: return ref array.Field58;
                case 59: return ref array.Field59;
                case 60: return ref array.Field60;
                case 61: return ref array.Field61;
                case 62: return ref array.Field62;
                case 63: return ref array.Field63;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray64 array1, in FixedLengthByteArray64 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray64 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray64 array1, in FixedLengthByteArray64 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray64 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray64 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray64 array1, in FixedLengthByteArray64 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray64 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray64 array1, in FixedLengthByteArray64 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray64 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 65 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray65
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray65 _Zero = default;
		public static ref readonly FixedLengthByteArray65 Zero => ref _Zero;

		public const int ConstLength = 65;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray65(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
			, Byte field25
			, Byte field26
			, Byte field27
			, Byte field28
			, Byte field29
			, Byte field30
			, Byte field31
			, Byte field32
			, Byte field33
			, Byte field34
			, Byte field35
			, Byte field36
			, Byte field37
			, Byte field38
			, Byte field39
			, Byte field40
			, Byte field41
			, Byte field42
			, Byte field43
			, Byte field44
			, Byte field45
			, Byte field46
			, Byte field47
			, Byte field48
			, Byte field49
			, Byte field50
			, Byte field51
			, Byte field52
			, Byte field53
			, Byte field54
			, Byte field55
			, Byte field56
			, Byte field57
			, Byte field58
			, Byte field59
			, Byte field60
			, Byte field61
			, Byte field62
			, Byte field63
			, Byte field64
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
			Field46 = field46;
			Field47 = field47;
			Field48 = field48;
			Field49 = field49;
			Field50 = field50;
			Field51 = field51;
			Field52 = field52;
			Field53 = field53;
			Field54 = field54;
			Field55 = field55;
			Field56 = field56;
			Field57 = field57;
			Field58 = field58;
			Field59 = field59;
			Field60 = field60;
			Field61 = field61;
			Field62 = field62;
			Field63 = field63;
			Field64 = field64;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
		public Byte Field25;
		public Byte Field26;
		public Byte Field27;
		public Byte Field28;
		public Byte Field29;
		public Byte Field30;
		public Byte Field31;
		public Byte Field32;
		public Byte Field33;
		public Byte Field34;
		public Byte Field35;
		public Byte Field36;
		public Byte Field37;
		public Byte Field38;
		public Byte Field39;
		public Byte Field40;
		public Byte Field41;
		public Byte Field42;
		public Byte Field43;
		public Byte Field44;
		public Byte Field45;
		public Byte Field46;
		public Byte Field47;
		public Byte Field48;
		public Byte Field49;
		public Byte Field50;
		public Byte Field51;
		public Byte Field52;
		public Byte Field53;
		public Byte Field54;
		public Byte Field55;
		public Byte Field56;
		public Byte Field57;
		public Byte Field58;
		public Byte Field59;
		public Byte Field60;
		public Byte Field61;
		public Byte Field62;
		public Byte Field63;
		public Byte Field64;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                46 => Field46,
                47 => Field47,
                48 => Field48,
                49 => Field49,
                50 => Field50,
                51 => Field51,
                52 => Field52,
                53 => Field53,
                54 => Field54,
                55 => Field55,
                56 => Field56,
                57 => Field57,
                58 => Field58,
                59 => Field59,
                60 => Field60,
                61 => Field61,
                62 => Field62,
                63 => Field63,
                64 => Field64,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
                    case 46: Field46 = value; break;
                    case 47: Field47 = value; break;
                    case 48: Field48 = value; break;
                    case 49: Field49 = value; break;
                    case 50: Field50 = value; break;
                    case 51: Field51 = value; break;
                    case 52: Field52 = value; break;
                    case 53: Field53 = value; break;
                    case 54: Field54 = value; break;
                    case 55: Field55 = value; break;
                    case 56: Field56 = value; break;
                    case 57: Field57 = value; break;
                    case 58: Field58 = value; break;
                    case 59: Field59 = value; break;
                    case 60: Field60 = value; break;
                    case 61: Field61 = value; break;
                    case 62: Field62 = value; break;
                    case 63: Field63 = value; break;
                    case 64: Field64 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray65) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray65)other);

        public readonly bool Equals(in FixedLengthByteArray65 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray65 left, in FixedLengthByteArray65 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray65 left, in FixedLengthByteArray65 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
              yield return Field46;
              yield return Field47;
              yield return Field48;
              yield return Field49;
              yield return Field50;
              yield return Field51;
              yield return Field52;
              yield return Field53;
              yield return Field54;
              yield return Field55;
              yield return Field56;
              yield return Field57;
              yield return Field58;
              yield return Field59;
              yield return Field60;
              yield return Field61;
              yield return Field62;
              yield return Field63;
              yield return Field64;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray65 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray65 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray65 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray65 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
                case 46: return ref array.Field46;
                case 47: return ref array.Field47;
                case 48: return ref array.Field48;
                case 49: return ref array.Field49;
                case 50: return ref array.Field50;
                case 51: return ref array.Field51;
                case 52: return ref array.Field52;
                case 53: return ref array.Field53;
                case 54: return ref array.Field54;
                case 55: return ref array.Field55;
                case 56: return ref array.Field56;
                case 57: return ref array.Field57;
                case 58: return ref array.Field58;
                case 59: return ref array.Field59;
                case 60: return ref array.Field60;
                case 61: return ref array.Field61;
                case 62: return ref array.Field62;
                case 63: return ref array.Field63;
                case 64: return ref array.Field64;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray65 array1, in FixedLengthByteArray65 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray65 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray65 array1, in FixedLengthByteArray65 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray65 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray65 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray65 array1, in FixedLengthByteArray65 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray65 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray65 array1, in FixedLengthByteArray65 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray65 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 96 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray96
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray96 _Zero = default;
		public static ref readonly FixedLengthByteArray96 Zero => ref _Zero;

		public const int ConstLength = 96;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray96(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
			, Byte field25
			, Byte field26
			, Byte field27
			, Byte field28
			, Byte field29
			, Byte field30
			, Byte field31
			, Byte field32
			, Byte field33
			, Byte field34
			, Byte field35
			, Byte field36
			, Byte field37
			, Byte field38
			, Byte field39
			, Byte field40
			, Byte field41
			, Byte field42
			, Byte field43
			, Byte field44
			, Byte field45
			, Byte field46
			, Byte field47
			, Byte field48
			, Byte field49
			, Byte field50
			, Byte field51
			, Byte field52
			, Byte field53
			, Byte field54
			, Byte field55
			, Byte field56
			, Byte field57
			, Byte field58
			, Byte field59
			, Byte field60
			, Byte field61
			, Byte field62
			, Byte field63
			, Byte field64
			, Byte field65
			, Byte field66
			, Byte field67
			, Byte field68
			, Byte field69
			, Byte field70
			, Byte field71
			, Byte field72
			, Byte field73
			, Byte field74
			, Byte field75
			, Byte field76
			, Byte field77
			, Byte field78
			, Byte field79
			, Byte field80
			, Byte field81
			, Byte field82
			, Byte field83
			, Byte field84
			, Byte field85
			, Byte field86
			, Byte field87
			, Byte field88
			, Byte field89
			, Byte field90
			, Byte field91
			, Byte field92
			, Byte field93
			, Byte field94
			, Byte field95
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
			Field46 = field46;
			Field47 = field47;
			Field48 = field48;
			Field49 = field49;
			Field50 = field50;
			Field51 = field51;
			Field52 = field52;
			Field53 = field53;
			Field54 = field54;
			Field55 = field55;
			Field56 = field56;
			Field57 = field57;
			Field58 = field58;
			Field59 = field59;
			Field60 = field60;
			Field61 = field61;
			Field62 = field62;
			Field63 = field63;
			Field64 = field64;
			Field65 = field65;
			Field66 = field66;
			Field67 = field67;
			Field68 = field68;
			Field69 = field69;
			Field70 = field70;
			Field71 = field71;
			Field72 = field72;
			Field73 = field73;
			Field74 = field74;
			Field75 = field75;
			Field76 = field76;
			Field77 = field77;
			Field78 = field78;
			Field79 = field79;
			Field80 = field80;
			Field81 = field81;
			Field82 = field82;
			Field83 = field83;
			Field84 = field84;
			Field85 = field85;
			Field86 = field86;
			Field87 = field87;
			Field88 = field88;
			Field89 = field89;
			Field90 = field90;
			Field91 = field91;
			Field92 = field92;
			Field93 = field93;
			Field94 = field94;
			Field95 = field95;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
		public Byte Field25;
		public Byte Field26;
		public Byte Field27;
		public Byte Field28;
		public Byte Field29;
		public Byte Field30;
		public Byte Field31;
		public Byte Field32;
		public Byte Field33;
		public Byte Field34;
		public Byte Field35;
		public Byte Field36;
		public Byte Field37;
		public Byte Field38;
		public Byte Field39;
		public Byte Field40;
		public Byte Field41;
		public Byte Field42;
		public Byte Field43;
		public Byte Field44;
		public Byte Field45;
		public Byte Field46;
		public Byte Field47;
		public Byte Field48;
		public Byte Field49;
		public Byte Field50;
		public Byte Field51;
		public Byte Field52;
		public Byte Field53;
		public Byte Field54;
		public Byte Field55;
		public Byte Field56;
		public Byte Field57;
		public Byte Field58;
		public Byte Field59;
		public Byte Field60;
		public Byte Field61;
		public Byte Field62;
		public Byte Field63;
		public Byte Field64;
		public Byte Field65;
		public Byte Field66;
		public Byte Field67;
		public Byte Field68;
		public Byte Field69;
		public Byte Field70;
		public Byte Field71;
		public Byte Field72;
		public Byte Field73;
		public Byte Field74;
		public Byte Field75;
		public Byte Field76;
		public Byte Field77;
		public Byte Field78;
		public Byte Field79;
		public Byte Field80;
		public Byte Field81;
		public Byte Field82;
		public Byte Field83;
		public Byte Field84;
		public Byte Field85;
		public Byte Field86;
		public Byte Field87;
		public Byte Field88;
		public Byte Field89;
		public Byte Field90;
		public Byte Field91;
		public Byte Field92;
		public Byte Field93;
		public Byte Field94;
		public Byte Field95;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                46 => Field46,
                47 => Field47,
                48 => Field48,
                49 => Field49,
                50 => Field50,
                51 => Field51,
                52 => Field52,
                53 => Field53,
                54 => Field54,
                55 => Field55,
                56 => Field56,
                57 => Field57,
                58 => Field58,
                59 => Field59,
                60 => Field60,
                61 => Field61,
                62 => Field62,
                63 => Field63,
                64 => Field64,
                65 => Field65,
                66 => Field66,
                67 => Field67,
                68 => Field68,
                69 => Field69,
                70 => Field70,
                71 => Field71,
                72 => Field72,
                73 => Field73,
                74 => Field74,
                75 => Field75,
                76 => Field76,
                77 => Field77,
                78 => Field78,
                79 => Field79,
                80 => Field80,
                81 => Field81,
                82 => Field82,
                83 => Field83,
                84 => Field84,
                85 => Field85,
                86 => Field86,
                87 => Field87,
                88 => Field88,
                89 => Field89,
                90 => Field90,
                91 => Field91,
                92 => Field92,
                93 => Field93,
                94 => Field94,
                95 => Field95,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
                    case 46: Field46 = value; break;
                    case 47: Field47 = value; break;
                    case 48: Field48 = value; break;
                    case 49: Field49 = value; break;
                    case 50: Field50 = value; break;
                    case 51: Field51 = value; break;
                    case 52: Field52 = value; break;
                    case 53: Field53 = value; break;
                    case 54: Field54 = value; break;
                    case 55: Field55 = value; break;
                    case 56: Field56 = value; break;
                    case 57: Field57 = value; break;
                    case 58: Field58 = value; break;
                    case 59: Field59 = value; break;
                    case 60: Field60 = value; break;
                    case 61: Field61 = value; break;
                    case 62: Field62 = value; break;
                    case 63: Field63 = value; break;
                    case 64: Field64 = value; break;
                    case 65: Field65 = value; break;
                    case 66: Field66 = value; break;
                    case 67: Field67 = value; break;
                    case 68: Field68 = value; break;
                    case 69: Field69 = value; break;
                    case 70: Field70 = value; break;
                    case 71: Field71 = value; break;
                    case 72: Field72 = value; break;
                    case 73: Field73 = value; break;
                    case 74: Field74 = value; break;
                    case 75: Field75 = value; break;
                    case 76: Field76 = value; break;
                    case 77: Field77 = value; break;
                    case 78: Field78 = value; break;
                    case 79: Field79 = value; break;
                    case 80: Field80 = value; break;
                    case 81: Field81 = value; break;
                    case 82: Field82 = value; break;
                    case 83: Field83 = value; break;
                    case 84: Field84 = value; break;
                    case 85: Field85 = value; break;
                    case 86: Field86 = value; break;
                    case 87: Field87 = value; break;
                    case 88: Field88 = value; break;
                    case 89: Field89 = value; break;
                    case 90: Field90 = value; break;
                    case 91: Field91 = value; break;
                    case 92: Field92 = value; break;
                    case 93: Field93 = value; break;
                    case 94: Field94 = value; break;
                    case 95: Field95 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray96) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray96)other);

        public readonly bool Equals(in FixedLengthByteArray96 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray96 left, in FixedLengthByteArray96 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray96 left, in FixedLengthByteArray96 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
              yield return Field46;
              yield return Field47;
              yield return Field48;
              yield return Field49;
              yield return Field50;
              yield return Field51;
              yield return Field52;
              yield return Field53;
              yield return Field54;
              yield return Field55;
              yield return Field56;
              yield return Field57;
              yield return Field58;
              yield return Field59;
              yield return Field60;
              yield return Field61;
              yield return Field62;
              yield return Field63;
              yield return Field64;
              yield return Field65;
              yield return Field66;
              yield return Field67;
              yield return Field68;
              yield return Field69;
              yield return Field70;
              yield return Field71;
              yield return Field72;
              yield return Field73;
              yield return Field74;
              yield return Field75;
              yield return Field76;
              yield return Field77;
              yield return Field78;
              yield return Field79;
              yield return Field80;
              yield return Field81;
              yield return Field82;
              yield return Field83;
              yield return Field84;
              yield return Field85;
              yield return Field86;
              yield return Field87;
              yield return Field88;
              yield return Field89;
              yield return Field90;
              yield return Field91;
              yield return Field92;
              yield return Field93;
              yield return Field94;
              yield return Field95;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray96 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray96 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray96 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray96 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
                case 46: return ref array.Field46;
                case 47: return ref array.Field47;
                case 48: return ref array.Field48;
                case 49: return ref array.Field49;
                case 50: return ref array.Field50;
                case 51: return ref array.Field51;
                case 52: return ref array.Field52;
                case 53: return ref array.Field53;
                case 54: return ref array.Field54;
                case 55: return ref array.Field55;
                case 56: return ref array.Field56;
                case 57: return ref array.Field57;
                case 58: return ref array.Field58;
                case 59: return ref array.Field59;
                case 60: return ref array.Field60;
                case 61: return ref array.Field61;
                case 62: return ref array.Field62;
                case 63: return ref array.Field63;
                case 64: return ref array.Field64;
                case 65: return ref array.Field65;
                case 66: return ref array.Field66;
                case 67: return ref array.Field67;
                case 68: return ref array.Field68;
                case 69: return ref array.Field69;
                case 70: return ref array.Field70;
                case 71: return ref array.Field71;
                case 72: return ref array.Field72;
                case 73: return ref array.Field73;
                case 74: return ref array.Field74;
                case 75: return ref array.Field75;
                case 76: return ref array.Field76;
                case 77: return ref array.Field77;
                case 78: return ref array.Field78;
                case 79: return ref array.Field79;
                case 80: return ref array.Field80;
                case 81: return ref array.Field81;
                case 82: return ref array.Field82;
                case 83: return ref array.Field83;
                case 84: return ref array.Field84;
                case 85: return ref array.Field85;
                case 86: return ref array.Field86;
                case 87: return ref array.Field87;
                case 88: return ref array.Field88;
                case 89: return ref array.Field89;
                case 90: return ref array.Field90;
                case 91: return ref array.Field91;
                case 92: return ref array.Field92;
                case 93: return ref array.Field93;
                case 94: return ref array.Field94;
                case 95: return ref array.Field95;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray96 array1, in FixedLengthByteArray96 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray96 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray96 array1, in FixedLengthByteArray96 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray96 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray96 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray96 array1, in FixedLengthByteArray96 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray96 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray96 array1, in FixedLengthByteArray96 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray96 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 128 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray128
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray128 _Zero = default;
		public static ref readonly FixedLengthByteArray128 Zero => ref _Zero;

		public const int ConstLength = 128;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray128(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
			, Byte field25
			, Byte field26
			, Byte field27
			, Byte field28
			, Byte field29
			, Byte field30
			, Byte field31
			, Byte field32
			, Byte field33
			, Byte field34
			, Byte field35
			, Byte field36
			, Byte field37
			, Byte field38
			, Byte field39
			, Byte field40
			, Byte field41
			, Byte field42
			, Byte field43
			, Byte field44
			, Byte field45
			, Byte field46
			, Byte field47
			, Byte field48
			, Byte field49
			, Byte field50
			, Byte field51
			, Byte field52
			, Byte field53
			, Byte field54
			, Byte field55
			, Byte field56
			, Byte field57
			, Byte field58
			, Byte field59
			, Byte field60
			, Byte field61
			, Byte field62
			, Byte field63
			, Byte field64
			, Byte field65
			, Byte field66
			, Byte field67
			, Byte field68
			, Byte field69
			, Byte field70
			, Byte field71
			, Byte field72
			, Byte field73
			, Byte field74
			, Byte field75
			, Byte field76
			, Byte field77
			, Byte field78
			, Byte field79
			, Byte field80
			, Byte field81
			, Byte field82
			, Byte field83
			, Byte field84
			, Byte field85
			, Byte field86
			, Byte field87
			, Byte field88
			, Byte field89
			, Byte field90
			, Byte field91
			, Byte field92
			, Byte field93
			, Byte field94
			, Byte field95
			, Byte field96
			, Byte field97
			, Byte field98
			, Byte field99
			, Byte field100
			, Byte field101
			, Byte field102
			, Byte field103
			, Byte field104
			, Byte field105
			, Byte field106
			, Byte field107
			, Byte field108
			, Byte field109
			, Byte field110
			, Byte field111
			, Byte field112
			, Byte field113
			, Byte field114
			, Byte field115
			, Byte field116
			, Byte field117
			, Byte field118
			, Byte field119
			, Byte field120
			, Byte field121
			, Byte field122
			, Byte field123
			, Byte field124
			, Byte field125
			, Byte field126
			, Byte field127
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
			Field46 = field46;
			Field47 = field47;
			Field48 = field48;
			Field49 = field49;
			Field50 = field50;
			Field51 = field51;
			Field52 = field52;
			Field53 = field53;
			Field54 = field54;
			Field55 = field55;
			Field56 = field56;
			Field57 = field57;
			Field58 = field58;
			Field59 = field59;
			Field60 = field60;
			Field61 = field61;
			Field62 = field62;
			Field63 = field63;
			Field64 = field64;
			Field65 = field65;
			Field66 = field66;
			Field67 = field67;
			Field68 = field68;
			Field69 = field69;
			Field70 = field70;
			Field71 = field71;
			Field72 = field72;
			Field73 = field73;
			Field74 = field74;
			Field75 = field75;
			Field76 = field76;
			Field77 = field77;
			Field78 = field78;
			Field79 = field79;
			Field80 = field80;
			Field81 = field81;
			Field82 = field82;
			Field83 = field83;
			Field84 = field84;
			Field85 = field85;
			Field86 = field86;
			Field87 = field87;
			Field88 = field88;
			Field89 = field89;
			Field90 = field90;
			Field91 = field91;
			Field92 = field92;
			Field93 = field93;
			Field94 = field94;
			Field95 = field95;
			Field96 = field96;
			Field97 = field97;
			Field98 = field98;
			Field99 = field99;
			Field100 = field100;
			Field101 = field101;
			Field102 = field102;
			Field103 = field103;
			Field104 = field104;
			Field105 = field105;
			Field106 = field106;
			Field107 = field107;
			Field108 = field108;
			Field109 = field109;
			Field110 = field110;
			Field111 = field111;
			Field112 = field112;
			Field113 = field113;
			Field114 = field114;
			Field115 = field115;
			Field116 = field116;
			Field117 = field117;
			Field118 = field118;
			Field119 = field119;
			Field120 = field120;
			Field121 = field121;
			Field122 = field122;
			Field123 = field123;
			Field124 = field124;
			Field125 = field125;
			Field126 = field126;
			Field127 = field127;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
		public Byte Field25;
		public Byte Field26;
		public Byte Field27;
		public Byte Field28;
		public Byte Field29;
		public Byte Field30;
		public Byte Field31;
		public Byte Field32;
		public Byte Field33;
		public Byte Field34;
		public Byte Field35;
		public Byte Field36;
		public Byte Field37;
		public Byte Field38;
		public Byte Field39;
		public Byte Field40;
		public Byte Field41;
		public Byte Field42;
		public Byte Field43;
		public Byte Field44;
		public Byte Field45;
		public Byte Field46;
		public Byte Field47;
		public Byte Field48;
		public Byte Field49;
		public Byte Field50;
		public Byte Field51;
		public Byte Field52;
		public Byte Field53;
		public Byte Field54;
		public Byte Field55;
		public Byte Field56;
		public Byte Field57;
		public Byte Field58;
		public Byte Field59;
		public Byte Field60;
		public Byte Field61;
		public Byte Field62;
		public Byte Field63;
		public Byte Field64;
		public Byte Field65;
		public Byte Field66;
		public Byte Field67;
		public Byte Field68;
		public Byte Field69;
		public Byte Field70;
		public Byte Field71;
		public Byte Field72;
		public Byte Field73;
		public Byte Field74;
		public Byte Field75;
		public Byte Field76;
		public Byte Field77;
		public Byte Field78;
		public Byte Field79;
		public Byte Field80;
		public Byte Field81;
		public Byte Field82;
		public Byte Field83;
		public Byte Field84;
		public Byte Field85;
		public Byte Field86;
		public Byte Field87;
		public Byte Field88;
		public Byte Field89;
		public Byte Field90;
		public Byte Field91;
		public Byte Field92;
		public Byte Field93;
		public Byte Field94;
		public Byte Field95;
		public Byte Field96;
		public Byte Field97;
		public Byte Field98;
		public Byte Field99;
		public Byte Field100;
		public Byte Field101;
		public Byte Field102;
		public Byte Field103;
		public Byte Field104;
		public Byte Field105;
		public Byte Field106;
		public Byte Field107;
		public Byte Field108;
		public Byte Field109;
		public Byte Field110;
		public Byte Field111;
		public Byte Field112;
		public Byte Field113;
		public Byte Field114;
		public Byte Field115;
		public Byte Field116;
		public Byte Field117;
		public Byte Field118;
		public Byte Field119;
		public Byte Field120;
		public Byte Field121;
		public Byte Field122;
		public Byte Field123;
		public Byte Field124;
		public Byte Field125;
		public Byte Field126;
		public Byte Field127;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                46 => Field46,
                47 => Field47,
                48 => Field48,
                49 => Field49,
                50 => Field50,
                51 => Field51,
                52 => Field52,
                53 => Field53,
                54 => Field54,
                55 => Field55,
                56 => Field56,
                57 => Field57,
                58 => Field58,
                59 => Field59,
                60 => Field60,
                61 => Field61,
                62 => Field62,
                63 => Field63,
                64 => Field64,
                65 => Field65,
                66 => Field66,
                67 => Field67,
                68 => Field68,
                69 => Field69,
                70 => Field70,
                71 => Field71,
                72 => Field72,
                73 => Field73,
                74 => Field74,
                75 => Field75,
                76 => Field76,
                77 => Field77,
                78 => Field78,
                79 => Field79,
                80 => Field80,
                81 => Field81,
                82 => Field82,
                83 => Field83,
                84 => Field84,
                85 => Field85,
                86 => Field86,
                87 => Field87,
                88 => Field88,
                89 => Field89,
                90 => Field90,
                91 => Field91,
                92 => Field92,
                93 => Field93,
                94 => Field94,
                95 => Field95,
                96 => Field96,
                97 => Field97,
                98 => Field98,
                99 => Field99,
                100 => Field100,
                101 => Field101,
                102 => Field102,
                103 => Field103,
                104 => Field104,
                105 => Field105,
                106 => Field106,
                107 => Field107,
                108 => Field108,
                109 => Field109,
                110 => Field110,
                111 => Field111,
                112 => Field112,
                113 => Field113,
                114 => Field114,
                115 => Field115,
                116 => Field116,
                117 => Field117,
                118 => Field118,
                119 => Field119,
                120 => Field120,
                121 => Field121,
                122 => Field122,
                123 => Field123,
                124 => Field124,
                125 => Field125,
                126 => Field126,
                127 => Field127,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
                    case 46: Field46 = value; break;
                    case 47: Field47 = value; break;
                    case 48: Field48 = value; break;
                    case 49: Field49 = value; break;
                    case 50: Field50 = value; break;
                    case 51: Field51 = value; break;
                    case 52: Field52 = value; break;
                    case 53: Field53 = value; break;
                    case 54: Field54 = value; break;
                    case 55: Field55 = value; break;
                    case 56: Field56 = value; break;
                    case 57: Field57 = value; break;
                    case 58: Field58 = value; break;
                    case 59: Field59 = value; break;
                    case 60: Field60 = value; break;
                    case 61: Field61 = value; break;
                    case 62: Field62 = value; break;
                    case 63: Field63 = value; break;
                    case 64: Field64 = value; break;
                    case 65: Field65 = value; break;
                    case 66: Field66 = value; break;
                    case 67: Field67 = value; break;
                    case 68: Field68 = value; break;
                    case 69: Field69 = value; break;
                    case 70: Field70 = value; break;
                    case 71: Field71 = value; break;
                    case 72: Field72 = value; break;
                    case 73: Field73 = value; break;
                    case 74: Field74 = value; break;
                    case 75: Field75 = value; break;
                    case 76: Field76 = value; break;
                    case 77: Field77 = value; break;
                    case 78: Field78 = value; break;
                    case 79: Field79 = value; break;
                    case 80: Field80 = value; break;
                    case 81: Field81 = value; break;
                    case 82: Field82 = value; break;
                    case 83: Field83 = value; break;
                    case 84: Field84 = value; break;
                    case 85: Field85 = value; break;
                    case 86: Field86 = value; break;
                    case 87: Field87 = value; break;
                    case 88: Field88 = value; break;
                    case 89: Field89 = value; break;
                    case 90: Field90 = value; break;
                    case 91: Field91 = value; break;
                    case 92: Field92 = value; break;
                    case 93: Field93 = value; break;
                    case 94: Field94 = value; break;
                    case 95: Field95 = value; break;
                    case 96: Field96 = value; break;
                    case 97: Field97 = value; break;
                    case 98: Field98 = value; break;
                    case 99: Field99 = value; break;
                    case 100: Field100 = value; break;
                    case 101: Field101 = value; break;
                    case 102: Field102 = value; break;
                    case 103: Field103 = value; break;
                    case 104: Field104 = value; break;
                    case 105: Field105 = value; break;
                    case 106: Field106 = value; break;
                    case 107: Field107 = value; break;
                    case 108: Field108 = value; break;
                    case 109: Field109 = value; break;
                    case 110: Field110 = value; break;
                    case 111: Field111 = value; break;
                    case 112: Field112 = value; break;
                    case 113: Field113 = value; break;
                    case 114: Field114 = value; break;
                    case 115: Field115 = value; break;
                    case 116: Field116 = value; break;
                    case 117: Field117 = value; break;
                    case 118: Field118 = value; break;
                    case 119: Field119 = value; break;
                    case 120: Field120 = value; break;
                    case 121: Field121 = value; break;
                    case 122: Field122 = value; break;
                    case 123: Field123 = value; break;
                    case 124: Field124 = value; break;
                    case 125: Field125 = value; break;
                    case 126: Field126 = value; break;
                    case 127: Field127 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray128) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray128)other);

        public readonly bool Equals(in FixedLengthByteArray128 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray128 left, in FixedLengthByteArray128 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray128 left, in FixedLengthByteArray128 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
              yield return Field46;
              yield return Field47;
              yield return Field48;
              yield return Field49;
              yield return Field50;
              yield return Field51;
              yield return Field52;
              yield return Field53;
              yield return Field54;
              yield return Field55;
              yield return Field56;
              yield return Field57;
              yield return Field58;
              yield return Field59;
              yield return Field60;
              yield return Field61;
              yield return Field62;
              yield return Field63;
              yield return Field64;
              yield return Field65;
              yield return Field66;
              yield return Field67;
              yield return Field68;
              yield return Field69;
              yield return Field70;
              yield return Field71;
              yield return Field72;
              yield return Field73;
              yield return Field74;
              yield return Field75;
              yield return Field76;
              yield return Field77;
              yield return Field78;
              yield return Field79;
              yield return Field80;
              yield return Field81;
              yield return Field82;
              yield return Field83;
              yield return Field84;
              yield return Field85;
              yield return Field86;
              yield return Field87;
              yield return Field88;
              yield return Field89;
              yield return Field90;
              yield return Field91;
              yield return Field92;
              yield return Field93;
              yield return Field94;
              yield return Field95;
              yield return Field96;
              yield return Field97;
              yield return Field98;
              yield return Field99;
              yield return Field100;
              yield return Field101;
              yield return Field102;
              yield return Field103;
              yield return Field104;
              yield return Field105;
              yield return Field106;
              yield return Field107;
              yield return Field108;
              yield return Field109;
              yield return Field110;
              yield return Field111;
              yield return Field112;
              yield return Field113;
              yield return Field114;
              yield return Field115;
              yield return Field116;
              yield return Field117;
              yield return Field118;
              yield return Field119;
              yield return Field120;
              yield return Field121;
              yield return Field122;
              yield return Field123;
              yield return Field124;
              yield return Field125;
              yield return Field126;
              yield return Field127;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray128 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray128 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray128 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray128 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
                case 46: return ref array.Field46;
                case 47: return ref array.Field47;
                case 48: return ref array.Field48;
                case 49: return ref array.Field49;
                case 50: return ref array.Field50;
                case 51: return ref array.Field51;
                case 52: return ref array.Field52;
                case 53: return ref array.Field53;
                case 54: return ref array.Field54;
                case 55: return ref array.Field55;
                case 56: return ref array.Field56;
                case 57: return ref array.Field57;
                case 58: return ref array.Field58;
                case 59: return ref array.Field59;
                case 60: return ref array.Field60;
                case 61: return ref array.Field61;
                case 62: return ref array.Field62;
                case 63: return ref array.Field63;
                case 64: return ref array.Field64;
                case 65: return ref array.Field65;
                case 66: return ref array.Field66;
                case 67: return ref array.Field67;
                case 68: return ref array.Field68;
                case 69: return ref array.Field69;
                case 70: return ref array.Field70;
                case 71: return ref array.Field71;
                case 72: return ref array.Field72;
                case 73: return ref array.Field73;
                case 74: return ref array.Field74;
                case 75: return ref array.Field75;
                case 76: return ref array.Field76;
                case 77: return ref array.Field77;
                case 78: return ref array.Field78;
                case 79: return ref array.Field79;
                case 80: return ref array.Field80;
                case 81: return ref array.Field81;
                case 82: return ref array.Field82;
                case 83: return ref array.Field83;
                case 84: return ref array.Field84;
                case 85: return ref array.Field85;
                case 86: return ref array.Field86;
                case 87: return ref array.Field87;
                case 88: return ref array.Field88;
                case 89: return ref array.Field89;
                case 90: return ref array.Field90;
                case 91: return ref array.Field91;
                case 92: return ref array.Field92;
                case 93: return ref array.Field93;
                case 94: return ref array.Field94;
                case 95: return ref array.Field95;
                case 96: return ref array.Field96;
                case 97: return ref array.Field97;
                case 98: return ref array.Field98;
                case 99: return ref array.Field99;
                case 100: return ref array.Field100;
                case 101: return ref array.Field101;
                case 102: return ref array.Field102;
                case 103: return ref array.Field103;
                case 104: return ref array.Field104;
                case 105: return ref array.Field105;
                case 106: return ref array.Field106;
                case 107: return ref array.Field107;
                case 108: return ref array.Field108;
                case 109: return ref array.Field109;
                case 110: return ref array.Field110;
                case 111: return ref array.Field111;
                case 112: return ref array.Field112;
                case 113: return ref array.Field113;
                case 114: return ref array.Field114;
                case 115: return ref array.Field115;
                case 116: return ref array.Field116;
                case 117: return ref array.Field117;
                case 118: return ref array.Field118;
                case 119: return ref array.Field119;
                case 120: return ref array.Field120;
                case 121: return ref array.Field121;
                case 122: return ref array.Field122;
                case 123: return ref array.Field123;
                case 124: return ref array.Field124;
                case 125: return ref array.Field125;
                case 126: return ref array.Field126;
                case 127: return ref array.Field127;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray128 array1, in FixedLengthByteArray128 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray128 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray128 array1, in FixedLengthByteArray128 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray128 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray128 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray128 array1, in FixedLengthByteArray128 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray128 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray128 array1, in FixedLengthByteArray128 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray128 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 192 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray192
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray192 _Zero = default;
		public static ref readonly FixedLengthByteArray192 Zero => ref _Zero;

		public const int ConstLength = 192;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray192(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
			, Byte field25
			, Byte field26
			, Byte field27
			, Byte field28
			, Byte field29
			, Byte field30
			, Byte field31
			, Byte field32
			, Byte field33
			, Byte field34
			, Byte field35
			, Byte field36
			, Byte field37
			, Byte field38
			, Byte field39
			, Byte field40
			, Byte field41
			, Byte field42
			, Byte field43
			, Byte field44
			, Byte field45
			, Byte field46
			, Byte field47
			, Byte field48
			, Byte field49
			, Byte field50
			, Byte field51
			, Byte field52
			, Byte field53
			, Byte field54
			, Byte field55
			, Byte field56
			, Byte field57
			, Byte field58
			, Byte field59
			, Byte field60
			, Byte field61
			, Byte field62
			, Byte field63
			, Byte field64
			, Byte field65
			, Byte field66
			, Byte field67
			, Byte field68
			, Byte field69
			, Byte field70
			, Byte field71
			, Byte field72
			, Byte field73
			, Byte field74
			, Byte field75
			, Byte field76
			, Byte field77
			, Byte field78
			, Byte field79
			, Byte field80
			, Byte field81
			, Byte field82
			, Byte field83
			, Byte field84
			, Byte field85
			, Byte field86
			, Byte field87
			, Byte field88
			, Byte field89
			, Byte field90
			, Byte field91
			, Byte field92
			, Byte field93
			, Byte field94
			, Byte field95
			, Byte field96
			, Byte field97
			, Byte field98
			, Byte field99
			, Byte field100
			, Byte field101
			, Byte field102
			, Byte field103
			, Byte field104
			, Byte field105
			, Byte field106
			, Byte field107
			, Byte field108
			, Byte field109
			, Byte field110
			, Byte field111
			, Byte field112
			, Byte field113
			, Byte field114
			, Byte field115
			, Byte field116
			, Byte field117
			, Byte field118
			, Byte field119
			, Byte field120
			, Byte field121
			, Byte field122
			, Byte field123
			, Byte field124
			, Byte field125
			, Byte field126
			, Byte field127
			, Byte field128
			, Byte field129
			, Byte field130
			, Byte field131
			, Byte field132
			, Byte field133
			, Byte field134
			, Byte field135
			, Byte field136
			, Byte field137
			, Byte field138
			, Byte field139
			, Byte field140
			, Byte field141
			, Byte field142
			, Byte field143
			, Byte field144
			, Byte field145
			, Byte field146
			, Byte field147
			, Byte field148
			, Byte field149
			, Byte field150
			, Byte field151
			, Byte field152
			, Byte field153
			, Byte field154
			, Byte field155
			, Byte field156
			, Byte field157
			, Byte field158
			, Byte field159
			, Byte field160
			, Byte field161
			, Byte field162
			, Byte field163
			, Byte field164
			, Byte field165
			, Byte field166
			, Byte field167
			, Byte field168
			, Byte field169
			, Byte field170
			, Byte field171
			, Byte field172
			, Byte field173
			, Byte field174
			, Byte field175
			, Byte field176
			, Byte field177
			, Byte field178
			, Byte field179
			, Byte field180
			, Byte field181
			, Byte field182
			, Byte field183
			, Byte field184
			, Byte field185
			, Byte field186
			, Byte field187
			, Byte field188
			, Byte field189
			, Byte field190
			, Byte field191
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
			Field46 = field46;
			Field47 = field47;
			Field48 = field48;
			Field49 = field49;
			Field50 = field50;
			Field51 = field51;
			Field52 = field52;
			Field53 = field53;
			Field54 = field54;
			Field55 = field55;
			Field56 = field56;
			Field57 = field57;
			Field58 = field58;
			Field59 = field59;
			Field60 = field60;
			Field61 = field61;
			Field62 = field62;
			Field63 = field63;
			Field64 = field64;
			Field65 = field65;
			Field66 = field66;
			Field67 = field67;
			Field68 = field68;
			Field69 = field69;
			Field70 = field70;
			Field71 = field71;
			Field72 = field72;
			Field73 = field73;
			Field74 = field74;
			Field75 = field75;
			Field76 = field76;
			Field77 = field77;
			Field78 = field78;
			Field79 = field79;
			Field80 = field80;
			Field81 = field81;
			Field82 = field82;
			Field83 = field83;
			Field84 = field84;
			Field85 = field85;
			Field86 = field86;
			Field87 = field87;
			Field88 = field88;
			Field89 = field89;
			Field90 = field90;
			Field91 = field91;
			Field92 = field92;
			Field93 = field93;
			Field94 = field94;
			Field95 = field95;
			Field96 = field96;
			Field97 = field97;
			Field98 = field98;
			Field99 = field99;
			Field100 = field100;
			Field101 = field101;
			Field102 = field102;
			Field103 = field103;
			Field104 = field104;
			Field105 = field105;
			Field106 = field106;
			Field107 = field107;
			Field108 = field108;
			Field109 = field109;
			Field110 = field110;
			Field111 = field111;
			Field112 = field112;
			Field113 = field113;
			Field114 = field114;
			Field115 = field115;
			Field116 = field116;
			Field117 = field117;
			Field118 = field118;
			Field119 = field119;
			Field120 = field120;
			Field121 = field121;
			Field122 = field122;
			Field123 = field123;
			Field124 = field124;
			Field125 = field125;
			Field126 = field126;
			Field127 = field127;
			Field128 = field128;
			Field129 = field129;
			Field130 = field130;
			Field131 = field131;
			Field132 = field132;
			Field133 = field133;
			Field134 = field134;
			Field135 = field135;
			Field136 = field136;
			Field137 = field137;
			Field138 = field138;
			Field139 = field139;
			Field140 = field140;
			Field141 = field141;
			Field142 = field142;
			Field143 = field143;
			Field144 = field144;
			Field145 = field145;
			Field146 = field146;
			Field147 = field147;
			Field148 = field148;
			Field149 = field149;
			Field150 = field150;
			Field151 = field151;
			Field152 = field152;
			Field153 = field153;
			Field154 = field154;
			Field155 = field155;
			Field156 = field156;
			Field157 = field157;
			Field158 = field158;
			Field159 = field159;
			Field160 = field160;
			Field161 = field161;
			Field162 = field162;
			Field163 = field163;
			Field164 = field164;
			Field165 = field165;
			Field166 = field166;
			Field167 = field167;
			Field168 = field168;
			Field169 = field169;
			Field170 = field170;
			Field171 = field171;
			Field172 = field172;
			Field173 = field173;
			Field174 = field174;
			Field175 = field175;
			Field176 = field176;
			Field177 = field177;
			Field178 = field178;
			Field179 = field179;
			Field180 = field180;
			Field181 = field181;
			Field182 = field182;
			Field183 = field183;
			Field184 = field184;
			Field185 = field185;
			Field186 = field186;
			Field187 = field187;
			Field188 = field188;
			Field189 = field189;
			Field190 = field190;
			Field191 = field191;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
		public Byte Field25;
		public Byte Field26;
		public Byte Field27;
		public Byte Field28;
		public Byte Field29;
		public Byte Field30;
		public Byte Field31;
		public Byte Field32;
		public Byte Field33;
		public Byte Field34;
		public Byte Field35;
		public Byte Field36;
		public Byte Field37;
		public Byte Field38;
		public Byte Field39;
		public Byte Field40;
		public Byte Field41;
		public Byte Field42;
		public Byte Field43;
		public Byte Field44;
		public Byte Field45;
		public Byte Field46;
		public Byte Field47;
		public Byte Field48;
		public Byte Field49;
		public Byte Field50;
		public Byte Field51;
		public Byte Field52;
		public Byte Field53;
		public Byte Field54;
		public Byte Field55;
		public Byte Field56;
		public Byte Field57;
		public Byte Field58;
		public Byte Field59;
		public Byte Field60;
		public Byte Field61;
		public Byte Field62;
		public Byte Field63;
		public Byte Field64;
		public Byte Field65;
		public Byte Field66;
		public Byte Field67;
		public Byte Field68;
		public Byte Field69;
		public Byte Field70;
		public Byte Field71;
		public Byte Field72;
		public Byte Field73;
		public Byte Field74;
		public Byte Field75;
		public Byte Field76;
		public Byte Field77;
		public Byte Field78;
		public Byte Field79;
		public Byte Field80;
		public Byte Field81;
		public Byte Field82;
		public Byte Field83;
		public Byte Field84;
		public Byte Field85;
		public Byte Field86;
		public Byte Field87;
		public Byte Field88;
		public Byte Field89;
		public Byte Field90;
		public Byte Field91;
		public Byte Field92;
		public Byte Field93;
		public Byte Field94;
		public Byte Field95;
		public Byte Field96;
		public Byte Field97;
		public Byte Field98;
		public Byte Field99;
		public Byte Field100;
		public Byte Field101;
		public Byte Field102;
		public Byte Field103;
		public Byte Field104;
		public Byte Field105;
		public Byte Field106;
		public Byte Field107;
		public Byte Field108;
		public Byte Field109;
		public Byte Field110;
		public Byte Field111;
		public Byte Field112;
		public Byte Field113;
		public Byte Field114;
		public Byte Field115;
		public Byte Field116;
		public Byte Field117;
		public Byte Field118;
		public Byte Field119;
		public Byte Field120;
		public Byte Field121;
		public Byte Field122;
		public Byte Field123;
		public Byte Field124;
		public Byte Field125;
		public Byte Field126;
		public Byte Field127;
		public Byte Field128;
		public Byte Field129;
		public Byte Field130;
		public Byte Field131;
		public Byte Field132;
		public Byte Field133;
		public Byte Field134;
		public Byte Field135;
		public Byte Field136;
		public Byte Field137;
		public Byte Field138;
		public Byte Field139;
		public Byte Field140;
		public Byte Field141;
		public Byte Field142;
		public Byte Field143;
		public Byte Field144;
		public Byte Field145;
		public Byte Field146;
		public Byte Field147;
		public Byte Field148;
		public Byte Field149;
		public Byte Field150;
		public Byte Field151;
		public Byte Field152;
		public Byte Field153;
		public Byte Field154;
		public Byte Field155;
		public Byte Field156;
		public Byte Field157;
		public Byte Field158;
		public Byte Field159;
		public Byte Field160;
		public Byte Field161;
		public Byte Field162;
		public Byte Field163;
		public Byte Field164;
		public Byte Field165;
		public Byte Field166;
		public Byte Field167;
		public Byte Field168;
		public Byte Field169;
		public Byte Field170;
		public Byte Field171;
		public Byte Field172;
		public Byte Field173;
		public Byte Field174;
		public Byte Field175;
		public Byte Field176;
		public Byte Field177;
		public Byte Field178;
		public Byte Field179;
		public Byte Field180;
		public Byte Field181;
		public Byte Field182;
		public Byte Field183;
		public Byte Field184;
		public Byte Field185;
		public Byte Field186;
		public Byte Field187;
		public Byte Field188;
		public Byte Field189;
		public Byte Field190;
		public Byte Field191;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                46 => Field46,
                47 => Field47,
                48 => Field48,
                49 => Field49,
                50 => Field50,
                51 => Field51,
                52 => Field52,
                53 => Field53,
                54 => Field54,
                55 => Field55,
                56 => Field56,
                57 => Field57,
                58 => Field58,
                59 => Field59,
                60 => Field60,
                61 => Field61,
                62 => Field62,
                63 => Field63,
                64 => Field64,
                65 => Field65,
                66 => Field66,
                67 => Field67,
                68 => Field68,
                69 => Field69,
                70 => Field70,
                71 => Field71,
                72 => Field72,
                73 => Field73,
                74 => Field74,
                75 => Field75,
                76 => Field76,
                77 => Field77,
                78 => Field78,
                79 => Field79,
                80 => Field80,
                81 => Field81,
                82 => Field82,
                83 => Field83,
                84 => Field84,
                85 => Field85,
                86 => Field86,
                87 => Field87,
                88 => Field88,
                89 => Field89,
                90 => Field90,
                91 => Field91,
                92 => Field92,
                93 => Field93,
                94 => Field94,
                95 => Field95,
                96 => Field96,
                97 => Field97,
                98 => Field98,
                99 => Field99,
                100 => Field100,
                101 => Field101,
                102 => Field102,
                103 => Field103,
                104 => Field104,
                105 => Field105,
                106 => Field106,
                107 => Field107,
                108 => Field108,
                109 => Field109,
                110 => Field110,
                111 => Field111,
                112 => Field112,
                113 => Field113,
                114 => Field114,
                115 => Field115,
                116 => Field116,
                117 => Field117,
                118 => Field118,
                119 => Field119,
                120 => Field120,
                121 => Field121,
                122 => Field122,
                123 => Field123,
                124 => Field124,
                125 => Field125,
                126 => Field126,
                127 => Field127,
                128 => Field128,
                129 => Field129,
                130 => Field130,
                131 => Field131,
                132 => Field132,
                133 => Field133,
                134 => Field134,
                135 => Field135,
                136 => Field136,
                137 => Field137,
                138 => Field138,
                139 => Field139,
                140 => Field140,
                141 => Field141,
                142 => Field142,
                143 => Field143,
                144 => Field144,
                145 => Field145,
                146 => Field146,
                147 => Field147,
                148 => Field148,
                149 => Field149,
                150 => Field150,
                151 => Field151,
                152 => Field152,
                153 => Field153,
                154 => Field154,
                155 => Field155,
                156 => Field156,
                157 => Field157,
                158 => Field158,
                159 => Field159,
                160 => Field160,
                161 => Field161,
                162 => Field162,
                163 => Field163,
                164 => Field164,
                165 => Field165,
                166 => Field166,
                167 => Field167,
                168 => Field168,
                169 => Field169,
                170 => Field170,
                171 => Field171,
                172 => Field172,
                173 => Field173,
                174 => Field174,
                175 => Field175,
                176 => Field176,
                177 => Field177,
                178 => Field178,
                179 => Field179,
                180 => Field180,
                181 => Field181,
                182 => Field182,
                183 => Field183,
                184 => Field184,
                185 => Field185,
                186 => Field186,
                187 => Field187,
                188 => Field188,
                189 => Field189,
                190 => Field190,
                191 => Field191,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
                    case 46: Field46 = value; break;
                    case 47: Field47 = value; break;
                    case 48: Field48 = value; break;
                    case 49: Field49 = value; break;
                    case 50: Field50 = value; break;
                    case 51: Field51 = value; break;
                    case 52: Field52 = value; break;
                    case 53: Field53 = value; break;
                    case 54: Field54 = value; break;
                    case 55: Field55 = value; break;
                    case 56: Field56 = value; break;
                    case 57: Field57 = value; break;
                    case 58: Field58 = value; break;
                    case 59: Field59 = value; break;
                    case 60: Field60 = value; break;
                    case 61: Field61 = value; break;
                    case 62: Field62 = value; break;
                    case 63: Field63 = value; break;
                    case 64: Field64 = value; break;
                    case 65: Field65 = value; break;
                    case 66: Field66 = value; break;
                    case 67: Field67 = value; break;
                    case 68: Field68 = value; break;
                    case 69: Field69 = value; break;
                    case 70: Field70 = value; break;
                    case 71: Field71 = value; break;
                    case 72: Field72 = value; break;
                    case 73: Field73 = value; break;
                    case 74: Field74 = value; break;
                    case 75: Field75 = value; break;
                    case 76: Field76 = value; break;
                    case 77: Field77 = value; break;
                    case 78: Field78 = value; break;
                    case 79: Field79 = value; break;
                    case 80: Field80 = value; break;
                    case 81: Field81 = value; break;
                    case 82: Field82 = value; break;
                    case 83: Field83 = value; break;
                    case 84: Field84 = value; break;
                    case 85: Field85 = value; break;
                    case 86: Field86 = value; break;
                    case 87: Field87 = value; break;
                    case 88: Field88 = value; break;
                    case 89: Field89 = value; break;
                    case 90: Field90 = value; break;
                    case 91: Field91 = value; break;
                    case 92: Field92 = value; break;
                    case 93: Field93 = value; break;
                    case 94: Field94 = value; break;
                    case 95: Field95 = value; break;
                    case 96: Field96 = value; break;
                    case 97: Field97 = value; break;
                    case 98: Field98 = value; break;
                    case 99: Field99 = value; break;
                    case 100: Field100 = value; break;
                    case 101: Field101 = value; break;
                    case 102: Field102 = value; break;
                    case 103: Field103 = value; break;
                    case 104: Field104 = value; break;
                    case 105: Field105 = value; break;
                    case 106: Field106 = value; break;
                    case 107: Field107 = value; break;
                    case 108: Field108 = value; break;
                    case 109: Field109 = value; break;
                    case 110: Field110 = value; break;
                    case 111: Field111 = value; break;
                    case 112: Field112 = value; break;
                    case 113: Field113 = value; break;
                    case 114: Field114 = value; break;
                    case 115: Field115 = value; break;
                    case 116: Field116 = value; break;
                    case 117: Field117 = value; break;
                    case 118: Field118 = value; break;
                    case 119: Field119 = value; break;
                    case 120: Field120 = value; break;
                    case 121: Field121 = value; break;
                    case 122: Field122 = value; break;
                    case 123: Field123 = value; break;
                    case 124: Field124 = value; break;
                    case 125: Field125 = value; break;
                    case 126: Field126 = value; break;
                    case 127: Field127 = value; break;
                    case 128: Field128 = value; break;
                    case 129: Field129 = value; break;
                    case 130: Field130 = value; break;
                    case 131: Field131 = value; break;
                    case 132: Field132 = value; break;
                    case 133: Field133 = value; break;
                    case 134: Field134 = value; break;
                    case 135: Field135 = value; break;
                    case 136: Field136 = value; break;
                    case 137: Field137 = value; break;
                    case 138: Field138 = value; break;
                    case 139: Field139 = value; break;
                    case 140: Field140 = value; break;
                    case 141: Field141 = value; break;
                    case 142: Field142 = value; break;
                    case 143: Field143 = value; break;
                    case 144: Field144 = value; break;
                    case 145: Field145 = value; break;
                    case 146: Field146 = value; break;
                    case 147: Field147 = value; break;
                    case 148: Field148 = value; break;
                    case 149: Field149 = value; break;
                    case 150: Field150 = value; break;
                    case 151: Field151 = value; break;
                    case 152: Field152 = value; break;
                    case 153: Field153 = value; break;
                    case 154: Field154 = value; break;
                    case 155: Field155 = value; break;
                    case 156: Field156 = value; break;
                    case 157: Field157 = value; break;
                    case 158: Field158 = value; break;
                    case 159: Field159 = value; break;
                    case 160: Field160 = value; break;
                    case 161: Field161 = value; break;
                    case 162: Field162 = value; break;
                    case 163: Field163 = value; break;
                    case 164: Field164 = value; break;
                    case 165: Field165 = value; break;
                    case 166: Field166 = value; break;
                    case 167: Field167 = value; break;
                    case 168: Field168 = value; break;
                    case 169: Field169 = value; break;
                    case 170: Field170 = value; break;
                    case 171: Field171 = value; break;
                    case 172: Field172 = value; break;
                    case 173: Field173 = value; break;
                    case 174: Field174 = value; break;
                    case 175: Field175 = value; break;
                    case 176: Field176 = value; break;
                    case 177: Field177 = value; break;
                    case 178: Field178 = value; break;
                    case 179: Field179 = value; break;
                    case 180: Field180 = value; break;
                    case 181: Field181 = value; break;
                    case 182: Field182 = value; break;
                    case 183: Field183 = value; break;
                    case 184: Field184 = value; break;
                    case 185: Field185 = value; break;
                    case 186: Field186 = value; break;
                    case 187: Field187 = value; break;
                    case 188: Field188 = value; break;
                    case 189: Field189 = value; break;
                    case 190: Field190 = value; break;
                    case 191: Field191 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray192) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray192)other);

        public readonly bool Equals(in FixedLengthByteArray192 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray192 left, in FixedLengthByteArray192 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray192 left, in FixedLengthByteArray192 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
              yield return Field46;
              yield return Field47;
              yield return Field48;
              yield return Field49;
              yield return Field50;
              yield return Field51;
              yield return Field52;
              yield return Field53;
              yield return Field54;
              yield return Field55;
              yield return Field56;
              yield return Field57;
              yield return Field58;
              yield return Field59;
              yield return Field60;
              yield return Field61;
              yield return Field62;
              yield return Field63;
              yield return Field64;
              yield return Field65;
              yield return Field66;
              yield return Field67;
              yield return Field68;
              yield return Field69;
              yield return Field70;
              yield return Field71;
              yield return Field72;
              yield return Field73;
              yield return Field74;
              yield return Field75;
              yield return Field76;
              yield return Field77;
              yield return Field78;
              yield return Field79;
              yield return Field80;
              yield return Field81;
              yield return Field82;
              yield return Field83;
              yield return Field84;
              yield return Field85;
              yield return Field86;
              yield return Field87;
              yield return Field88;
              yield return Field89;
              yield return Field90;
              yield return Field91;
              yield return Field92;
              yield return Field93;
              yield return Field94;
              yield return Field95;
              yield return Field96;
              yield return Field97;
              yield return Field98;
              yield return Field99;
              yield return Field100;
              yield return Field101;
              yield return Field102;
              yield return Field103;
              yield return Field104;
              yield return Field105;
              yield return Field106;
              yield return Field107;
              yield return Field108;
              yield return Field109;
              yield return Field110;
              yield return Field111;
              yield return Field112;
              yield return Field113;
              yield return Field114;
              yield return Field115;
              yield return Field116;
              yield return Field117;
              yield return Field118;
              yield return Field119;
              yield return Field120;
              yield return Field121;
              yield return Field122;
              yield return Field123;
              yield return Field124;
              yield return Field125;
              yield return Field126;
              yield return Field127;
              yield return Field128;
              yield return Field129;
              yield return Field130;
              yield return Field131;
              yield return Field132;
              yield return Field133;
              yield return Field134;
              yield return Field135;
              yield return Field136;
              yield return Field137;
              yield return Field138;
              yield return Field139;
              yield return Field140;
              yield return Field141;
              yield return Field142;
              yield return Field143;
              yield return Field144;
              yield return Field145;
              yield return Field146;
              yield return Field147;
              yield return Field148;
              yield return Field149;
              yield return Field150;
              yield return Field151;
              yield return Field152;
              yield return Field153;
              yield return Field154;
              yield return Field155;
              yield return Field156;
              yield return Field157;
              yield return Field158;
              yield return Field159;
              yield return Field160;
              yield return Field161;
              yield return Field162;
              yield return Field163;
              yield return Field164;
              yield return Field165;
              yield return Field166;
              yield return Field167;
              yield return Field168;
              yield return Field169;
              yield return Field170;
              yield return Field171;
              yield return Field172;
              yield return Field173;
              yield return Field174;
              yield return Field175;
              yield return Field176;
              yield return Field177;
              yield return Field178;
              yield return Field179;
              yield return Field180;
              yield return Field181;
              yield return Field182;
              yield return Field183;
              yield return Field184;
              yield return Field185;
              yield return Field186;
              yield return Field187;
              yield return Field188;
              yield return Field189;
              yield return Field190;
              yield return Field191;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray192 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray192 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray192 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray192 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
                case 46: return ref array.Field46;
                case 47: return ref array.Field47;
                case 48: return ref array.Field48;
                case 49: return ref array.Field49;
                case 50: return ref array.Field50;
                case 51: return ref array.Field51;
                case 52: return ref array.Field52;
                case 53: return ref array.Field53;
                case 54: return ref array.Field54;
                case 55: return ref array.Field55;
                case 56: return ref array.Field56;
                case 57: return ref array.Field57;
                case 58: return ref array.Field58;
                case 59: return ref array.Field59;
                case 60: return ref array.Field60;
                case 61: return ref array.Field61;
                case 62: return ref array.Field62;
                case 63: return ref array.Field63;
                case 64: return ref array.Field64;
                case 65: return ref array.Field65;
                case 66: return ref array.Field66;
                case 67: return ref array.Field67;
                case 68: return ref array.Field68;
                case 69: return ref array.Field69;
                case 70: return ref array.Field70;
                case 71: return ref array.Field71;
                case 72: return ref array.Field72;
                case 73: return ref array.Field73;
                case 74: return ref array.Field74;
                case 75: return ref array.Field75;
                case 76: return ref array.Field76;
                case 77: return ref array.Field77;
                case 78: return ref array.Field78;
                case 79: return ref array.Field79;
                case 80: return ref array.Field80;
                case 81: return ref array.Field81;
                case 82: return ref array.Field82;
                case 83: return ref array.Field83;
                case 84: return ref array.Field84;
                case 85: return ref array.Field85;
                case 86: return ref array.Field86;
                case 87: return ref array.Field87;
                case 88: return ref array.Field88;
                case 89: return ref array.Field89;
                case 90: return ref array.Field90;
                case 91: return ref array.Field91;
                case 92: return ref array.Field92;
                case 93: return ref array.Field93;
                case 94: return ref array.Field94;
                case 95: return ref array.Field95;
                case 96: return ref array.Field96;
                case 97: return ref array.Field97;
                case 98: return ref array.Field98;
                case 99: return ref array.Field99;
                case 100: return ref array.Field100;
                case 101: return ref array.Field101;
                case 102: return ref array.Field102;
                case 103: return ref array.Field103;
                case 104: return ref array.Field104;
                case 105: return ref array.Field105;
                case 106: return ref array.Field106;
                case 107: return ref array.Field107;
                case 108: return ref array.Field108;
                case 109: return ref array.Field109;
                case 110: return ref array.Field110;
                case 111: return ref array.Field111;
                case 112: return ref array.Field112;
                case 113: return ref array.Field113;
                case 114: return ref array.Field114;
                case 115: return ref array.Field115;
                case 116: return ref array.Field116;
                case 117: return ref array.Field117;
                case 118: return ref array.Field118;
                case 119: return ref array.Field119;
                case 120: return ref array.Field120;
                case 121: return ref array.Field121;
                case 122: return ref array.Field122;
                case 123: return ref array.Field123;
                case 124: return ref array.Field124;
                case 125: return ref array.Field125;
                case 126: return ref array.Field126;
                case 127: return ref array.Field127;
                case 128: return ref array.Field128;
                case 129: return ref array.Field129;
                case 130: return ref array.Field130;
                case 131: return ref array.Field131;
                case 132: return ref array.Field132;
                case 133: return ref array.Field133;
                case 134: return ref array.Field134;
                case 135: return ref array.Field135;
                case 136: return ref array.Field136;
                case 137: return ref array.Field137;
                case 138: return ref array.Field138;
                case 139: return ref array.Field139;
                case 140: return ref array.Field140;
                case 141: return ref array.Field141;
                case 142: return ref array.Field142;
                case 143: return ref array.Field143;
                case 144: return ref array.Field144;
                case 145: return ref array.Field145;
                case 146: return ref array.Field146;
                case 147: return ref array.Field147;
                case 148: return ref array.Field148;
                case 149: return ref array.Field149;
                case 150: return ref array.Field150;
                case 151: return ref array.Field151;
                case 152: return ref array.Field152;
                case 153: return ref array.Field153;
                case 154: return ref array.Field154;
                case 155: return ref array.Field155;
                case 156: return ref array.Field156;
                case 157: return ref array.Field157;
                case 158: return ref array.Field158;
                case 159: return ref array.Field159;
                case 160: return ref array.Field160;
                case 161: return ref array.Field161;
                case 162: return ref array.Field162;
                case 163: return ref array.Field163;
                case 164: return ref array.Field164;
                case 165: return ref array.Field165;
                case 166: return ref array.Field166;
                case 167: return ref array.Field167;
                case 168: return ref array.Field168;
                case 169: return ref array.Field169;
                case 170: return ref array.Field170;
                case 171: return ref array.Field171;
                case 172: return ref array.Field172;
                case 173: return ref array.Field173;
                case 174: return ref array.Field174;
                case 175: return ref array.Field175;
                case 176: return ref array.Field176;
                case 177: return ref array.Field177;
                case 178: return ref array.Field178;
                case 179: return ref array.Field179;
                case 180: return ref array.Field180;
                case 181: return ref array.Field181;
                case 182: return ref array.Field182;
                case 183: return ref array.Field183;
                case 184: return ref array.Field184;
                case 185: return ref array.Field185;
                case 186: return ref array.Field186;
                case 187: return ref array.Field187;
                case 188: return ref array.Field188;
                case 189: return ref array.Field189;
                case 190: return ref array.Field190;
                case 191: return ref array.Field191;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray192 array1, in FixedLengthByteArray192 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray192 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray192 array1, in FixedLengthByteArray192 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray192 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray192 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray192 array1, in FixedLengthByteArray192 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray192 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray192 array1, in FixedLengthByteArray192 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray192 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 256 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray256
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray256 _Zero = default;
		public static ref readonly FixedLengthByteArray256 Zero => ref _Zero;

		public const int ConstLength = 256;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray256(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
			, Byte field25
			, Byte field26
			, Byte field27
			, Byte field28
			, Byte field29
			, Byte field30
			, Byte field31
			, Byte field32
			, Byte field33
			, Byte field34
			, Byte field35
			, Byte field36
			, Byte field37
			, Byte field38
			, Byte field39
			, Byte field40
			, Byte field41
			, Byte field42
			, Byte field43
			, Byte field44
			, Byte field45
			, Byte field46
			, Byte field47
			, Byte field48
			, Byte field49
			, Byte field50
			, Byte field51
			, Byte field52
			, Byte field53
			, Byte field54
			, Byte field55
			, Byte field56
			, Byte field57
			, Byte field58
			, Byte field59
			, Byte field60
			, Byte field61
			, Byte field62
			, Byte field63
			, Byte field64
			, Byte field65
			, Byte field66
			, Byte field67
			, Byte field68
			, Byte field69
			, Byte field70
			, Byte field71
			, Byte field72
			, Byte field73
			, Byte field74
			, Byte field75
			, Byte field76
			, Byte field77
			, Byte field78
			, Byte field79
			, Byte field80
			, Byte field81
			, Byte field82
			, Byte field83
			, Byte field84
			, Byte field85
			, Byte field86
			, Byte field87
			, Byte field88
			, Byte field89
			, Byte field90
			, Byte field91
			, Byte field92
			, Byte field93
			, Byte field94
			, Byte field95
			, Byte field96
			, Byte field97
			, Byte field98
			, Byte field99
			, Byte field100
			, Byte field101
			, Byte field102
			, Byte field103
			, Byte field104
			, Byte field105
			, Byte field106
			, Byte field107
			, Byte field108
			, Byte field109
			, Byte field110
			, Byte field111
			, Byte field112
			, Byte field113
			, Byte field114
			, Byte field115
			, Byte field116
			, Byte field117
			, Byte field118
			, Byte field119
			, Byte field120
			, Byte field121
			, Byte field122
			, Byte field123
			, Byte field124
			, Byte field125
			, Byte field126
			, Byte field127
			, Byte field128
			, Byte field129
			, Byte field130
			, Byte field131
			, Byte field132
			, Byte field133
			, Byte field134
			, Byte field135
			, Byte field136
			, Byte field137
			, Byte field138
			, Byte field139
			, Byte field140
			, Byte field141
			, Byte field142
			, Byte field143
			, Byte field144
			, Byte field145
			, Byte field146
			, Byte field147
			, Byte field148
			, Byte field149
			, Byte field150
			, Byte field151
			, Byte field152
			, Byte field153
			, Byte field154
			, Byte field155
			, Byte field156
			, Byte field157
			, Byte field158
			, Byte field159
			, Byte field160
			, Byte field161
			, Byte field162
			, Byte field163
			, Byte field164
			, Byte field165
			, Byte field166
			, Byte field167
			, Byte field168
			, Byte field169
			, Byte field170
			, Byte field171
			, Byte field172
			, Byte field173
			, Byte field174
			, Byte field175
			, Byte field176
			, Byte field177
			, Byte field178
			, Byte field179
			, Byte field180
			, Byte field181
			, Byte field182
			, Byte field183
			, Byte field184
			, Byte field185
			, Byte field186
			, Byte field187
			, Byte field188
			, Byte field189
			, Byte field190
			, Byte field191
			, Byte field192
			, Byte field193
			, Byte field194
			, Byte field195
			, Byte field196
			, Byte field197
			, Byte field198
			, Byte field199
			, Byte field200
			, Byte field201
			, Byte field202
			, Byte field203
			, Byte field204
			, Byte field205
			, Byte field206
			, Byte field207
			, Byte field208
			, Byte field209
			, Byte field210
			, Byte field211
			, Byte field212
			, Byte field213
			, Byte field214
			, Byte field215
			, Byte field216
			, Byte field217
			, Byte field218
			, Byte field219
			, Byte field220
			, Byte field221
			, Byte field222
			, Byte field223
			, Byte field224
			, Byte field225
			, Byte field226
			, Byte field227
			, Byte field228
			, Byte field229
			, Byte field230
			, Byte field231
			, Byte field232
			, Byte field233
			, Byte field234
			, Byte field235
			, Byte field236
			, Byte field237
			, Byte field238
			, Byte field239
			, Byte field240
			, Byte field241
			, Byte field242
			, Byte field243
			, Byte field244
			, Byte field245
			, Byte field246
			, Byte field247
			, Byte field248
			, Byte field249
			, Byte field250
			, Byte field251
			, Byte field252
			, Byte field253
			, Byte field254
			, Byte field255
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
			Field46 = field46;
			Field47 = field47;
			Field48 = field48;
			Field49 = field49;
			Field50 = field50;
			Field51 = field51;
			Field52 = field52;
			Field53 = field53;
			Field54 = field54;
			Field55 = field55;
			Field56 = field56;
			Field57 = field57;
			Field58 = field58;
			Field59 = field59;
			Field60 = field60;
			Field61 = field61;
			Field62 = field62;
			Field63 = field63;
			Field64 = field64;
			Field65 = field65;
			Field66 = field66;
			Field67 = field67;
			Field68 = field68;
			Field69 = field69;
			Field70 = field70;
			Field71 = field71;
			Field72 = field72;
			Field73 = field73;
			Field74 = field74;
			Field75 = field75;
			Field76 = field76;
			Field77 = field77;
			Field78 = field78;
			Field79 = field79;
			Field80 = field80;
			Field81 = field81;
			Field82 = field82;
			Field83 = field83;
			Field84 = field84;
			Field85 = field85;
			Field86 = field86;
			Field87 = field87;
			Field88 = field88;
			Field89 = field89;
			Field90 = field90;
			Field91 = field91;
			Field92 = field92;
			Field93 = field93;
			Field94 = field94;
			Field95 = field95;
			Field96 = field96;
			Field97 = field97;
			Field98 = field98;
			Field99 = field99;
			Field100 = field100;
			Field101 = field101;
			Field102 = field102;
			Field103 = field103;
			Field104 = field104;
			Field105 = field105;
			Field106 = field106;
			Field107 = field107;
			Field108 = field108;
			Field109 = field109;
			Field110 = field110;
			Field111 = field111;
			Field112 = field112;
			Field113 = field113;
			Field114 = field114;
			Field115 = field115;
			Field116 = field116;
			Field117 = field117;
			Field118 = field118;
			Field119 = field119;
			Field120 = field120;
			Field121 = field121;
			Field122 = field122;
			Field123 = field123;
			Field124 = field124;
			Field125 = field125;
			Field126 = field126;
			Field127 = field127;
			Field128 = field128;
			Field129 = field129;
			Field130 = field130;
			Field131 = field131;
			Field132 = field132;
			Field133 = field133;
			Field134 = field134;
			Field135 = field135;
			Field136 = field136;
			Field137 = field137;
			Field138 = field138;
			Field139 = field139;
			Field140 = field140;
			Field141 = field141;
			Field142 = field142;
			Field143 = field143;
			Field144 = field144;
			Field145 = field145;
			Field146 = field146;
			Field147 = field147;
			Field148 = field148;
			Field149 = field149;
			Field150 = field150;
			Field151 = field151;
			Field152 = field152;
			Field153 = field153;
			Field154 = field154;
			Field155 = field155;
			Field156 = field156;
			Field157 = field157;
			Field158 = field158;
			Field159 = field159;
			Field160 = field160;
			Field161 = field161;
			Field162 = field162;
			Field163 = field163;
			Field164 = field164;
			Field165 = field165;
			Field166 = field166;
			Field167 = field167;
			Field168 = field168;
			Field169 = field169;
			Field170 = field170;
			Field171 = field171;
			Field172 = field172;
			Field173 = field173;
			Field174 = field174;
			Field175 = field175;
			Field176 = field176;
			Field177 = field177;
			Field178 = field178;
			Field179 = field179;
			Field180 = field180;
			Field181 = field181;
			Field182 = field182;
			Field183 = field183;
			Field184 = field184;
			Field185 = field185;
			Field186 = field186;
			Field187 = field187;
			Field188 = field188;
			Field189 = field189;
			Field190 = field190;
			Field191 = field191;
			Field192 = field192;
			Field193 = field193;
			Field194 = field194;
			Field195 = field195;
			Field196 = field196;
			Field197 = field197;
			Field198 = field198;
			Field199 = field199;
			Field200 = field200;
			Field201 = field201;
			Field202 = field202;
			Field203 = field203;
			Field204 = field204;
			Field205 = field205;
			Field206 = field206;
			Field207 = field207;
			Field208 = field208;
			Field209 = field209;
			Field210 = field210;
			Field211 = field211;
			Field212 = field212;
			Field213 = field213;
			Field214 = field214;
			Field215 = field215;
			Field216 = field216;
			Field217 = field217;
			Field218 = field218;
			Field219 = field219;
			Field220 = field220;
			Field221 = field221;
			Field222 = field222;
			Field223 = field223;
			Field224 = field224;
			Field225 = field225;
			Field226 = field226;
			Field227 = field227;
			Field228 = field228;
			Field229 = field229;
			Field230 = field230;
			Field231 = field231;
			Field232 = field232;
			Field233 = field233;
			Field234 = field234;
			Field235 = field235;
			Field236 = field236;
			Field237 = field237;
			Field238 = field238;
			Field239 = field239;
			Field240 = field240;
			Field241 = field241;
			Field242 = field242;
			Field243 = field243;
			Field244 = field244;
			Field245 = field245;
			Field246 = field246;
			Field247 = field247;
			Field248 = field248;
			Field249 = field249;
			Field250 = field250;
			Field251 = field251;
			Field252 = field252;
			Field253 = field253;
			Field254 = field254;
			Field255 = field255;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
		public Byte Field25;
		public Byte Field26;
		public Byte Field27;
		public Byte Field28;
		public Byte Field29;
		public Byte Field30;
		public Byte Field31;
		public Byte Field32;
		public Byte Field33;
		public Byte Field34;
		public Byte Field35;
		public Byte Field36;
		public Byte Field37;
		public Byte Field38;
		public Byte Field39;
		public Byte Field40;
		public Byte Field41;
		public Byte Field42;
		public Byte Field43;
		public Byte Field44;
		public Byte Field45;
		public Byte Field46;
		public Byte Field47;
		public Byte Field48;
		public Byte Field49;
		public Byte Field50;
		public Byte Field51;
		public Byte Field52;
		public Byte Field53;
		public Byte Field54;
		public Byte Field55;
		public Byte Field56;
		public Byte Field57;
		public Byte Field58;
		public Byte Field59;
		public Byte Field60;
		public Byte Field61;
		public Byte Field62;
		public Byte Field63;
		public Byte Field64;
		public Byte Field65;
		public Byte Field66;
		public Byte Field67;
		public Byte Field68;
		public Byte Field69;
		public Byte Field70;
		public Byte Field71;
		public Byte Field72;
		public Byte Field73;
		public Byte Field74;
		public Byte Field75;
		public Byte Field76;
		public Byte Field77;
		public Byte Field78;
		public Byte Field79;
		public Byte Field80;
		public Byte Field81;
		public Byte Field82;
		public Byte Field83;
		public Byte Field84;
		public Byte Field85;
		public Byte Field86;
		public Byte Field87;
		public Byte Field88;
		public Byte Field89;
		public Byte Field90;
		public Byte Field91;
		public Byte Field92;
		public Byte Field93;
		public Byte Field94;
		public Byte Field95;
		public Byte Field96;
		public Byte Field97;
		public Byte Field98;
		public Byte Field99;
		public Byte Field100;
		public Byte Field101;
		public Byte Field102;
		public Byte Field103;
		public Byte Field104;
		public Byte Field105;
		public Byte Field106;
		public Byte Field107;
		public Byte Field108;
		public Byte Field109;
		public Byte Field110;
		public Byte Field111;
		public Byte Field112;
		public Byte Field113;
		public Byte Field114;
		public Byte Field115;
		public Byte Field116;
		public Byte Field117;
		public Byte Field118;
		public Byte Field119;
		public Byte Field120;
		public Byte Field121;
		public Byte Field122;
		public Byte Field123;
		public Byte Field124;
		public Byte Field125;
		public Byte Field126;
		public Byte Field127;
		public Byte Field128;
		public Byte Field129;
		public Byte Field130;
		public Byte Field131;
		public Byte Field132;
		public Byte Field133;
		public Byte Field134;
		public Byte Field135;
		public Byte Field136;
		public Byte Field137;
		public Byte Field138;
		public Byte Field139;
		public Byte Field140;
		public Byte Field141;
		public Byte Field142;
		public Byte Field143;
		public Byte Field144;
		public Byte Field145;
		public Byte Field146;
		public Byte Field147;
		public Byte Field148;
		public Byte Field149;
		public Byte Field150;
		public Byte Field151;
		public Byte Field152;
		public Byte Field153;
		public Byte Field154;
		public Byte Field155;
		public Byte Field156;
		public Byte Field157;
		public Byte Field158;
		public Byte Field159;
		public Byte Field160;
		public Byte Field161;
		public Byte Field162;
		public Byte Field163;
		public Byte Field164;
		public Byte Field165;
		public Byte Field166;
		public Byte Field167;
		public Byte Field168;
		public Byte Field169;
		public Byte Field170;
		public Byte Field171;
		public Byte Field172;
		public Byte Field173;
		public Byte Field174;
		public Byte Field175;
		public Byte Field176;
		public Byte Field177;
		public Byte Field178;
		public Byte Field179;
		public Byte Field180;
		public Byte Field181;
		public Byte Field182;
		public Byte Field183;
		public Byte Field184;
		public Byte Field185;
		public Byte Field186;
		public Byte Field187;
		public Byte Field188;
		public Byte Field189;
		public Byte Field190;
		public Byte Field191;
		public Byte Field192;
		public Byte Field193;
		public Byte Field194;
		public Byte Field195;
		public Byte Field196;
		public Byte Field197;
		public Byte Field198;
		public Byte Field199;
		public Byte Field200;
		public Byte Field201;
		public Byte Field202;
		public Byte Field203;
		public Byte Field204;
		public Byte Field205;
		public Byte Field206;
		public Byte Field207;
		public Byte Field208;
		public Byte Field209;
		public Byte Field210;
		public Byte Field211;
		public Byte Field212;
		public Byte Field213;
		public Byte Field214;
		public Byte Field215;
		public Byte Field216;
		public Byte Field217;
		public Byte Field218;
		public Byte Field219;
		public Byte Field220;
		public Byte Field221;
		public Byte Field222;
		public Byte Field223;
		public Byte Field224;
		public Byte Field225;
		public Byte Field226;
		public Byte Field227;
		public Byte Field228;
		public Byte Field229;
		public Byte Field230;
		public Byte Field231;
		public Byte Field232;
		public Byte Field233;
		public Byte Field234;
		public Byte Field235;
		public Byte Field236;
		public Byte Field237;
		public Byte Field238;
		public Byte Field239;
		public Byte Field240;
		public Byte Field241;
		public Byte Field242;
		public Byte Field243;
		public Byte Field244;
		public Byte Field245;
		public Byte Field246;
		public Byte Field247;
		public Byte Field248;
		public Byte Field249;
		public Byte Field250;
		public Byte Field251;
		public Byte Field252;
		public Byte Field253;
		public Byte Field254;
		public Byte Field255;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                46 => Field46,
                47 => Field47,
                48 => Field48,
                49 => Field49,
                50 => Field50,
                51 => Field51,
                52 => Field52,
                53 => Field53,
                54 => Field54,
                55 => Field55,
                56 => Field56,
                57 => Field57,
                58 => Field58,
                59 => Field59,
                60 => Field60,
                61 => Field61,
                62 => Field62,
                63 => Field63,
                64 => Field64,
                65 => Field65,
                66 => Field66,
                67 => Field67,
                68 => Field68,
                69 => Field69,
                70 => Field70,
                71 => Field71,
                72 => Field72,
                73 => Field73,
                74 => Field74,
                75 => Field75,
                76 => Field76,
                77 => Field77,
                78 => Field78,
                79 => Field79,
                80 => Field80,
                81 => Field81,
                82 => Field82,
                83 => Field83,
                84 => Field84,
                85 => Field85,
                86 => Field86,
                87 => Field87,
                88 => Field88,
                89 => Field89,
                90 => Field90,
                91 => Field91,
                92 => Field92,
                93 => Field93,
                94 => Field94,
                95 => Field95,
                96 => Field96,
                97 => Field97,
                98 => Field98,
                99 => Field99,
                100 => Field100,
                101 => Field101,
                102 => Field102,
                103 => Field103,
                104 => Field104,
                105 => Field105,
                106 => Field106,
                107 => Field107,
                108 => Field108,
                109 => Field109,
                110 => Field110,
                111 => Field111,
                112 => Field112,
                113 => Field113,
                114 => Field114,
                115 => Field115,
                116 => Field116,
                117 => Field117,
                118 => Field118,
                119 => Field119,
                120 => Field120,
                121 => Field121,
                122 => Field122,
                123 => Field123,
                124 => Field124,
                125 => Field125,
                126 => Field126,
                127 => Field127,
                128 => Field128,
                129 => Field129,
                130 => Field130,
                131 => Field131,
                132 => Field132,
                133 => Field133,
                134 => Field134,
                135 => Field135,
                136 => Field136,
                137 => Field137,
                138 => Field138,
                139 => Field139,
                140 => Field140,
                141 => Field141,
                142 => Field142,
                143 => Field143,
                144 => Field144,
                145 => Field145,
                146 => Field146,
                147 => Field147,
                148 => Field148,
                149 => Field149,
                150 => Field150,
                151 => Field151,
                152 => Field152,
                153 => Field153,
                154 => Field154,
                155 => Field155,
                156 => Field156,
                157 => Field157,
                158 => Field158,
                159 => Field159,
                160 => Field160,
                161 => Field161,
                162 => Field162,
                163 => Field163,
                164 => Field164,
                165 => Field165,
                166 => Field166,
                167 => Field167,
                168 => Field168,
                169 => Field169,
                170 => Field170,
                171 => Field171,
                172 => Field172,
                173 => Field173,
                174 => Field174,
                175 => Field175,
                176 => Field176,
                177 => Field177,
                178 => Field178,
                179 => Field179,
                180 => Field180,
                181 => Field181,
                182 => Field182,
                183 => Field183,
                184 => Field184,
                185 => Field185,
                186 => Field186,
                187 => Field187,
                188 => Field188,
                189 => Field189,
                190 => Field190,
                191 => Field191,
                192 => Field192,
                193 => Field193,
                194 => Field194,
                195 => Field195,
                196 => Field196,
                197 => Field197,
                198 => Field198,
                199 => Field199,
                200 => Field200,
                201 => Field201,
                202 => Field202,
                203 => Field203,
                204 => Field204,
                205 => Field205,
                206 => Field206,
                207 => Field207,
                208 => Field208,
                209 => Field209,
                210 => Field210,
                211 => Field211,
                212 => Field212,
                213 => Field213,
                214 => Field214,
                215 => Field215,
                216 => Field216,
                217 => Field217,
                218 => Field218,
                219 => Field219,
                220 => Field220,
                221 => Field221,
                222 => Field222,
                223 => Field223,
                224 => Field224,
                225 => Field225,
                226 => Field226,
                227 => Field227,
                228 => Field228,
                229 => Field229,
                230 => Field230,
                231 => Field231,
                232 => Field232,
                233 => Field233,
                234 => Field234,
                235 => Field235,
                236 => Field236,
                237 => Field237,
                238 => Field238,
                239 => Field239,
                240 => Field240,
                241 => Field241,
                242 => Field242,
                243 => Field243,
                244 => Field244,
                245 => Field245,
                246 => Field246,
                247 => Field247,
                248 => Field248,
                249 => Field249,
                250 => Field250,
                251 => Field251,
                252 => Field252,
                253 => Field253,
                254 => Field254,
                255 => Field255,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
                    case 46: Field46 = value; break;
                    case 47: Field47 = value; break;
                    case 48: Field48 = value; break;
                    case 49: Field49 = value; break;
                    case 50: Field50 = value; break;
                    case 51: Field51 = value; break;
                    case 52: Field52 = value; break;
                    case 53: Field53 = value; break;
                    case 54: Field54 = value; break;
                    case 55: Field55 = value; break;
                    case 56: Field56 = value; break;
                    case 57: Field57 = value; break;
                    case 58: Field58 = value; break;
                    case 59: Field59 = value; break;
                    case 60: Field60 = value; break;
                    case 61: Field61 = value; break;
                    case 62: Field62 = value; break;
                    case 63: Field63 = value; break;
                    case 64: Field64 = value; break;
                    case 65: Field65 = value; break;
                    case 66: Field66 = value; break;
                    case 67: Field67 = value; break;
                    case 68: Field68 = value; break;
                    case 69: Field69 = value; break;
                    case 70: Field70 = value; break;
                    case 71: Field71 = value; break;
                    case 72: Field72 = value; break;
                    case 73: Field73 = value; break;
                    case 74: Field74 = value; break;
                    case 75: Field75 = value; break;
                    case 76: Field76 = value; break;
                    case 77: Field77 = value; break;
                    case 78: Field78 = value; break;
                    case 79: Field79 = value; break;
                    case 80: Field80 = value; break;
                    case 81: Field81 = value; break;
                    case 82: Field82 = value; break;
                    case 83: Field83 = value; break;
                    case 84: Field84 = value; break;
                    case 85: Field85 = value; break;
                    case 86: Field86 = value; break;
                    case 87: Field87 = value; break;
                    case 88: Field88 = value; break;
                    case 89: Field89 = value; break;
                    case 90: Field90 = value; break;
                    case 91: Field91 = value; break;
                    case 92: Field92 = value; break;
                    case 93: Field93 = value; break;
                    case 94: Field94 = value; break;
                    case 95: Field95 = value; break;
                    case 96: Field96 = value; break;
                    case 97: Field97 = value; break;
                    case 98: Field98 = value; break;
                    case 99: Field99 = value; break;
                    case 100: Field100 = value; break;
                    case 101: Field101 = value; break;
                    case 102: Field102 = value; break;
                    case 103: Field103 = value; break;
                    case 104: Field104 = value; break;
                    case 105: Field105 = value; break;
                    case 106: Field106 = value; break;
                    case 107: Field107 = value; break;
                    case 108: Field108 = value; break;
                    case 109: Field109 = value; break;
                    case 110: Field110 = value; break;
                    case 111: Field111 = value; break;
                    case 112: Field112 = value; break;
                    case 113: Field113 = value; break;
                    case 114: Field114 = value; break;
                    case 115: Field115 = value; break;
                    case 116: Field116 = value; break;
                    case 117: Field117 = value; break;
                    case 118: Field118 = value; break;
                    case 119: Field119 = value; break;
                    case 120: Field120 = value; break;
                    case 121: Field121 = value; break;
                    case 122: Field122 = value; break;
                    case 123: Field123 = value; break;
                    case 124: Field124 = value; break;
                    case 125: Field125 = value; break;
                    case 126: Field126 = value; break;
                    case 127: Field127 = value; break;
                    case 128: Field128 = value; break;
                    case 129: Field129 = value; break;
                    case 130: Field130 = value; break;
                    case 131: Field131 = value; break;
                    case 132: Field132 = value; break;
                    case 133: Field133 = value; break;
                    case 134: Field134 = value; break;
                    case 135: Field135 = value; break;
                    case 136: Field136 = value; break;
                    case 137: Field137 = value; break;
                    case 138: Field138 = value; break;
                    case 139: Field139 = value; break;
                    case 140: Field140 = value; break;
                    case 141: Field141 = value; break;
                    case 142: Field142 = value; break;
                    case 143: Field143 = value; break;
                    case 144: Field144 = value; break;
                    case 145: Field145 = value; break;
                    case 146: Field146 = value; break;
                    case 147: Field147 = value; break;
                    case 148: Field148 = value; break;
                    case 149: Field149 = value; break;
                    case 150: Field150 = value; break;
                    case 151: Field151 = value; break;
                    case 152: Field152 = value; break;
                    case 153: Field153 = value; break;
                    case 154: Field154 = value; break;
                    case 155: Field155 = value; break;
                    case 156: Field156 = value; break;
                    case 157: Field157 = value; break;
                    case 158: Field158 = value; break;
                    case 159: Field159 = value; break;
                    case 160: Field160 = value; break;
                    case 161: Field161 = value; break;
                    case 162: Field162 = value; break;
                    case 163: Field163 = value; break;
                    case 164: Field164 = value; break;
                    case 165: Field165 = value; break;
                    case 166: Field166 = value; break;
                    case 167: Field167 = value; break;
                    case 168: Field168 = value; break;
                    case 169: Field169 = value; break;
                    case 170: Field170 = value; break;
                    case 171: Field171 = value; break;
                    case 172: Field172 = value; break;
                    case 173: Field173 = value; break;
                    case 174: Field174 = value; break;
                    case 175: Field175 = value; break;
                    case 176: Field176 = value; break;
                    case 177: Field177 = value; break;
                    case 178: Field178 = value; break;
                    case 179: Field179 = value; break;
                    case 180: Field180 = value; break;
                    case 181: Field181 = value; break;
                    case 182: Field182 = value; break;
                    case 183: Field183 = value; break;
                    case 184: Field184 = value; break;
                    case 185: Field185 = value; break;
                    case 186: Field186 = value; break;
                    case 187: Field187 = value; break;
                    case 188: Field188 = value; break;
                    case 189: Field189 = value; break;
                    case 190: Field190 = value; break;
                    case 191: Field191 = value; break;
                    case 192: Field192 = value; break;
                    case 193: Field193 = value; break;
                    case 194: Field194 = value; break;
                    case 195: Field195 = value; break;
                    case 196: Field196 = value; break;
                    case 197: Field197 = value; break;
                    case 198: Field198 = value; break;
                    case 199: Field199 = value; break;
                    case 200: Field200 = value; break;
                    case 201: Field201 = value; break;
                    case 202: Field202 = value; break;
                    case 203: Field203 = value; break;
                    case 204: Field204 = value; break;
                    case 205: Field205 = value; break;
                    case 206: Field206 = value; break;
                    case 207: Field207 = value; break;
                    case 208: Field208 = value; break;
                    case 209: Field209 = value; break;
                    case 210: Field210 = value; break;
                    case 211: Field211 = value; break;
                    case 212: Field212 = value; break;
                    case 213: Field213 = value; break;
                    case 214: Field214 = value; break;
                    case 215: Field215 = value; break;
                    case 216: Field216 = value; break;
                    case 217: Field217 = value; break;
                    case 218: Field218 = value; break;
                    case 219: Field219 = value; break;
                    case 220: Field220 = value; break;
                    case 221: Field221 = value; break;
                    case 222: Field222 = value; break;
                    case 223: Field223 = value; break;
                    case 224: Field224 = value; break;
                    case 225: Field225 = value; break;
                    case 226: Field226 = value; break;
                    case 227: Field227 = value; break;
                    case 228: Field228 = value; break;
                    case 229: Field229 = value; break;
                    case 230: Field230 = value; break;
                    case 231: Field231 = value; break;
                    case 232: Field232 = value; break;
                    case 233: Field233 = value; break;
                    case 234: Field234 = value; break;
                    case 235: Field235 = value; break;
                    case 236: Field236 = value; break;
                    case 237: Field237 = value; break;
                    case 238: Field238 = value; break;
                    case 239: Field239 = value; break;
                    case 240: Field240 = value; break;
                    case 241: Field241 = value; break;
                    case 242: Field242 = value; break;
                    case 243: Field243 = value; break;
                    case 244: Field244 = value; break;
                    case 245: Field245 = value; break;
                    case 246: Field246 = value; break;
                    case 247: Field247 = value; break;
                    case 248: Field248 = value; break;
                    case 249: Field249 = value; break;
                    case 250: Field250 = value; break;
                    case 251: Field251 = value; break;
                    case 252: Field252 = value; break;
                    case 253: Field253 = value; break;
                    case 254: Field254 = value; break;
                    case 255: Field255 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray256) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray256)other);

        public readonly bool Equals(in FixedLengthByteArray256 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray256 left, in FixedLengthByteArray256 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray256 left, in FixedLengthByteArray256 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
              yield return Field46;
              yield return Field47;
              yield return Field48;
              yield return Field49;
              yield return Field50;
              yield return Field51;
              yield return Field52;
              yield return Field53;
              yield return Field54;
              yield return Field55;
              yield return Field56;
              yield return Field57;
              yield return Field58;
              yield return Field59;
              yield return Field60;
              yield return Field61;
              yield return Field62;
              yield return Field63;
              yield return Field64;
              yield return Field65;
              yield return Field66;
              yield return Field67;
              yield return Field68;
              yield return Field69;
              yield return Field70;
              yield return Field71;
              yield return Field72;
              yield return Field73;
              yield return Field74;
              yield return Field75;
              yield return Field76;
              yield return Field77;
              yield return Field78;
              yield return Field79;
              yield return Field80;
              yield return Field81;
              yield return Field82;
              yield return Field83;
              yield return Field84;
              yield return Field85;
              yield return Field86;
              yield return Field87;
              yield return Field88;
              yield return Field89;
              yield return Field90;
              yield return Field91;
              yield return Field92;
              yield return Field93;
              yield return Field94;
              yield return Field95;
              yield return Field96;
              yield return Field97;
              yield return Field98;
              yield return Field99;
              yield return Field100;
              yield return Field101;
              yield return Field102;
              yield return Field103;
              yield return Field104;
              yield return Field105;
              yield return Field106;
              yield return Field107;
              yield return Field108;
              yield return Field109;
              yield return Field110;
              yield return Field111;
              yield return Field112;
              yield return Field113;
              yield return Field114;
              yield return Field115;
              yield return Field116;
              yield return Field117;
              yield return Field118;
              yield return Field119;
              yield return Field120;
              yield return Field121;
              yield return Field122;
              yield return Field123;
              yield return Field124;
              yield return Field125;
              yield return Field126;
              yield return Field127;
              yield return Field128;
              yield return Field129;
              yield return Field130;
              yield return Field131;
              yield return Field132;
              yield return Field133;
              yield return Field134;
              yield return Field135;
              yield return Field136;
              yield return Field137;
              yield return Field138;
              yield return Field139;
              yield return Field140;
              yield return Field141;
              yield return Field142;
              yield return Field143;
              yield return Field144;
              yield return Field145;
              yield return Field146;
              yield return Field147;
              yield return Field148;
              yield return Field149;
              yield return Field150;
              yield return Field151;
              yield return Field152;
              yield return Field153;
              yield return Field154;
              yield return Field155;
              yield return Field156;
              yield return Field157;
              yield return Field158;
              yield return Field159;
              yield return Field160;
              yield return Field161;
              yield return Field162;
              yield return Field163;
              yield return Field164;
              yield return Field165;
              yield return Field166;
              yield return Field167;
              yield return Field168;
              yield return Field169;
              yield return Field170;
              yield return Field171;
              yield return Field172;
              yield return Field173;
              yield return Field174;
              yield return Field175;
              yield return Field176;
              yield return Field177;
              yield return Field178;
              yield return Field179;
              yield return Field180;
              yield return Field181;
              yield return Field182;
              yield return Field183;
              yield return Field184;
              yield return Field185;
              yield return Field186;
              yield return Field187;
              yield return Field188;
              yield return Field189;
              yield return Field190;
              yield return Field191;
              yield return Field192;
              yield return Field193;
              yield return Field194;
              yield return Field195;
              yield return Field196;
              yield return Field197;
              yield return Field198;
              yield return Field199;
              yield return Field200;
              yield return Field201;
              yield return Field202;
              yield return Field203;
              yield return Field204;
              yield return Field205;
              yield return Field206;
              yield return Field207;
              yield return Field208;
              yield return Field209;
              yield return Field210;
              yield return Field211;
              yield return Field212;
              yield return Field213;
              yield return Field214;
              yield return Field215;
              yield return Field216;
              yield return Field217;
              yield return Field218;
              yield return Field219;
              yield return Field220;
              yield return Field221;
              yield return Field222;
              yield return Field223;
              yield return Field224;
              yield return Field225;
              yield return Field226;
              yield return Field227;
              yield return Field228;
              yield return Field229;
              yield return Field230;
              yield return Field231;
              yield return Field232;
              yield return Field233;
              yield return Field234;
              yield return Field235;
              yield return Field236;
              yield return Field237;
              yield return Field238;
              yield return Field239;
              yield return Field240;
              yield return Field241;
              yield return Field242;
              yield return Field243;
              yield return Field244;
              yield return Field245;
              yield return Field246;
              yield return Field247;
              yield return Field248;
              yield return Field249;
              yield return Field250;
              yield return Field251;
              yield return Field252;
              yield return Field253;
              yield return Field254;
              yield return Field255;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray256 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray256 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray256 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray256 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
                case 46: return ref array.Field46;
                case 47: return ref array.Field47;
                case 48: return ref array.Field48;
                case 49: return ref array.Field49;
                case 50: return ref array.Field50;
                case 51: return ref array.Field51;
                case 52: return ref array.Field52;
                case 53: return ref array.Field53;
                case 54: return ref array.Field54;
                case 55: return ref array.Field55;
                case 56: return ref array.Field56;
                case 57: return ref array.Field57;
                case 58: return ref array.Field58;
                case 59: return ref array.Field59;
                case 60: return ref array.Field60;
                case 61: return ref array.Field61;
                case 62: return ref array.Field62;
                case 63: return ref array.Field63;
                case 64: return ref array.Field64;
                case 65: return ref array.Field65;
                case 66: return ref array.Field66;
                case 67: return ref array.Field67;
                case 68: return ref array.Field68;
                case 69: return ref array.Field69;
                case 70: return ref array.Field70;
                case 71: return ref array.Field71;
                case 72: return ref array.Field72;
                case 73: return ref array.Field73;
                case 74: return ref array.Field74;
                case 75: return ref array.Field75;
                case 76: return ref array.Field76;
                case 77: return ref array.Field77;
                case 78: return ref array.Field78;
                case 79: return ref array.Field79;
                case 80: return ref array.Field80;
                case 81: return ref array.Field81;
                case 82: return ref array.Field82;
                case 83: return ref array.Field83;
                case 84: return ref array.Field84;
                case 85: return ref array.Field85;
                case 86: return ref array.Field86;
                case 87: return ref array.Field87;
                case 88: return ref array.Field88;
                case 89: return ref array.Field89;
                case 90: return ref array.Field90;
                case 91: return ref array.Field91;
                case 92: return ref array.Field92;
                case 93: return ref array.Field93;
                case 94: return ref array.Field94;
                case 95: return ref array.Field95;
                case 96: return ref array.Field96;
                case 97: return ref array.Field97;
                case 98: return ref array.Field98;
                case 99: return ref array.Field99;
                case 100: return ref array.Field100;
                case 101: return ref array.Field101;
                case 102: return ref array.Field102;
                case 103: return ref array.Field103;
                case 104: return ref array.Field104;
                case 105: return ref array.Field105;
                case 106: return ref array.Field106;
                case 107: return ref array.Field107;
                case 108: return ref array.Field108;
                case 109: return ref array.Field109;
                case 110: return ref array.Field110;
                case 111: return ref array.Field111;
                case 112: return ref array.Field112;
                case 113: return ref array.Field113;
                case 114: return ref array.Field114;
                case 115: return ref array.Field115;
                case 116: return ref array.Field116;
                case 117: return ref array.Field117;
                case 118: return ref array.Field118;
                case 119: return ref array.Field119;
                case 120: return ref array.Field120;
                case 121: return ref array.Field121;
                case 122: return ref array.Field122;
                case 123: return ref array.Field123;
                case 124: return ref array.Field124;
                case 125: return ref array.Field125;
                case 126: return ref array.Field126;
                case 127: return ref array.Field127;
                case 128: return ref array.Field128;
                case 129: return ref array.Field129;
                case 130: return ref array.Field130;
                case 131: return ref array.Field131;
                case 132: return ref array.Field132;
                case 133: return ref array.Field133;
                case 134: return ref array.Field134;
                case 135: return ref array.Field135;
                case 136: return ref array.Field136;
                case 137: return ref array.Field137;
                case 138: return ref array.Field138;
                case 139: return ref array.Field139;
                case 140: return ref array.Field140;
                case 141: return ref array.Field141;
                case 142: return ref array.Field142;
                case 143: return ref array.Field143;
                case 144: return ref array.Field144;
                case 145: return ref array.Field145;
                case 146: return ref array.Field146;
                case 147: return ref array.Field147;
                case 148: return ref array.Field148;
                case 149: return ref array.Field149;
                case 150: return ref array.Field150;
                case 151: return ref array.Field151;
                case 152: return ref array.Field152;
                case 153: return ref array.Field153;
                case 154: return ref array.Field154;
                case 155: return ref array.Field155;
                case 156: return ref array.Field156;
                case 157: return ref array.Field157;
                case 158: return ref array.Field158;
                case 159: return ref array.Field159;
                case 160: return ref array.Field160;
                case 161: return ref array.Field161;
                case 162: return ref array.Field162;
                case 163: return ref array.Field163;
                case 164: return ref array.Field164;
                case 165: return ref array.Field165;
                case 166: return ref array.Field166;
                case 167: return ref array.Field167;
                case 168: return ref array.Field168;
                case 169: return ref array.Field169;
                case 170: return ref array.Field170;
                case 171: return ref array.Field171;
                case 172: return ref array.Field172;
                case 173: return ref array.Field173;
                case 174: return ref array.Field174;
                case 175: return ref array.Field175;
                case 176: return ref array.Field176;
                case 177: return ref array.Field177;
                case 178: return ref array.Field178;
                case 179: return ref array.Field179;
                case 180: return ref array.Field180;
                case 181: return ref array.Field181;
                case 182: return ref array.Field182;
                case 183: return ref array.Field183;
                case 184: return ref array.Field184;
                case 185: return ref array.Field185;
                case 186: return ref array.Field186;
                case 187: return ref array.Field187;
                case 188: return ref array.Field188;
                case 189: return ref array.Field189;
                case 190: return ref array.Field190;
                case 191: return ref array.Field191;
                case 192: return ref array.Field192;
                case 193: return ref array.Field193;
                case 194: return ref array.Field194;
                case 195: return ref array.Field195;
                case 196: return ref array.Field196;
                case 197: return ref array.Field197;
                case 198: return ref array.Field198;
                case 199: return ref array.Field199;
                case 200: return ref array.Field200;
                case 201: return ref array.Field201;
                case 202: return ref array.Field202;
                case 203: return ref array.Field203;
                case 204: return ref array.Field204;
                case 205: return ref array.Field205;
                case 206: return ref array.Field206;
                case 207: return ref array.Field207;
                case 208: return ref array.Field208;
                case 209: return ref array.Field209;
                case 210: return ref array.Field210;
                case 211: return ref array.Field211;
                case 212: return ref array.Field212;
                case 213: return ref array.Field213;
                case 214: return ref array.Field214;
                case 215: return ref array.Field215;
                case 216: return ref array.Field216;
                case 217: return ref array.Field217;
                case 218: return ref array.Field218;
                case 219: return ref array.Field219;
                case 220: return ref array.Field220;
                case 221: return ref array.Field221;
                case 222: return ref array.Field222;
                case 223: return ref array.Field223;
                case 224: return ref array.Field224;
                case 225: return ref array.Field225;
                case 226: return ref array.Field226;
                case 227: return ref array.Field227;
                case 228: return ref array.Field228;
                case 229: return ref array.Field229;
                case 230: return ref array.Field230;
                case 231: return ref array.Field231;
                case 232: return ref array.Field232;
                case 233: return ref array.Field233;
                case 234: return ref array.Field234;
                case 235: return ref array.Field235;
                case 236: return ref array.Field236;
                case 237: return ref array.Field237;
                case 238: return ref array.Field238;
                case 239: return ref array.Field239;
                case 240: return ref array.Field240;
                case 241: return ref array.Field241;
                case 242: return ref array.Field242;
                case 243: return ref array.Field243;
                case 244: return ref array.Field244;
                case 245: return ref array.Field245;
                case 246: return ref array.Field246;
                case 247: return ref array.Field247;
                case 248: return ref array.Field248;
                case 249: return ref array.Field249;
                case 250: return ref array.Field250;
                case 251: return ref array.Field251;
                case 252: return ref array.Field252;
                case 253: return ref array.Field253;
                case 254: return ref array.Field254;
                case 255: return ref array.Field255;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray256 array1, in FixedLengthByteArray256 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray256 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray256 array1, in FixedLengthByteArray256 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray256 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray256 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray256 array1, in FixedLengthByteArray256 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray256 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray256 array1, in FixedLengthByteArray256 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray256 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 260 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray260
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray260 _Zero = default;
		public static ref readonly FixedLengthByteArray260 Zero => ref _Zero;

		public const int ConstLength = 260;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray260(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
			, Byte field25
			, Byte field26
			, Byte field27
			, Byte field28
			, Byte field29
			, Byte field30
			, Byte field31
			, Byte field32
			, Byte field33
			, Byte field34
			, Byte field35
			, Byte field36
			, Byte field37
			, Byte field38
			, Byte field39
			, Byte field40
			, Byte field41
			, Byte field42
			, Byte field43
			, Byte field44
			, Byte field45
			, Byte field46
			, Byte field47
			, Byte field48
			, Byte field49
			, Byte field50
			, Byte field51
			, Byte field52
			, Byte field53
			, Byte field54
			, Byte field55
			, Byte field56
			, Byte field57
			, Byte field58
			, Byte field59
			, Byte field60
			, Byte field61
			, Byte field62
			, Byte field63
			, Byte field64
			, Byte field65
			, Byte field66
			, Byte field67
			, Byte field68
			, Byte field69
			, Byte field70
			, Byte field71
			, Byte field72
			, Byte field73
			, Byte field74
			, Byte field75
			, Byte field76
			, Byte field77
			, Byte field78
			, Byte field79
			, Byte field80
			, Byte field81
			, Byte field82
			, Byte field83
			, Byte field84
			, Byte field85
			, Byte field86
			, Byte field87
			, Byte field88
			, Byte field89
			, Byte field90
			, Byte field91
			, Byte field92
			, Byte field93
			, Byte field94
			, Byte field95
			, Byte field96
			, Byte field97
			, Byte field98
			, Byte field99
			, Byte field100
			, Byte field101
			, Byte field102
			, Byte field103
			, Byte field104
			, Byte field105
			, Byte field106
			, Byte field107
			, Byte field108
			, Byte field109
			, Byte field110
			, Byte field111
			, Byte field112
			, Byte field113
			, Byte field114
			, Byte field115
			, Byte field116
			, Byte field117
			, Byte field118
			, Byte field119
			, Byte field120
			, Byte field121
			, Byte field122
			, Byte field123
			, Byte field124
			, Byte field125
			, Byte field126
			, Byte field127
			, Byte field128
			, Byte field129
			, Byte field130
			, Byte field131
			, Byte field132
			, Byte field133
			, Byte field134
			, Byte field135
			, Byte field136
			, Byte field137
			, Byte field138
			, Byte field139
			, Byte field140
			, Byte field141
			, Byte field142
			, Byte field143
			, Byte field144
			, Byte field145
			, Byte field146
			, Byte field147
			, Byte field148
			, Byte field149
			, Byte field150
			, Byte field151
			, Byte field152
			, Byte field153
			, Byte field154
			, Byte field155
			, Byte field156
			, Byte field157
			, Byte field158
			, Byte field159
			, Byte field160
			, Byte field161
			, Byte field162
			, Byte field163
			, Byte field164
			, Byte field165
			, Byte field166
			, Byte field167
			, Byte field168
			, Byte field169
			, Byte field170
			, Byte field171
			, Byte field172
			, Byte field173
			, Byte field174
			, Byte field175
			, Byte field176
			, Byte field177
			, Byte field178
			, Byte field179
			, Byte field180
			, Byte field181
			, Byte field182
			, Byte field183
			, Byte field184
			, Byte field185
			, Byte field186
			, Byte field187
			, Byte field188
			, Byte field189
			, Byte field190
			, Byte field191
			, Byte field192
			, Byte field193
			, Byte field194
			, Byte field195
			, Byte field196
			, Byte field197
			, Byte field198
			, Byte field199
			, Byte field200
			, Byte field201
			, Byte field202
			, Byte field203
			, Byte field204
			, Byte field205
			, Byte field206
			, Byte field207
			, Byte field208
			, Byte field209
			, Byte field210
			, Byte field211
			, Byte field212
			, Byte field213
			, Byte field214
			, Byte field215
			, Byte field216
			, Byte field217
			, Byte field218
			, Byte field219
			, Byte field220
			, Byte field221
			, Byte field222
			, Byte field223
			, Byte field224
			, Byte field225
			, Byte field226
			, Byte field227
			, Byte field228
			, Byte field229
			, Byte field230
			, Byte field231
			, Byte field232
			, Byte field233
			, Byte field234
			, Byte field235
			, Byte field236
			, Byte field237
			, Byte field238
			, Byte field239
			, Byte field240
			, Byte field241
			, Byte field242
			, Byte field243
			, Byte field244
			, Byte field245
			, Byte field246
			, Byte field247
			, Byte field248
			, Byte field249
			, Byte field250
			, Byte field251
			, Byte field252
			, Byte field253
			, Byte field254
			, Byte field255
			, Byte field256
			, Byte field257
			, Byte field258
			, Byte field259
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
			Field46 = field46;
			Field47 = field47;
			Field48 = field48;
			Field49 = field49;
			Field50 = field50;
			Field51 = field51;
			Field52 = field52;
			Field53 = field53;
			Field54 = field54;
			Field55 = field55;
			Field56 = field56;
			Field57 = field57;
			Field58 = field58;
			Field59 = field59;
			Field60 = field60;
			Field61 = field61;
			Field62 = field62;
			Field63 = field63;
			Field64 = field64;
			Field65 = field65;
			Field66 = field66;
			Field67 = field67;
			Field68 = field68;
			Field69 = field69;
			Field70 = field70;
			Field71 = field71;
			Field72 = field72;
			Field73 = field73;
			Field74 = field74;
			Field75 = field75;
			Field76 = field76;
			Field77 = field77;
			Field78 = field78;
			Field79 = field79;
			Field80 = field80;
			Field81 = field81;
			Field82 = field82;
			Field83 = field83;
			Field84 = field84;
			Field85 = field85;
			Field86 = field86;
			Field87 = field87;
			Field88 = field88;
			Field89 = field89;
			Field90 = field90;
			Field91 = field91;
			Field92 = field92;
			Field93 = field93;
			Field94 = field94;
			Field95 = field95;
			Field96 = field96;
			Field97 = field97;
			Field98 = field98;
			Field99 = field99;
			Field100 = field100;
			Field101 = field101;
			Field102 = field102;
			Field103 = field103;
			Field104 = field104;
			Field105 = field105;
			Field106 = field106;
			Field107 = field107;
			Field108 = field108;
			Field109 = field109;
			Field110 = field110;
			Field111 = field111;
			Field112 = field112;
			Field113 = field113;
			Field114 = field114;
			Field115 = field115;
			Field116 = field116;
			Field117 = field117;
			Field118 = field118;
			Field119 = field119;
			Field120 = field120;
			Field121 = field121;
			Field122 = field122;
			Field123 = field123;
			Field124 = field124;
			Field125 = field125;
			Field126 = field126;
			Field127 = field127;
			Field128 = field128;
			Field129 = field129;
			Field130 = field130;
			Field131 = field131;
			Field132 = field132;
			Field133 = field133;
			Field134 = field134;
			Field135 = field135;
			Field136 = field136;
			Field137 = field137;
			Field138 = field138;
			Field139 = field139;
			Field140 = field140;
			Field141 = field141;
			Field142 = field142;
			Field143 = field143;
			Field144 = field144;
			Field145 = field145;
			Field146 = field146;
			Field147 = field147;
			Field148 = field148;
			Field149 = field149;
			Field150 = field150;
			Field151 = field151;
			Field152 = field152;
			Field153 = field153;
			Field154 = field154;
			Field155 = field155;
			Field156 = field156;
			Field157 = field157;
			Field158 = field158;
			Field159 = field159;
			Field160 = field160;
			Field161 = field161;
			Field162 = field162;
			Field163 = field163;
			Field164 = field164;
			Field165 = field165;
			Field166 = field166;
			Field167 = field167;
			Field168 = field168;
			Field169 = field169;
			Field170 = field170;
			Field171 = field171;
			Field172 = field172;
			Field173 = field173;
			Field174 = field174;
			Field175 = field175;
			Field176 = field176;
			Field177 = field177;
			Field178 = field178;
			Field179 = field179;
			Field180 = field180;
			Field181 = field181;
			Field182 = field182;
			Field183 = field183;
			Field184 = field184;
			Field185 = field185;
			Field186 = field186;
			Field187 = field187;
			Field188 = field188;
			Field189 = field189;
			Field190 = field190;
			Field191 = field191;
			Field192 = field192;
			Field193 = field193;
			Field194 = field194;
			Field195 = field195;
			Field196 = field196;
			Field197 = field197;
			Field198 = field198;
			Field199 = field199;
			Field200 = field200;
			Field201 = field201;
			Field202 = field202;
			Field203 = field203;
			Field204 = field204;
			Field205 = field205;
			Field206 = field206;
			Field207 = field207;
			Field208 = field208;
			Field209 = field209;
			Field210 = field210;
			Field211 = field211;
			Field212 = field212;
			Field213 = field213;
			Field214 = field214;
			Field215 = field215;
			Field216 = field216;
			Field217 = field217;
			Field218 = field218;
			Field219 = field219;
			Field220 = field220;
			Field221 = field221;
			Field222 = field222;
			Field223 = field223;
			Field224 = field224;
			Field225 = field225;
			Field226 = field226;
			Field227 = field227;
			Field228 = field228;
			Field229 = field229;
			Field230 = field230;
			Field231 = field231;
			Field232 = field232;
			Field233 = field233;
			Field234 = field234;
			Field235 = field235;
			Field236 = field236;
			Field237 = field237;
			Field238 = field238;
			Field239 = field239;
			Field240 = field240;
			Field241 = field241;
			Field242 = field242;
			Field243 = field243;
			Field244 = field244;
			Field245 = field245;
			Field246 = field246;
			Field247 = field247;
			Field248 = field248;
			Field249 = field249;
			Field250 = field250;
			Field251 = field251;
			Field252 = field252;
			Field253 = field253;
			Field254 = field254;
			Field255 = field255;
			Field256 = field256;
			Field257 = field257;
			Field258 = field258;
			Field259 = field259;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
		public Byte Field25;
		public Byte Field26;
		public Byte Field27;
		public Byte Field28;
		public Byte Field29;
		public Byte Field30;
		public Byte Field31;
		public Byte Field32;
		public Byte Field33;
		public Byte Field34;
		public Byte Field35;
		public Byte Field36;
		public Byte Field37;
		public Byte Field38;
		public Byte Field39;
		public Byte Field40;
		public Byte Field41;
		public Byte Field42;
		public Byte Field43;
		public Byte Field44;
		public Byte Field45;
		public Byte Field46;
		public Byte Field47;
		public Byte Field48;
		public Byte Field49;
		public Byte Field50;
		public Byte Field51;
		public Byte Field52;
		public Byte Field53;
		public Byte Field54;
		public Byte Field55;
		public Byte Field56;
		public Byte Field57;
		public Byte Field58;
		public Byte Field59;
		public Byte Field60;
		public Byte Field61;
		public Byte Field62;
		public Byte Field63;
		public Byte Field64;
		public Byte Field65;
		public Byte Field66;
		public Byte Field67;
		public Byte Field68;
		public Byte Field69;
		public Byte Field70;
		public Byte Field71;
		public Byte Field72;
		public Byte Field73;
		public Byte Field74;
		public Byte Field75;
		public Byte Field76;
		public Byte Field77;
		public Byte Field78;
		public Byte Field79;
		public Byte Field80;
		public Byte Field81;
		public Byte Field82;
		public Byte Field83;
		public Byte Field84;
		public Byte Field85;
		public Byte Field86;
		public Byte Field87;
		public Byte Field88;
		public Byte Field89;
		public Byte Field90;
		public Byte Field91;
		public Byte Field92;
		public Byte Field93;
		public Byte Field94;
		public Byte Field95;
		public Byte Field96;
		public Byte Field97;
		public Byte Field98;
		public Byte Field99;
		public Byte Field100;
		public Byte Field101;
		public Byte Field102;
		public Byte Field103;
		public Byte Field104;
		public Byte Field105;
		public Byte Field106;
		public Byte Field107;
		public Byte Field108;
		public Byte Field109;
		public Byte Field110;
		public Byte Field111;
		public Byte Field112;
		public Byte Field113;
		public Byte Field114;
		public Byte Field115;
		public Byte Field116;
		public Byte Field117;
		public Byte Field118;
		public Byte Field119;
		public Byte Field120;
		public Byte Field121;
		public Byte Field122;
		public Byte Field123;
		public Byte Field124;
		public Byte Field125;
		public Byte Field126;
		public Byte Field127;
		public Byte Field128;
		public Byte Field129;
		public Byte Field130;
		public Byte Field131;
		public Byte Field132;
		public Byte Field133;
		public Byte Field134;
		public Byte Field135;
		public Byte Field136;
		public Byte Field137;
		public Byte Field138;
		public Byte Field139;
		public Byte Field140;
		public Byte Field141;
		public Byte Field142;
		public Byte Field143;
		public Byte Field144;
		public Byte Field145;
		public Byte Field146;
		public Byte Field147;
		public Byte Field148;
		public Byte Field149;
		public Byte Field150;
		public Byte Field151;
		public Byte Field152;
		public Byte Field153;
		public Byte Field154;
		public Byte Field155;
		public Byte Field156;
		public Byte Field157;
		public Byte Field158;
		public Byte Field159;
		public Byte Field160;
		public Byte Field161;
		public Byte Field162;
		public Byte Field163;
		public Byte Field164;
		public Byte Field165;
		public Byte Field166;
		public Byte Field167;
		public Byte Field168;
		public Byte Field169;
		public Byte Field170;
		public Byte Field171;
		public Byte Field172;
		public Byte Field173;
		public Byte Field174;
		public Byte Field175;
		public Byte Field176;
		public Byte Field177;
		public Byte Field178;
		public Byte Field179;
		public Byte Field180;
		public Byte Field181;
		public Byte Field182;
		public Byte Field183;
		public Byte Field184;
		public Byte Field185;
		public Byte Field186;
		public Byte Field187;
		public Byte Field188;
		public Byte Field189;
		public Byte Field190;
		public Byte Field191;
		public Byte Field192;
		public Byte Field193;
		public Byte Field194;
		public Byte Field195;
		public Byte Field196;
		public Byte Field197;
		public Byte Field198;
		public Byte Field199;
		public Byte Field200;
		public Byte Field201;
		public Byte Field202;
		public Byte Field203;
		public Byte Field204;
		public Byte Field205;
		public Byte Field206;
		public Byte Field207;
		public Byte Field208;
		public Byte Field209;
		public Byte Field210;
		public Byte Field211;
		public Byte Field212;
		public Byte Field213;
		public Byte Field214;
		public Byte Field215;
		public Byte Field216;
		public Byte Field217;
		public Byte Field218;
		public Byte Field219;
		public Byte Field220;
		public Byte Field221;
		public Byte Field222;
		public Byte Field223;
		public Byte Field224;
		public Byte Field225;
		public Byte Field226;
		public Byte Field227;
		public Byte Field228;
		public Byte Field229;
		public Byte Field230;
		public Byte Field231;
		public Byte Field232;
		public Byte Field233;
		public Byte Field234;
		public Byte Field235;
		public Byte Field236;
		public Byte Field237;
		public Byte Field238;
		public Byte Field239;
		public Byte Field240;
		public Byte Field241;
		public Byte Field242;
		public Byte Field243;
		public Byte Field244;
		public Byte Field245;
		public Byte Field246;
		public Byte Field247;
		public Byte Field248;
		public Byte Field249;
		public Byte Field250;
		public Byte Field251;
		public Byte Field252;
		public Byte Field253;
		public Byte Field254;
		public Byte Field255;
		public Byte Field256;
		public Byte Field257;
		public Byte Field258;
		public Byte Field259;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                46 => Field46,
                47 => Field47,
                48 => Field48,
                49 => Field49,
                50 => Field50,
                51 => Field51,
                52 => Field52,
                53 => Field53,
                54 => Field54,
                55 => Field55,
                56 => Field56,
                57 => Field57,
                58 => Field58,
                59 => Field59,
                60 => Field60,
                61 => Field61,
                62 => Field62,
                63 => Field63,
                64 => Field64,
                65 => Field65,
                66 => Field66,
                67 => Field67,
                68 => Field68,
                69 => Field69,
                70 => Field70,
                71 => Field71,
                72 => Field72,
                73 => Field73,
                74 => Field74,
                75 => Field75,
                76 => Field76,
                77 => Field77,
                78 => Field78,
                79 => Field79,
                80 => Field80,
                81 => Field81,
                82 => Field82,
                83 => Field83,
                84 => Field84,
                85 => Field85,
                86 => Field86,
                87 => Field87,
                88 => Field88,
                89 => Field89,
                90 => Field90,
                91 => Field91,
                92 => Field92,
                93 => Field93,
                94 => Field94,
                95 => Field95,
                96 => Field96,
                97 => Field97,
                98 => Field98,
                99 => Field99,
                100 => Field100,
                101 => Field101,
                102 => Field102,
                103 => Field103,
                104 => Field104,
                105 => Field105,
                106 => Field106,
                107 => Field107,
                108 => Field108,
                109 => Field109,
                110 => Field110,
                111 => Field111,
                112 => Field112,
                113 => Field113,
                114 => Field114,
                115 => Field115,
                116 => Field116,
                117 => Field117,
                118 => Field118,
                119 => Field119,
                120 => Field120,
                121 => Field121,
                122 => Field122,
                123 => Field123,
                124 => Field124,
                125 => Field125,
                126 => Field126,
                127 => Field127,
                128 => Field128,
                129 => Field129,
                130 => Field130,
                131 => Field131,
                132 => Field132,
                133 => Field133,
                134 => Field134,
                135 => Field135,
                136 => Field136,
                137 => Field137,
                138 => Field138,
                139 => Field139,
                140 => Field140,
                141 => Field141,
                142 => Field142,
                143 => Field143,
                144 => Field144,
                145 => Field145,
                146 => Field146,
                147 => Field147,
                148 => Field148,
                149 => Field149,
                150 => Field150,
                151 => Field151,
                152 => Field152,
                153 => Field153,
                154 => Field154,
                155 => Field155,
                156 => Field156,
                157 => Field157,
                158 => Field158,
                159 => Field159,
                160 => Field160,
                161 => Field161,
                162 => Field162,
                163 => Field163,
                164 => Field164,
                165 => Field165,
                166 => Field166,
                167 => Field167,
                168 => Field168,
                169 => Field169,
                170 => Field170,
                171 => Field171,
                172 => Field172,
                173 => Field173,
                174 => Field174,
                175 => Field175,
                176 => Field176,
                177 => Field177,
                178 => Field178,
                179 => Field179,
                180 => Field180,
                181 => Field181,
                182 => Field182,
                183 => Field183,
                184 => Field184,
                185 => Field185,
                186 => Field186,
                187 => Field187,
                188 => Field188,
                189 => Field189,
                190 => Field190,
                191 => Field191,
                192 => Field192,
                193 => Field193,
                194 => Field194,
                195 => Field195,
                196 => Field196,
                197 => Field197,
                198 => Field198,
                199 => Field199,
                200 => Field200,
                201 => Field201,
                202 => Field202,
                203 => Field203,
                204 => Field204,
                205 => Field205,
                206 => Field206,
                207 => Field207,
                208 => Field208,
                209 => Field209,
                210 => Field210,
                211 => Field211,
                212 => Field212,
                213 => Field213,
                214 => Field214,
                215 => Field215,
                216 => Field216,
                217 => Field217,
                218 => Field218,
                219 => Field219,
                220 => Field220,
                221 => Field221,
                222 => Field222,
                223 => Field223,
                224 => Field224,
                225 => Field225,
                226 => Field226,
                227 => Field227,
                228 => Field228,
                229 => Field229,
                230 => Field230,
                231 => Field231,
                232 => Field232,
                233 => Field233,
                234 => Field234,
                235 => Field235,
                236 => Field236,
                237 => Field237,
                238 => Field238,
                239 => Field239,
                240 => Field240,
                241 => Field241,
                242 => Field242,
                243 => Field243,
                244 => Field244,
                245 => Field245,
                246 => Field246,
                247 => Field247,
                248 => Field248,
                249 => Field249,
                250 => Field250,
                251 => Field251,
                252 => Field252,
                253 => Field253,
                254 => Field254,
                255 => Field255,
                256 => Field256,
                257 => Field257,
                258 => Field258,
                259 => Field259,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
                    case 46: Field46 = value; break;
                    case 47: Field47 = value; break;
                    case 48: Field48 = value; break;
                    case 49: Field49 = value; break;
                    case 50: Field50 = value; break;
                    case 51: Field51 = value; break;
                    case 52: Field52 = value; break;
                    case 53: Field53 = value; break;
                    case 54: Field54 = value; break;
                    case 55: Field55 = value; break;
                    case 56: Field56 = value; break;
                    case 57: Field57 = value; break;
                    case 58: Field58 = value; break;
                    case 59: Field59 = value; break;
                    case 60: Field60 = value; break;
                    case 61: Field61 = value; break;
                    case 62: Field62 = value; break;
                    case 63: Field63 = value; break;
                    case 64: Field64 = value; break;
                    case 65: Field65 = value; break;
                    case 66: Field66 = value; break;
                    case 67: Field67 = value; break;
                    case 68: Field68 = value; break;
                    case 69: Field69 = value; break;
                    case 70: Field70 = value; break;
                    case 71: Field71 = value; break;
                    case 72: Field72 = value; break;
                    case 73: Field73 = value; break;
                    case 74: Field74 = value; break;
                    case 75: Field75 = value; break;
                    case 76: Field76 = value; break;
                    case 77: Field77 = value; break;
                    case 78: Field78 = value; break;
                    case 79: Field79 = value; break;
                    case 80: Field80 = value; break;
                    case 81: Field81 = value; break;
                    case 82: Field82 = value; break;
                    case 83: Field83 = value; break;
                    case 84: Field84 = value; break;
                    case 85: Field85 = value; break;
                    case 86: Field86 = value; break;
                    case 87: Field87 = value; break;
                    case 88: Field88 = value; break;
                    case 89: Field89 = value; break;
                    case 90: Field90 = value; break;
                    case 91: Field91 = value; break;
                    case 92: Field92 = value; break;
                    case 93: Field93 = value; break;
                    case 94: Field94 = value; break;
                    case 95: Field95 = value; break;
                    case 96: Field96 = value; break;
                    case 97: Field97 = value; break;
                    case 98: Field98 = value; break;
                    case 99: Field99 = value; break;
                    case 100: Field100 = value; break;
                    case 101: Field101 = value; break;
                    case 102: Field102 = value; break;
                    case 103: Field103 = value; break;
                    case 104: Field104 = value; break;
                    case 105: Field105 = value; break;
                    case 106: Field106 = value; break;
                    case 107: Field107 = value; break;
                    case 108: Field108 = value; break;
                    case 109: Field109 = value; break;
                    case 110: Field110 = value; break;
                    case 111: Field111 = value; break;
                    case 112: Field112 = value; break;
                    case 113: Field113 = value; break;
                    case 114: Field114 = value; break;
                    case 115: Field115 = value; break;
                    case 116: Field116 = value; break;
                    case 117: Field117 = value; break;
                    case 118: Field118 = value; break;
                    case 119: Field119 = value; break;
                    case 120: Field120 = value; break;
                    case 121: Field121 = value; break;
                    case 122: Field122 = value; break;
                    case 123: Field123 = value; break;
                    case 124: Field124 = value; break;
                    case 125: Field125 = value; break;
                    case 126: Field126 = value; break;
                    case 127: Field127 = value; break;
                    case 128: Field128 = value; break;
                    case 129: Field129 = value; break;
                    case 130: Field130 = value; break;
                    case 131: Field131 = value; break;
                    case 132: Field132 = value; break;
                    case 133: Field133 = value; break;
                    case 134: Field134 = value; break;
                    case 135: Field135 = value; break;
                    case 136: Field136 = value; break;
                    case 137: Field137 = value; break;
                    case 138: Field138 = value; break;
                    case 139: Field139 = value; break;
                    case 140: Field140 = value; break;
                    case 141: Field141 = value; break;
                    case 142: Field142 = value; break;
                    case 143: Field143 = value; break;
                    case 144: Field144 = value; break;
                    case 145: Field145 = value; break;
                    case 146: Field146 = value; break;
                    case 147: Field147 = value; break;
                    case 148: Field148 = value; break;
                    case 149: Field149 = value; break;
                    case 150: Field150 = value; break;
                    case 151: Field151 = value; break;
                    case 152: Field152 = value; break;
                    case 153: Field153 = value; break;
                    case 154: Field154 = value; break;
                    case 155: Field155 = value; break;
                    case 156: Field156 = value; break;
                    case 157: Field157 = value; break;
                    case 158: Field158 = value; break;
                    case 159: Field159 = value; break;
                    case 160: Field160 = value; break;
                    case 161: Field161 = value; break;
                    case 162: Field162 = value; break;
                    case 163: Field163 = value; break;
                    case 164: Field164 = value; break;
                    case 165: Field165 = value; break;
                    case 166: Field166 = value; break;
                    case 167: Field167 = value; break;
                    case 168: Field168 = value; break;
                    case 169: Field169 = value; break;
                    case 170: Field170 = value; break;
                    case 171: Field171 = value; break;
                    case 172: Field172 = value; break;
                    case 173: Field173 = value; break;
                    case 174: Field174 = value; break;
                    case 175: Field175 = value; break;
                    case 176: Field176 = value; break;
                    case 177: Field177 = value; break;
                    case 178: Field178 = value; break;
                    case 179: Field179 = value; break;
                    case 180: Field180 = value; break;
                    case 181: Field181 = value; break;
                    case 182: Field182 = value; break;
                    case 183: Field183 = value; break;
                    case 184: Field184 = value; break;
                    case 185: Field185 = value; break;
                    case 186: Field186 = value; break;
                    case 187: Field187 = value; break;
                    case 188: Field188 = value; break;
                    case 189: Field189 = value; break;
                    case 190: Field190 = value; break;
                    case 191: Field191 = value; break;
                    case 192: Field192 = value; break;
                    case 193: Field193 = value; break;
                    case 194: Field194 = value; break;
                    case 195: Field195 = value; break;
                    case 196: Field196 = value; break;
                    case 197: Field197 = value; break;
                    case 198: Field198 = value; break;
                    case 199: Field199 = value; break;
                    case 200: Field200 = value; break;
                    case 201: Field201 = value; break;
                    case 202: Field202 = value; break;
                    case 203: Field203 = value; break;
                    case 204: Field204 = value; break;
                    case 205: Field205 = value; break;
                    case 206: Field206 = value; break;
                    case 207: Field207 = value; break;
                    case 208: Field208 = value; break;
                    case 209: Field209 = value; break;
                    case 210: Field210 = value; break;
                    case 211: Field211 = value; break;
                    case 212: Field212 = value; break;
                    case 213: Field213 = value; break;
                    case 214: Field214 = value; break;
                    case 215: Field215 = value; break;
                    case 216: Field216 = value; break;
                    case 217: Field217 = value; break;
                    case 218: Field218 = value; break;
                    case 219: Field219 = value; break;
                    case 220: Field220 = value; break;
                    case 221: Field221 = value; break;
                    case 222: Field222 = value; break;
                    case 223: Field223 = value; break;
                    case 224: Field224 = value; break;
                    case 225: Field225 = value; break;
                    case 226: Field226 = value; break;
                    case 227: Field227 = value; break;
                    case 228: Field228 = value; break;
                    case 229: Field229 = value; break;
                    case 230: Field230 = value; break;
                    case 231: Field231 = value; break;
                    case 232: Field232 = value; break;
                    case 233: Field233 = value; break;
                    case 234: Field234 = value; break;
                    case 235: Field235 = value; break;
                    case 236: Field236 = value; break;
                    case 237: Field237 = value; break;
                    case 238: Field238 = value; break;
                    case 239: Field239 = value; break;
                    case 240: Field240 = value; break;
                    case 241: Field241 = value; break;
                    case 242: Field242 = value; break;
                    case 243: Field243 = value; break;
                    case 244: Field244 = value; break;
                    case 245: Field245 = value; break;
                    case 246: Field246 = value; break;
                    case 247: Field247 = value; break;
                    case 248: Field248 = value; break;
                    case 249: Field249 = value; break;
                    case 250: Field250 = value; break;
                    case 251: Field251 = value; break;
                    case 252: Field252 = value; break;
                    case 253: Field253 = value; break;
                    case 254: Field254 = value; break;
                    case 255: Field255 = value; break;
                    case 256: Field256 = value; break;
                    case 257: Field257 = value; break;
                    case 258: Field258 = value; break;
                    case 259: Field259 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray260) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray260)other);

        public readonly bool Equals(in FixedLengthByteArray260 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray260 left, in FixedLengthByteArray260 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray260 left, in FixedLengthByteArray260 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
              yield return Field46;
              yield return Field47;
              yield return Field48;
              yield return Field49;
              yield return Field50;
              yield return Field51;
              yield return Field52;
              yield return Field53;
              yield return Field54;
              yield return Field55;
              yield return Field56;
              yield return Field57;
              yield return Field58;
              yield return Field59;
              yield return Field60;
              yield return Field61;
              yield return Field62;
              yield return Field63;
              yield return Field64;
              yield return Field65;
              yield return Field66;
              yield return Field67;
              yield return Field68;
              yield return Field69;
              yield return Field70;
              yield return Field71;
              yield return Field72;
              yield return Field73;
              yield return Field74;
              yield return Field75;
              yield return Field76;
              yield return Field77;
              yield return Field78;
              yield return Field79;
              yield return Field80;
              yield return Field81;
              yield return Field82;
              yield return Field83;
              yield return Field84;
              yield return Field85;
              yield return Field86;
              yield return Field87;
              yield return Field88;
              yield return Field89;
              yield return Field90;
              yield return Field91;
              yield return Field92;
              yield return Field93;
              yield return Field94;
              yield return Field95;
              yield return Field96;
              yield return Field97;
              yield return Field98;
              yield return Field99;
              yield return Field100;
              yield return Field101;
              yield return Field102;
              yield return Field103;
              yield return Field104;
              yield return Field105;
              yield return Field106;
              yield return Field107;
              yield return Field108;
              yield return Field109;
              yield return Field110;
              yield return Field111;
              yield return Field112;
              yield return Field113;
              yield return Field114;
              yield return Field115;
              yield return Field116;
              yield return Field117;
              yield return Field118;
              yield return Field119;
              yield return Field120;
              yield return Field121;
              yield return Field122;
              yield return Field123;
              yield return Field124;
              yield return Field125;
              yield return Field126;
              yield return Field127;
              yield return Field128;
              yield return Field129;
              yield return Field130;
              yield return Field131;
              yield return Field132;
              yield return Field133;
              yield return Field134;
              yield return Field135;
              yield return Field136;
              yield return Field137;
              yield return Field138;
              yield return Field139;
              yield return Field140;
              yield return Field141;
              yield return Field142;
              yield return Field143;
              yield return Field144;
              yield return Field145;
              yield return Field146;
              yield return Field147;
              yield return Field148;
              yield return Field149;
              yield return Field150;
              yield return Field151;
              yield return Field152;
              yield return Field153;
              yield return Field154;
              yield return Field155;
              yield return Field156;
              yield return Field157;
              yield return Field158;
              yield return Field159;
              yield return Field160;
              yield return Field161;
              yield return Field162;
              yield return Field163;
              yield return Field164;
              yield return Field165;
              yield return Field166;
              yield return Field167;
              yield return Field168;
              yield return Field169;
              yield return Field170;
              yield return Field171;
              yield return Field172;
              yield return Field173;
              yield return Field174;
              yield return Field175;
              yield return Field176;
              yield return Field177;
              yield return Field178;
              yield return Field179;
              yield return Field180;
              yield return Field181;
              yield return Field182;
              yield return Field183;
              yield return Field184;
              yield return Field185;
              yield return Field186;
              yield return Field187;
              yield return Field188;
              yield return Field189;
              yield return Field190;
              yield return Field191;
              yield return Field192;
              yield return Field193;
              yield return Field194;
              yield return Field195;
              yield return Field196;
              yield return Field197;
              yield return Field198;
              yield return Field199;
              yield return Field200;
              yield return Field201;
              yield return Field202;
              yield return Field203;
              yield return Field204;
              yield return Field205;
              yield return Field206;
              yield return Field207;
              yield return Field208;
              yield return Field209;
              yield return Field210;
              yield return Field211;
              yield return Field212;
              yield return Field213;
              yield return Field214;
              yield return Field215;
              yield return Field216;
              yield return Field217;
              yield return Field218;
              yield return Field219;
              yield return Field220;
              yield return Field221;
              yield return Field222;
              yield return Field223;
              yield return Field224;
              yield return Field225;
              yield return Field226;
              yield return Field227;
              yield return Field228;
              yield return Field229;
              yield return Field230;
              yield return Field231;
              yield return Field232;
              yield return Field233;
              yield return Field234;
              yield return Field235;
              yield return Field236;
              yield return Field237;
              yield return Field238;
              yield return Field239;
              yield return Field240;
              yield return Field241;
              yield return Field242;
              yield return Field243;
              yield return Field244;
              yield return Field245;
              yield return Field246;
              yield return Field247;
              yield return Field248;
              yield return Field249;
              yield return Field250;
              yield return Field251;
              yield return Field252;
              yield return Field253;
              yield return Field254;
              yield return Field255;
              yield return Field256;
              yield return Field257;
              yield return Field258;
              yield return Field259;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray260 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray260 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray260 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray260 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
                case 46: return ref array.Field46;
                case 47: return ref array.Field47;
                case 48: return ref array.Field48;
                case 49: return ref array.Field49;
                case 50: return ref array.Field50;
                case 51: return ref array.Field51;
                case 52: return ref array.Field52;
                case 53: return ref array.Field53;
                case 54: return ref array.Field54;
                case 55: return ref array.Field55;
                case 56: return ref array.Field56;
                case 57: return ref array.Field57;
                case 58: return ref array.Field58;
                case 59: return ref array.Field59;
                case 60: return ref array.Field60;
                case 61: return ref array.Field61;
                case 62: return ref array.Field62;
                case 63: return ref array.Field63;
                case 64: return ref array.Field64;
                case 65: return ref array.Field65;
                case 66: return ref array.Field66;
                case 67: return ref array.Field67;
                case 68: return ref array.Field68;
                case 69: return ref array.Field69;
                case 70: return ref array.Field70;
                case 71: return ref array.Field71;
                case 72: return ref array.Field72;
                case 73: return ref array.Field73;
                case 74: return ref array.Field74;
                case 75: return ref array.Field75;
                case 76: return ref array.Field76;
                case 77: return ref array.Field77;
                case 78: return ref array.Field78;
                case 79: return ref array.Field79;
                case 80: return ref array.Field80;
                case 81: return ref array.Field81;
                case 82: return ref array.Field82;
                case 83: return ref array.Field83;
                case 84: return ref array.Field84;
                case 85: return ref array.Field85;
                case 86: return ref array.Field86;
                case 87: return ref array.Field87;
                case 88: return ref array.Field88;
                case 89: return ref array.Field89;
                case 90: return ref array.Field90;
                case 91: return ref array.Field91;
                case 92: return ref array.Field92;
                case 93: return ref array.Field93;
                case 94: return ref array.Field94;
                case 95: return ref array.Field95;
                case 96: return ref array.Field96;
                case 97: return ref array.Field97;
                case 98: return ref array.Field98;
                case 99: return ref array.Field99;
                case 100: return ref array.Field100;
                case 101: return ref array.Field101;
                case 102: return ref array.Field102;
                case 103: return ref array.Field103;
                case 104: return ref array.Field104;
                case 105: return ref array.Field105;
                case 106: return ref array.Field106;
                case 107: return ref array.Field107;
                case 108: return ref array.Field108;
                case 109: return ref array.Field109;
                case 110: return ref array.Field110;
                case 111: return ref array.Field111;
                case 112: return ref array.Field112;
                case 113: return ref array.Field113;
                case 114: return ref array.Field114;
                case 115: return ref array.Field115;
                case 116: return ref array.Field116;
                case 117: return ref array.Field117;
                case 118: return ref array.Field118;
                case 119: return ref array.Field119;
                case 120: return ref array.Field120;
                case 121: return ref array.Field121;
                case 122: return ref array.Field122;
                case 123: return ref array.Field123;
                case 124: return ref array.Field124;
                case 125: return ref array.Field125;
                case 126: return ref array.Field126;
                case 127: return ref array.Field127;
                case 128: return ref array.Field128;
                case 129: return ref array.Field129;
                case 130: return ref array.Field130;
                case 131: return ref array.Field131;
                case 132: return ref array.Field132;
                case 133: return ref array.Field133;
                case 134: return ref array.Field134;
                case 135: return ref array.Field135;
                case 136: return ref array.Field136;
                case 137: return ref array.Field137;
                case 138: return ref array.Field138;
                case 139: return ref array.Field139;
                case 140: return ref array.Field140;
                case 141: return ref array.Field141;
                case 142: return ref array.Field142;
                case 143: return ref array.Field143;
                case 144: return ref array.Field144;
                case 145: return ref array.Field145;
                case 146: return ref array.Field146;
                case 147: return ref array.Field147;
                case 148: return ref array.Field148;
                case 149: return ref array.Field149;
                case 150: return ref array.Field150;
                case 151: return ref array.Field151;
                case 152: return ref array.Field152;
                case 153: return ref array.Field153;
                case 154: return ref array.Field154;
                case 155: return ref array.Field155;
                case 156: return ref array.Field156;
                case 157: return ref array.Field157;
                case 158: return ref array.Field158;
                case 159: return ref array.Field159;
                case 160: return ref array.Field160;
                case 161: return ref array.Field161;
                case 162: return ref array.Field162;
                case 163: return ref array.Field163;
                case 164: return ref array.Field164;
                case 165: return ref array.Field165;
                case 166: return ref array.Field166;
                case 167: return ref array.Field167;
                case 168: return ref array.Field168;
                case 169: return ref array.Field169;
                case 170: return ref array.Field170;
                case 171: return ref array.Field171;
                case 172: return ref array.Field172;
                case 173: return ref array.Field173;
                case 174: return ref array.Field174;
                case 175: return ref array.Field175;
                case 176: return ref array.Field176;
                case 177: return ref array.Field177;
                case 178: return ref array.Field178;
                case 179: return ref array.Field179;
                case 180: return ref array.Field180;
                case 181: return ref array.Field181;
                case 182: return ref array.Field182;
                case 183: return ref array.Field183;
                case 184: return ref array.Field184;
                case 185: return ref array.Field185;
                case 186: return ref array.Field186;
                case 187: return ref array.Field187;
                case 188: return ref array.Field188;
                case 189: return ref array.Field189;
                case 190: return ref array.Field190;
                case 191: return ref array.Field191;
                case 192: return ref array.Field192;
                case 193: return ref array.Field193;
                case 194: return ref array.Field194;
                case 195: return ref array.Field195;
                case 196: return ref array.Field196;
                case 197: return ref array.Field197;
                case 198: return ref array.Field198;
                case 199: return ref array.Field199;
                case 200: return ref array.Field200;
                case 201: return ref array.Field201;
                case 202: return ref array.Field202;
                case 203: return ref array.Field203;
                case 204: return ref array.Field204;
                case 205: return ref array.Field205;
                case 206: return ref array.Field206;
                case 207: return ref array.Field207;
                case 208: return ref array.Field208;
                case 209: return ref array.Field209;
                case 210: return ref array.Field210;
                case 211: return ref array.Field211;
                case 212: return ref array.Field212;
                case 213: return ref array.Field213;
                case 214: return ref array.Field214;
                case 215: return ref array.Field215;
                case 216: return ref array.Field216;
                case 217: return ref array.Field217;
                case 218: return ref array.Field218;
                case 219: return ref array.Field219;
                case 220: return ref array.Field220;
                case 221: return ref array.Field221;
                case 222: return ref array.Field222;
                case 223: return ref array.Field223;
                case 224: return ref array.Field224;
                case 225: return ref array.Field225;
                case 226: return ref array.Field226;
                case 227: return ref array.Field227;
                case 228: return ref array.Field228;
                case 229: return ref array.Field229;
                case 230: return ref array.Field230;
                case 231: return ref array.Field231;
                case 232: return ref array.Field232;
                case 233: return ref array.Field233;
                case 234: return ref array.Field234;
                case 235: return ref array.Field235;
                case 236: return ref array.Field236;
                case 237: return ref array.Field237;
                case 238: return ref array.Field238;
                case 239: return ref array.Field239;
                case 240: return ref array.Field240;
                case 241: return ref array.Field241;
                case 242: return ref array.Field242;
                case 243: return ref array.Field243;
                case 244: return ref array.Field244;
                case 245: return ref array.Field245;
                case 246: return ref array.Field246;
                case 247: return ref array.Field247;
                case 248: return ref array.Field248;
                case 249: return ref array.Field249;
                case 250: return ref array.Field250;
                case 251: return ref array.Field251;
                case 252: return ref array.Field252;
                case 253: return ref array.Field253;
                case 254: return ref array.Field254;
                case 255: return ref array.Field255;
                case 256: return ref array.Field256;
                case 257: return ref array.Field257;
                case 258: return ref array.Field258;
                case 259: return ref array.Field259;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray260 array1, in FixedLengthByteArray260 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray260 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray260 array1, in FixedLengthByteArray260 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray260 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray260 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray260 array1, in FixedLengthByteArray260 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray260 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray260 array1, in FixedLengthByteArray260 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray260 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 384 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray384
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray384 _Zero = default;
		public static ref readonly FixedLengthByteArray384 Zero => ref _Zero;

		public const int ConstLength = 384;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray384(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
			, Byte field25
			, Byte field26
			, Byte field27
			, Byte field28
			, Byte field29
			, Byte field30
			, Byte field31
			, Byte field32
			, Byte field33
			, Byte field34
			, Byte field35
			, Byte field36
			, Byte field37
			, Byte field38
			, Byte field39
			, Byte field40
			, Byte field41
			, Byte field42
			, Byte field43
			, Byte field44
			, Byte field45
			, Byte field46
			, Byte field47
			, Byte field48
			, Byte field49
			, Byte field50
			, Byte field51
			, Byte field52
			, Byte field53
			, Byte field54
			, Byte field55
			, Byte field56
			, Byte field57
			, Byte field58
			, Byte field59
			, Byte field60
			, Byte field61
			, Byte field62
			, Byte field63
			, Byte field64
			, Byte field65
			, Byte field66
			, Byte field67
			, Byte field68
			, Byte field69
			, Byte field70
			, Byte field71
			, Byte field72
			, Byte field73
			, Byte field74
			, Byte field75
			, Byte field76
			, Byte field77
			, Byte field78
			, Byte field79
			, Byte field80
			, Byte field81
			, Byte field82
			, Byte field83
			, Byte field84
			, Byte field85
			, Byte field86
			, Byte field87
			, Byte field88
			, Byte field89
			, Byte field90
			, Byte field91
			, Byte field92
			, Byte field93
			, Byte field94
			, Byte field95
			, Byte field96
			, Byte field97
			, Byte field98
			, Byte field99
			, Byte field100
			, Byte field101
			, Byte field102
			, Byte field103
			, Byte field104
			, Byte field105
			, Byte field106
			, Byte field107
			, Byte field108
			, Byte field109
			, Byte field110
			, Byte field111
			, Byte field112
			, Byte field113
			, Byte field114
			, Byte field115
			, Byte field116
			, Byte field117
			, Byte field118
			, Byte field119
			, Byte field120
			, Byte field121
			, Byte field122
			, Byte field123
			, Byte field124
			, Byte field125
			, Byte field126
			, Byte field127
			, Byte field128
			, Byte field129
			, Byte field130
			, Byte field131
			, Byte field132
			, Byte field133
			, Byte field134
			, Byte field135
			, Byte field136
			, Byte field137
			, Byte field138
			, Byte field139
			, Byte field140
			, Byte field141
			, Byte field142
			, Byte field143
			, Byte field144
			, Byte field145
			, Byte field146
			, Byte field147
			, Byte field148
			, Byte field149
			, Byte field150
			, Byte field151
			, Byte field152
			, Byte field153
			, Byte field154
			, Byte field155
			, Byte field156
			, Byte field157
			, Byte field158
			, Byte field159
			, Byte field160
			, Byte field161
			, Byte field162
			, Byte field163
			, Byte field164
			, Byte field165
			, Byte field166
			, Byte field167
			, Byte field168
			, Byte field169
			, Byte field170
			, Byte field171
			, Byte field172
			, Byte field173
			, Byte field174
			, Byte field175
			, Byte field176
			, Byte field177
			, Byte field178
			, Byte field179
			, Byte field180
			, Byte field181
			, Byte field182
			, Byte field183
			, Byte field184
			, Byte field185
			, Byte field186
			, Byte field187
			, Byte field188
			, Byte field189
			, Byte field190
			, Byte field191
			, Byte field192
			, Byte field193
			, Byte field194
			, Byte field195
			, Byte field196
			, Byte field197
			, Byte field198
			, Byte field199
			, Byte field200
			, Byte field201
			, Byte field202
			, Byte field203
			, Byte field204
			, Byte field205
			, Byte field206
			, Byte field207
			, Byte field208
			, Byte field209
			, Byte field210
			, Byte field211
			, Byte field212
			, Byte field213
			, Byte field214
			, Byte field215
			, Byte field216
			, Byte field217
			, Byte field218
			, Byte field219
			, Byte field220
			, Byte field221
			, Byte field222
			, Byte field223
			, Byte field224
			, Byte field225
			, Byte field226
			, Byte field227
			, Byte field228
			, Byte field229
			, Byte field230
			, Byte field231
			, Byte field232
			, Byte field233
			, Byte field234
			, Byte field235
			, Byte field236
			, Byte field237
			, Byte field238
			, Byte field239
			, Byte field240
			, Byte field241
			, Byte field242
			, Byte field243
			, Byte field244
			, Byte field245
			, Byte field246
			, Byte field247
			, Byte field248
			, Byte field249
			, Byte field250
			, Byte field251
			, Byte field252
			, Byte field253
			, Byte field254
			, Byte field255
			, Byte field256
			, Byte field257
			, Byte field258
			, Byte field259
			, Byte field260
			, Byte field261
			, Byte field262
			, Byte field263
			, Byte field264
			, Byte field265
			, Byte field266
			, Byte field267
			, Byte field268
			, Byte field269
			, Byte field270
			, Byte field271
			, Byte field272
			, Byte field273
			, Byte field274
			, Byte field275
			, Byte field276
			, Byte field277
			, Byte field278
			, Byte field279
			, Byte field280
			, Byte field281
			, Byte field282
			, Byte field283
			, Byte field284
			, Byte field285
			, Byte field286
			, Byte field287
			, Byte field288
			, Byte field289
			, Byte field290
			, Byte field291
			, Byte field292
			, Byte field293
			, Byte field294
			, Byte field295
			, Byte field296
			, Byte field297
			, Byte field298
			, Byte field299
			, Byte field300
			, Byte field301
			, Byte field302
			, Byte field303
			, Byte field304
			, Byte field305
			, Byte field306
			, Byte field307
			, Byte field308
			, Byte field309
			, Byte field310
			, Byte field311
			, Byte field312
			, Byte field313
			, Byte field314
			, Byte field315
			, Byte field316
			, Byte field317
			, Byte field318
			, Byte field319
			, Byte field320
			, Byte field321
			, Byte field322
			, Byte field323
			, Byte field324
			, Byte field325
			, Byte field326
			, Byte field327
			, Byte field328
			, Byte field329
			, Byte field330
			, Byte field331
			, Byte field332
			, Byte field333
			, Byte field334
			, Byte field335
			, Byte field336
			, Byte field337
			, Byte field338
			, Byte field339
			, Byte field340
			, Byte field341
			, Byte field342
			, Byte field343
			, Byte field344
			, Byte field345
			, Byte field346
			, Byte field347
			, Byte field348
			, Byte field349
			, Byte field350
			, Byte field351
			, Byte field352
			, Byte field353
			, Byte field354
			, Byte field355
			, Byte field356
			, Byte field357
			, Byte field358
			, Byte field359
			, Byte field360
			, Byte field361
			, Byte field362
			, Byte field363
			, Byte field364
			, Byte field365
			, Byte field366
			, Byte field367
			, Byte field368
			, Byte field369
			, Byte field370
			, Byte field371
			, Byte field372
			, Byte field373
			, Byte field374
			, Byte field375
			, Byte field376
			, Byte field377
			, Byte field378
			, Byte field379
			, Byte field380
			, Byte field381
			, Byte field382
			, Byte field383
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
			Field46 = field46;
			Field47 = field47;
			Field48 = field48;
			Field49 = field49;
			Field50 = field50;
			Field51 = field51;
			Field52 = field52;
			Field53 = field53;
			Field54 = field54;
			Field55 = field55;
			Field56 = field56;
			Field57 = field57;
			Field58 = field58;
			Field59 = field59;
			Field60 = field60;
			Field61 = field61;
			Field62 = field62;
			Field63 = field63;
			Field64 = field64;
			Field65 = field65;
			Field66 = field66;
			Field67 = field67;
			Field68 = field68;
			Field69 = field69;
			Field70 = field70;
			Field71 = field71;
			Field72 = field72;
			Field73 = field73;
			Field74 = field74;
			Field75 = field75;
			Field76 = field76;
			Field77 = field77;
			Field78 = field78;
			Field79 = field79;
			Field80 = field80;
			Field81 = field81;
			Field82 = field82;
			Field83 = field83;
			Field84 = field84;
			Field85 = field85;
			Field86 = field86;
			Field87 = field87;
			Field88 = field88;
			Field89 = field89;
			Field90 = field90;
			Field91 = field91;
			Field92 = field92;
			Field93 = field93;
			Field94 = field94;
			Field95 = field95;
			Field96 = field96;
			Field97 = field97;
			Field98 = field98;
			Field99 = field99;
			Field100 = field100;
			Field101 = field101;
			Field102 = field102;
			Field103 = field103;
			Field104 = field104;
			Field105 = field105;
			Field106 = field106;
			Field107 = field107;
			Field108 = field108;
			Field109 = field109;
			Field110 = field110;
			Field111 = field111;
			Field112 = field112;
			Field113 = field113;
			Field114 = field114;
			Field115 = field115;
			Field116 = field116;
			Field117 = field117;
			Field118 = field118;
			Field119 = field119;
			Field120 = field120;
			Field121 = field121;
			Field122 = field122;
			Field123 = field123;
			Field124 = field124;
			Field125 = field125;
			Field126 = field126;
			Field127 = field127;
			Field128 = field128;
			Field129 = field129;
			Field130 = field130;
			Field131 = field131;
			Field132 = field132;
			Field133 = field133;
			Field134 = field134;
			Field135 = field135;
			Field136 = field136;
			Field137 = field137;
			Field138 = field138;
			Field139 = field139;
			Field140 = field140;
			Field141 = field141;
			Field142 = field142;
			Field143 = field143;
			Field144 = field144;
			Field145 = field145;
			Field146 = field146;
			Field147 = field147;
			Field148 = field148;
			Field149 = field149;
			Field150 = field150;
			Field151 = field151;
			Field152 = field152;
			Field153 = field153;
			Field154 = field154;
			Field155 = field155;
			Field156 = field156;
			Field157 = field157;
			Field158 = field158;
			Field159 = field159;
			Field160 = field160;
			Field161 = field161;
			Field162 = field162;
			Field163 = field163;
			Field164 = field164;
			Field165 = field165;
			Field166 = field166;
			Field167 = field167;
			Field168 = field168;
			Field169 = field169;
			Field170 = field170;
			Field171 = field171;
			Field172 = field172;
			Field173 = field173;
			Field174 = field174;
			Field175 = field175;
			Field176 = field176;
			Field177 = field177;
			Field178 = field178;
			Field179 = field179;
			Field180 = field180;
			Field181 = field181;
			Field182 = field182;
			Field183 = field183;
			Field184 = field184;
			Field185 = field185;
			Field186 = field186;
			Field187 = field187;
			Field188 = field188;
			Field189 = field189;
			Field190 = field190;
			Field191 = field191;
			Field192 = field192;
			Field193 = field193;
			Field194 = field194;
			Field195 = field195;
			Field196 = field196;
			Field197 = field197;
			Field198 = field198;
			Field199 = field199;
			Field200 = field200;
			Field201 = field201;
			Field202 = field202;
			Field203 = field203;
			Field204 = field204;
			Field205 = field205;
			Field206 = field206;
			Field207 = field207;
			Field208 = field208;
			Field209 = field209;
			Field210 = field210;
			Field211 = field211;
			Field212 = field212;
			Field213 = field213;
			Field214 = field214;
			Field215 = field215;
			Field216 = field216;
			Field217 = field217;
			Field218 = field218;
			Field219 = field219;
			Field220 = field220;
			Field221 = field221;
			Field222 = field222;
			Field223 = field223;
			Field224 = field224;
			Field225 = field225;
			Field226 = field226;
			Field227 = field227;
			Field228 = field228;
			Field229 = field229;
			Field230 = field230;
			Field231 = field231;
			Field232 = field232;
			Field233 = field233;
			Field234 = field234;
			Field235 = field235;
			Field236 = field236;
			Field237 = field237;
			Field238 = field238;
			Field239 = field239;
			Field240 = field240;
			Field241 = field241;
			Field242 = field242;
			Field243 = field243;
			Field244 = field244;
			Field245 = field245;
			Field246 = field246;
			Field247 = field247;
			Field248 = field248;
			Field249 = field249;
			Field250 = field250;
			Field251 = field251;
			Field252 = field252;
			Field253 = field253;
			Field254 = field254;
			Field255 = field255;
			Field256 = field256;
			Field257 = field257;
			Field258 = field258;
			Field259 = field259;
			Field260 = field260;
			Field261 = field261;
			Field262 = field262;
			Field263 = field263;
			Field264 = field264;
			Field265 = field265;
			Field266 = field266;
			Field267 = field267;
			Field268 = field268;
			Field269 = field269;
			Field270 = field270;
			Field271 = field271;
			Field272 = field272;
			Field273 = field273;
			Field274 = field274;
			Field275 = field275;
			Field276 = field276;
			Field277 = field277;
			Field278 = field278;
			Field279 = field279;
			Field280 = field280;
			Field281 = field281;
			Field282 = field282;
			Field283 = field283;
			Field284 = field284;
			Field285 = field285;
			Field286 = field286;
			Field287 = field287;
			Field288 = field288;
			Field289 = field289;
			Field290 = field290;
			Field291 = field291;
			Field292 = field292;
			Field293 = field293;
			Field294 = field294;
			Field295 = field295;
			Field296 = field296;
			Field297 = field297;
			Field298 = field298;
			Field299 = field299;
			Field300 = field300;
			Field301 = field301;
			Field302 = field302;
			Field303 = field303;
			Field304 = field304;
			Field305 = field305;
			Field306 = field306;
			Field307 = field307;
			Field308 = field308;
			Field309 = field309;
			Field310 = field310;
			Field311 = field311;
			Field312 = field312;
			Field313 = field313;
			Field314 = field314;
			Field315 = field315;
			Field316 = field316;
			Field317 = field317;
			Field318 = field318;
			Field319 = field319;
			Field320 = field320;
			Field321 = field321;
			Field322 = field322;
			Field323 = field323;
			Field324 = field324;
			Field325 = field325;
			Field326 = field326;
			Field327 = field327;
			Field328 = field328;
			Field329 = field329;
			Field330 = field330;
			Field331 = field331;
			Field332 = field332;
			Field333 = field333;
			Field334 = field334;
			Field335 = field335;
			Field336 = field336;
			Field337 = field337;
			Field338 = field338;
			Field339 = field339;
			Field340 = field340;
			Field341 = field341;
			Field342 = field342;
			Field343 = field343;
			Field344 = field344;
			Field345 = field345;
			Field346 = field346;
			Field347 = field347;
			Field348 = field348;
			Field349 = field349;
			Field350 = field350;
			Field351 = field351;
			Field352 = field352;
			Field353 = field353;
			Field354 = field354;
			Field355 = field355;
			Field356 = field356;
			Field357 = field357;
			Field358 = field358;
			Field359 = field359;
			Field360 = field360;
			Field361 = field361;
			Field362 = field362;
			Field363 = field363;
			Field364 = field364;
			Field365 = field365;
			Field366 = field366;
			Field367 = field367;
			Field368 = field368;
			Field369 = field369;
			Field370 = field370;
			Field371 = field371;
			Field372 = field372;
			Field373 = field373;
			Field374 = field374;
			Field375 = field375;
			Field376 = field376;
			Field377 = field377;
			Field378 = field378;
			Field379 = field379;
			Field380 = field380;
			Field381 = field381;
			Field382 = field382;
			Field383 = field383;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
		public Byte Field25;
		public Byte Field26;
		public Byte Field27;
		public Byte Field28;
		public Byte Field29;
		public Byte Field30;
		public Byte Field31;
		public Byte Field32;
		public Byte Field33;
		public Byte Field34;
		public Byte Field35;
		public Byte Field36;
		public Byte Field37;
		public Byte Field38;
		public Byte Field39;
		public Byte Field40;
		public Byte Field41;
		public Byte Field42;
		public Byte Field43;
		public Byte Field44;
		public Byte Field45;
		public Byte Field46;
		public Byte Field47;
		public Byte Field48;
		public Byte Field49;
		public Byte Field50;
		public Byte Field51;
		public Byte Field52;
		public Byte Field53;
		public Byte Field54;
		public Byte Field55;
		public Byte Field56;
		public Byte Field57;
		public Byte Field58;
		public Byte Field59;
		public Byte Field60;
		public Byte Field61;
		public Byte Field62;
		public Byte Field63;
		public Byte Field64;
		public Byte Field65;
		public Byte Field66;
		public Byte Field67;
		public Byte Field68;
		public Byte Field69;
		public Byte Field70;
		public Byte Field71;
		public Byte Field72;
		public Byte Field73;
		public Byte Field74;
		public Byte Field75;
		public Byte Field76;
		public Byte Field77;
		public Byte Field78;
		public Byte Field79;
		public Byte Field80;
		public Byte Field81;
		public Byte Field82;
		public Byte Field83;
		public Byte Field84;
		public Byte Field85;
		public Byte Field86;
		public Byte Field87;
		public Byte Field88;
		public Byte Field89;
		public Byte Field90;
		public Byte Field91;
		public Byte Field92;
		public Byte Field93;
		public Byte Field94;
		public Byte Field95;
		public Byte Field96;
		public Byte Field97;
		public Byte Field98;
		public Byte Field99;
		public Byte Field100;
		public Byte Field101;
		public Byte Field102;
		public Byte Field103;
		public Byte Field104;
		public Byte Field105;
		public Byte Field106;
		public Byte Field107;
		public Byte Field108;
		public Byte Field109;
		public Byte Field110;
		public Byte Field111;
		public Byte Field112;
		public Byte Field113;
		public Byte Field114;
		public Byte Field115;
		public Byte Field116;
		public Byte Field117;
		public Byte Field118;
		public Byte Field119;
		public Byte Field120;
		public Byte Field121;
		public Byte Field122;
		public Byte Field123;
		public Byte Field124;
		public Byte Field125;
		public Byte Field126;
		public Byte Field127;
		public Byte Field128;
		public Byte Field129;
		public Byte Field130;
		public Byte Field131;
		public Byte Field132;
		public Byte Field133;
		public Byte Field134;
		public Byte Field135;
		public Byte Field136;
		public Byte Field137;
		public Byte Field138;
		public Byte Field139;
		public Byte Field140;
		public Byte Field141;
		public Byte Field142;
		public Byte Field143;
		public Byte Field144;
		public Byte Field145;
		public Byte Field146;
		public Byte Field147;
		public Byte Field148;
		public Byte Field149;
		public Byte Field150;
		public Byte Field151;
		public Byte Field152;
		public Byte Field153;
		public Byte Field154;
		public Byte Field155;
		public Byte Field156;
		public Byte Field157;
		public Byte Field158;
		public Byte Field159;
		public Byte Field160;
		public Byte Field161;
		public Byte Field162;
		public Byte Field163;
		public Byte Field164;
		public Byte Field165;
		public Byte Field166;
		public Byte Field167;
		public Byte Field168;
		public Byte Field169;
		public Byte Field170;
		public Byte Field171;
		public Byte Field172;
		public Byte Field173;
		public Byte Field174;
		public Byte Field175;
		public Byte Field176;
		public Byte Field177;
		public Byte Field178;
		public Byte Field179;
		public Byte Field180;
		public Byte Field181;
		public Byte Field182;
		public Byte Field183;
		public Byte Field184;
		public Byte Field185;
		public Byte Field186;
		public Byte Field187;
		public Byte Field188;
		public Byte Field189;
		public Byte Field190;
		public Byte Field191;
		public Byte Field192;
		public Byte Field193;
		public Byte Field194;
		public Byte Field195;
		public Byte Field196;
		public Byte Field197;
		public Byte Field198;
		public Byte Field199;
		public Byte Field200;
		public Byte Field201;
		public Byte Field202;
		public Byte Field203;
		public Byte Field204;
		public Byte Field205;
		public Byte Field206;
		public Byte Field207;
		public Byte Field208;
		public Byte Field209;
		public Byte Field210;
		public Byte Field211;
		public Byte Field212;
		public Byte Field213;
		public Byte Field214;
		public Byte Field215;
		public Byte Field216;
		public Byte Field217;
		public Byte Field218;
		public Byte Field219;
		public Byte Field220;
		public Byte Field221;
		public Byte Field222;
		public Byte Field223;
		public Byte Field224;
		public Byte Field225;
		public Byte Field226;
		public Byte Field227;
		public Byte Field228;
		public Byte Field229;
		public Byte Field230;
		public Byte Field231;
		public Byte Field232;
		public Byte Field233;
		public Byte Field234;
		public Byte Field235;
		public Byte Field236;
		public Byte Field237;
		public Byte Field238;
		public Byte Field239;
		public Byte Field240;
		public Byte Field241;
		public Byte Field242;
		public Byte Field243;
		public Byte Field244;
		public Byte Field245;
		public Byte Field246;
		public Byte Field247;
		public Byte Field248;
		public Byte Field249;
		public Byte Field250;
		public Byte Field251;
		public Byte Field252;
		public Byte Field253;
		public Byte Field254;
		public Byte Field255;
		public Byte Field256;
		public Byte Field257;
		public Byte Field258;
		public Byte Field259;
		public Byte Field260;
		public Byte Field261;
		public Byte Field262;
		public Byte Field263;
		public Byte Field264;
		public Byte Field265;
		public Byte Field266;
		public Byte Field267;
		public Byte Field268;
		public Byte Field269;
		public Byte Field270;
		public Byte Field271;
		public Byte Field272;
		public Byte Field273;
		public Byte Field274;
		public Byte Field275;
		public Byte Field276;
		public Byte Field277;
		public Byte Field278;
		public Byte Field279;
		public Byte Field280;
		public Byte Field281;
		public Byte Field282;
		public Byte Field283;
		public Byte Field284;
		public Byte Field285;
		public Byte Field286;
		public Byte Field287;
		public Byte Field288;
		public Byte Field289;
		public Byte Field290;
		public Byte Field291;
		public Byte Field292;
		public Byte Field293;
		public Byte Field294;
		public Byte Field295;
		public Byte Field296;
		public Byte Field297;
		public Byte Field298;
		public Byte Field299;
		public Byte Field300;
		public Byte Field301;
		public Byte Field302;
		public Byte Field303;
		public Byte Field304;
		public Byte Field305;
		public Byte Field306;
		public Byte Field307;
		public Byte Field308;
		public Byte Field309;
		public Byte Field310;
		public Byte Field311;
		public Byte Field312;
		public Byte Field313;
		public Byte Field314;
		public Byte Field315;
		public Byte Field316;
		public Byte Field317;
		public Byte Field318;
		public Byte Field319;
		public Byte Field320;
		public Byte Field321;
		public Byte Field322;
		public Byte Field323;
		public Byte Field324;
		public Byte Field325;
		public Byte Field326;
		public Byte Field327;
		public Byte Field328;
		public Byte Field329;
		public Byte Field330;
		public Byte Field331;
		public Byte Field332;
		public Byte Field333;
		public Byte Field334;
		public Byte Field335;
		public Byte Field336;
		public Byte Field337;
		public Byte Field338;
		public Byte Field339;
		public Byte Field340;
		public Byte Field341;
		public Byte Field342;
		public Byte Field343;
		public Byte Field344;
		public Byte Field345;
		public Byte Field346;
		public Byte Field347;
		public Byte Field348;
		public Byte Field349;
		public Byte Field350;
		public Byte Field351;
		public Byte Field352;
		public Byte Field353;
		public Byte Field354;
		public Byte Field355;
		public Byte Field356;
		public Byte Field357;
		public Byte Field358;
		public Byte Field359;
		public Byte Field360;
		public Byte Field361;
		public Byte Field362;
		public Byte Field363;
		public Byte Field364;
		public Byte Field365;
		public Byte Field366;
		public Byte Field367;
		public Byte Field368;
		public Byte Field369;
		public Byte Field370;
		public Byte Field371;
		public Byte Field372;
		public Byte Field373;
		public Byte Field374;
		public Byte Field375;
		public Byte Field376;
		public Byte Field377;
		public Byte Field378;
		public Byte Field379;
		public Byte Field380;
		public Byte Field381;
		public Byte Field382;
		public Byte Field383;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                46 => Field46,
                47 => Field47,
                48 => Field48,
                49 => Field49,
                50 => Field50,
                51 => Field51,
                52 => Field52,
                53 => Field53,
                54 => Field54,
                55 => Field55,
                56 => Field56,
                57 => Field57,
                58 => Field58,
                59 => Field59,
                60 => Field60,
                61 => Field61,
                62 => Field62,
                63 => Field63,
                64 => Field64,
                65 => Field65,
                66 => Field66,
                67 => Field67,
                68 => Field68,
                69 => Field69,
                70 => Field70,
                71 => Field71,
                72 => Field72,
                73 => Field73,
                74 => Field74,
                75 => Field75,
                76 => Field76,
                77 => Field77,
                78 => Field78,
                79 => Field79,
                80 => Field80,
                81 => Field81,
                82 => Field82,
                83 => Field83,
                84 => Field84,
                85 => Field85,
                86 => Field86,
                87 => Field87,
                88 => Field88,
                89 => Field89,
                90 => Field90,
                91 => Field91,
                92 => Field92,
                93 => Field93,
                94 => Field94,
                95 => Field95,
                96 => Field96,
                97 => Field97,
                98 => Field98,
                99 => Field99,
                100 => Field100,
                101 => Field101,
                102 => Field102,
                103 => Field103,
                104 => Field104,
                105 => Field105,
                106 => Field106,
                107 => Field107,
                108 => Field108,
                109 => Field109,
                110 => Field110,
                111 => Field111,
                112 => Field112,
                113 => Field113,
                114 => Field114,
                115 => Field115,
                116 => Field116,
                117 => Field117,
                118 => Field118,
                119 => Field119,
                120 => Field120,
                121 => Field121,
                122 => Field122,
                123 => Field123,
                124 => Field124,
                125 => Field125,
                126 => Field126,
                127 => Field127,
                128 => Field128,
                129 => Field129,
                130 => Field130,
                131 => Field131,
                132 => Field132,
                133 => Field133,
                134 => Field134,
                135 => Field135,
                136 => Field136,
                137 => Field137,
                138 => Field138,
                139 => Field139,
                140 => Field140,
                141 => Field141,
                142 => Field142,
                143 => Field143,
                144 => Field144,
                145 => Field145,
                146 => Field146,
                147 => Field147,
                148 => Field148,
                149 => Field149,
                150 => Field150,
                151 => Field151,
                152 => Field152,
                153 => Field153,
                154 => Field154,
                155 => Field155,
                156 => Field156,
                157 => Field157,
                158 => Field158,
                159 => Field159,
                160 => Field160,
                161 => Field161,
                162 => Field162,
                163 => Field163,
                164 => Field164,
                165 => Field165,
                166 => Field166,
                167 => Field167,
                168 => Field168,
                169 => Field169,
                170 => Field170,
                171 => Field171,
                172 => Field172,
                173 => Field173,
                174 => Field174,
                175 => Field175,
                176 => Field176,
                177 => Field177,
                178 => Field178,
                179 => Field179,
                180 => Field180,
                181 => Field181,
                182 => Field182,
                183 => Field183,
                184 => Field184,
                185 => Field185,
                186 => Field186,
                187 => Field187,
                188 => Field188,
                189 => Field189,
                190 => Field190,
                191 => Field191,
                192 => Field192,
                193 => Field193,
                194 => Field194,
                195 => Field195,
                196 => Field196,
                197 => Field197,
                198 => Field198,
                199 => Field199,
                200 => Field200,
                201 => Field201,
                202 => Field202,
                203 => Field203,
                204 => Field204,
                205 => Field205,
                206 => Field206,
                207 => Field207,
                208 => Field208,
                209 => Field209,
                210 => Field210,
                211 => Field211,
                212 => Field212,
                213 => Field213,
                214 => Field214,
                215 => Field215,
                216 => Field216,
                217 => Field217,
                218 => Field218,
                219 => Field219,
                220 => Field220,
                221 => Field221,
                222 => Field222,
                223 => Field223,
                224 => Field224,
                225 => Field225,
                226 => Field226,
                227 => Field227,
                228 => Field228,
                229 => Field229,
                230 => Field230,
                231 => Field231,
                232 => Field232,
                233 => Field233,
                234 => Field234,
                235 => Field235,
                236 => Field236,
                237 => Field237,
                238 => Field238,
                239 => Field239,
                240 => Field240,
                241 => Field241,
                242 => Field242,
                243 => Field243,
                244 => Field244,
                245 => Field245,
                246 => Field246,
                247 => Field247,
                248 => Field248,
                249 => Field249,
                250 => Field250,
                251 => Field251,
                252 => Field252,
                253 => Field253,
                254 => Field254,
                255 => Field255,
                256 => Field256,
                257 => Field257,
                258 => Field258,
                259 => Field259,
                260 => Field260,
                261 => Field261,
                262 => Field262,
                263 => Field263,
                264 => Field264,
                265 => Field265,
                266 => Field266,
                267 => Field267,
                268 => Field268,
                269 => Field269,
                270 => Field270,
                271 => Field271,
                272 => Field272,
                273 => Field273,
                274 => Field274,
                275 => Field275,
                276 => Field276,
                277 => Field277,
                278 => Field278,
                279 => Field279,
                280 => Field280,
                281 => Field281,
                282 => Field282,
                283 => Field283,
                284 => Field284,
                285 => Field285,
                286 => Field286,
                287 => Field287,
                288 => Field288,
                289 => Field289,
                290 => Field290,
                291 => Field291,
                292 => Field292,
                293 => Field293,
                294 => Field294,
                295 => Field295,
                296 => Field296,
                297 => Field297,
                298 => Field298,
                299 => Field299,
                300 => Field300,
                301 => Field301,
                302 => Field302,
                303 => Field303,
                304 => Field304,
                305 => Field305,
                306 => Field306,
                307 => Field307,
                308 => Field308,
                309 => Field309,
                310 => Field310,
                311 => Field311,
                312 => Field312,
                313 => Field313,
                314 => Field314,
                315 => Field315,
                316 => Field316,
                317 => Field317,
                318 => Field318,
                319 => Field319,
                320 => Field320,
                321 => Field321,
                322 => Field322,
                323 => Field323,
                324 => Field324,
                325 => Field325,
                326 => Field326,
                327 => Field327,
                328 => Field328,
                329 => Field329,
                330 => Field330,
                331 => Field331,
                332 => Field332,
                333 => Field333,
                334 => Field334,
                335 => Field335,
                336 => Field336,
                337 => Field337,
                338 => Field338,
                339 => Field339,
                340 => Field340,
                341 => Field341,
                342 => Field342,
                343 => Field343,
                344 => Field344,
                345 => Field345,
                346 => Field346,
                347 => Field347,
                348 => Field348,
                349 => Field349,
                350 => Field350,
                351 => Field351,
                352 => Field352,
                353 => Field353,
                354 => Field354,
                355 => Field355,
                356 => Field356,
                357 => Field357,
                358 => Field358,
                359 => Field359,
                360 => Field360,
                361 => Field361,
                362 => Field362,
                363 => Field363,
                364 => Field364,
                365 => Field365,
                366 => Field366,
                367 => Field367,
                368 => Field368,
                369 => Field369,
                370 => Field370,
                371 => Field371,
                372 => Field372,
                373 => Field373,
                374 => Field374,
                375 => Field375,
                376 => Field376,
                377 => Field377,
                378 => Field378,
                379 => Field379,
                380 => Field380,
                381 => Field381,
                382 => Field382,
                383 => Field383,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
                    case 46: Field46 = value; break;
                    case 47: Field47 = value; break;
                    case 48: Field48 = value; break;
                    case 49: Field49 = value; break;
                    case 50: Field50 = value; break;
                    case 51: Field51 = value; break;
                    case 52: Field52 = value; break;
                    case 53: Field53 = value; break;
                    case 54: Field54 = value; break;
                    case 55: Field55 = value; break;
                    case 56: Field56 = value; break;
                    case 57: Field57 = value; break;
                    case 58: Field58 = value; break;
                    case 59: Field59 = value; break;
                    case 60: Field60 = value; break;
                    case 61: Field61 = value; break;
                    case 62: Field62 = value; break;
                    case 63: Field63 = value; break;
                    case 64: Field64 = value; break;
                    case 65: Field65 = value; break;
                    case 66: Field66 = value; break;
                    case 67: Field67 = value; break;
                    case 68: Field68 = value; break;
                    case 69: Field69 = value; break;
                    case 70: Field70 = value; break;
                    case 71: Field71 = value; break;
                    case 72: Field72 = value; break;
                    case 73: Field73 = value; break;
                    case 74: Field74 = value; break;
                    case 75: Field75 = value; break;
                    case 76: Field76 = value; break;
                    case 77: Field77 = value; break;
                    case 78: Field78 = value; break;
                    case 79: Field79 = value; break;
                    case 80: Field80 = value; break;
                    case 81: Field81 = value; break;
                    case 82: Field82 = value; break;
                    case 83: Field83 = value; break;
                    case 84: Field84 = value; break;
                    case 85: Field85 = value; break;
                    case 86: Field86 = value; break;
                    case 87: Field87 = value; break;
                    case 88: Field88 = value; break;
                    case 89: Field89 = value; break;
                    case 90: Field90 = value; break;
                    case 91: Field91 = value; break;
                    case 92: Field92 = value; break;
                    case 93: Field93 = value; break;
                    case 94: Field94 = value; break;
                    case 95: Field95 = value; break;
                    case 96: Field96 = value; break;
                    case 97: Field97 = value; break;
                    case 98: Field98 = value; break;
                    case 99: Field99 = value; break;
                    case 100: Field100 = value; break;
                    case 101: Field101 = value; break;
                    case 102: Field102 = value; break;
                    case 103: Field103 = value; break;
                    case 104: Field104 = value; break;
                    case 105: Field105 = value; break;
                    case 106: Field106 = value; break;
                    case 107: Field107 = value; break;
                    case 108: Field108 = value; break;
                    case 109: Field109 = value; break;
                    case 110: Field110 = value; break;
                    case 111: Field111 = value; break;
                    case 112: Field112 = value; break;
                    case 113: Field113 = value; break;
                    case 114: Field114 = value; break;
                    case 115: Field115 = value; break;
                    case 116: Field116 = value; break;
                    case 117: Field117 = value; break;
                    case 118: Field118 = value; break;
                    case 119: Field119 = value; break;
                    case 120: Field120 = value; break;
                    case 121: Field121 = value; break;
                    case 122: Field122 = value; break;
                    case 123: Field123 = value; break;
                    case 124: Field124 = value; break;
                    case 125: Field125 = value; break;
                    case 126: Field126 = value; break;
                    case 127: Field127 = value; break;
                    case 128: Field128 = value; break;
                    case 129: Field129 = value; break;
                    case 130: Field130 = value; break;
                    case 131: Field131 = value; break;
                    case 132: Field132 = value; break;
                    case 133: Field133 = value; break;
                    case 134: Field134 = value; break;
                    case 135: Field135 = value; break;
                    case 136: Field136 = value; break;
                    case 137: Field137 = value; break;
                    case 138: Field138 = value; break;
                    case 139: Field139 = value; break;
                    case 140: Field140 = value; break;
                    case 141: Field141 = value; break;
                    case 142: Field142 = value; break;
                    case 143: Field143 = value; break;
                    case 144: Field144 = value; break;
                    case 145: Field145 = value; break;
                    case 146: Field146 = value; break;
                    case 147: Field147 = value; break;
                    case 148: Field148 = value; break;
                    case 149: Field149 = value; break;
                    case 150: Field150 = value; break;
                    case 151: Field151 = value; break;
                    case 152: Field152 = value; break;
                    case 153: Field153 = value; break;
                    case 154: Field154 = value; break;
                    case 155: Field155 = value; break;
                    case 156: Field156 = value; break;
                    case 157: Field157 = value; break;
                    case 158: Field158 = value; break;
                    case 159: Field159 = value; break;
                    case 160: Field160 = value; break;
                    case 161: Field161 = value; break;
                    case 162: Field162 = value; break;
                    case 163: Field163 = value; break;
                    case 164: Field164 = value; break;
                    case 165: Field165 = value; break;
                    case 166: Field166 = value; break;
                    case 167: Field167 = value; break;
                    case 168: Field168 = value; break;
                    case 169: Field169 = value; break;
                    case 170: Field170 = value; break;
                    case 171: Field171 = value; break;
                    case 172: Field172 = value; break;
                    case 173: Field173 = value; break;
                    case 174: Field174 = value; break;
                    case 175: Field175 = value; break;
                    case 176: Field176 = value; break;
                    case 177: Field177 = value; break;
                    case 178: Field178 = value; break;
                    case 179: Field179 = value; break;
                    case 180: Field180 = value; break;
                    case 181: Field181 = value; break;
                    case 182: Field182 = value; break;
                    case 183: Field183 = value; break;
                    case 184: Field184 = value; break;
                    case 185: Field185 = value; break;
                    case 186: Field186 = value; break;
                    case 187: Field187 = value; break;
                    case 188: Field188 = value; break;
                    case 189: Field189 = value; break;
                    case 190: Field190 = value; break;
                    case 191: Field191 = value; break;
                    case 192: Field192 = value; break;
                    case 193: Field193 = value; break;
                    case 194: Field194 = value; break;
                    case 195: Field195 = value; break;
                    case 196: Field196 = value; break;
                    case 197: Field197 = value; break;
                    case 198: Field198 = value; break;
                    case 199: Field199 = value; break;
                    case 200: Field200 = value; break;
                    case 201: Field201 = value; break;
                    case 202: Field202 = value; break;
                    case 203: Field203 = value; break;
                    case 204: Field204 = value; break;
                    case 205: Field205 = value; break;
                    case 206: Field206 = value; break;
                    case 207: Field207 = value; break;
                    case 208: Field208 = value; break;
                    case 209: Field209 = value; break;
                    case 210: Field210 = value; break;
                    case 211: Field211 = value; break;
                    case 212: Field212 = value; break;
                    case 213: Field213 = value; break;
                    case 214: Field214 = value; break;
                    case 215: Field215 = value; break;
                    case 216: Field216 = value; break;
                    case 217: Field217 = value; break;
                    case 218: Field218 = value; break;
                    case 219: Field219 = value; break;
                    case 220: Field220 = value; break;
                    case 221: Field221 = value; break;
                    case 222: Field222 = value; break;
                    case 223: Field223 = value; break;
                    case 224: Field224 = value; break;
                    case 225: Field225 = value; break;
                    case 226: Field226 = value; break;
                    case 227: Field227 = value; break;
                    case 228: Field228 = value; break;
                    case 229: Field229 = value; break;
                    case 230: Field230 = value; break;
                    case 231: Field231 = value; break;
                    case 232: Field232 = value; break;
                    case 233: Field233 = value; break;
                    case 234: Field234 = value; break;
                    case 235: Field235 = value; break;
                    case 236: Field236 = value; break;
                    case 237: Field237 = value; break;
                    case 238: Field238 = value; break;
                    case 239: Field239 = value; break;
                    case 240: Field240 = value; break;
                    case 241: Field241 = value; break;
                    case 242: Field242 = value; break;
                    case 243: Field243 = value; break;
                    case 244: Field244 = value; break;
                    case 245: Field245 = value; break;
                    case 246: Field246 = value; break;
                    case 247: Field247 = value; break;
                    case 248: Field248 = value; break;
                    case 249: Field249 = value; break;
                    case 250: Field250 = value; break;
                    case 251: Field251 = value; break;
                    case 252: Field252 = value; break;
                    case 253: Field253 = value; break;
                    case 254: Field254 = value; break;
                    case 255: Field255 = value; break;
                    case 256: Field256 = value; break;
                    case 257: Field257 = value; break;
                    case 258: Field258 = value; break;
                    case 259: Field259 = value; break;
                    case 260: Field260 = value; break;
                    case 261: Field261 = value; break;
                    case 262: Field262 = value; break;
                    case 263: Field263 = value; break;
                    case 264: Field264 = value; break;
                    case 265: Field265 = value; break;
                    case 266: Field266 = value; break;
                    case 267: Field267 = value; break;
                    case 268: Field268 = value; break;
                    case 269: Field269 = value; break;
                    case 270: Field270 = value; break;
                    case 271: Field271 = value; break;
                    case 272: Field272 = value; break;
                    case 273: Field273 = value; break;
                    case 274: Field274 = value; break;
                    case 275: Field275 = value; break;
                    case 276: Field276 = value; break;
                    case 277: Field277 = value; break;
                    case 278: Field278 = value; break;
                    case 279: Field279 = value; break;
                    case 280: Field280 = value; break;
                    case 281: Field281 = value; break;
                    case 282: Field282 = value; break;
                    case 283: Field283 = value; break;
                    case 284: Field284 = value; break;
                    case 285: Field285 = value; break;
                    case 286: Field286 = value; break;
                    case 287: Field287 = value; break;
                    case 288: Field288 = value; break;
                    case 289: Field289 = value; break;
                    case 290: Field290 = value; break;
                    case 291: Field291 = value; break;
                    case 292: Field292 = value; break;
                    case 293: Field293 = value; break;
                    case 294: Field294 = value; break;
                    case 295: Field295 = value; break;
                    case 296: Field296 = value; break;
                    case 297: Field297 = value; break;
                    case 298: Field298 = value; break;
                    case 299: Field299 = value; break;
                    case 300: Field300 = value; break;
                    case 301: Field301 = value; break;
                    case 302: Field302 = value; break;
                    case 303: Field303 = value; break;
                    case 304: Field304 = value; break;
                    case 305: Field305 = value; break;
                    case 306: Field306 = value; break;
                    case 307: Field307 = value; break;
                    case 308: Field308 = value; break;
                    case 309: Field309 = value; break;
                    case 310: Field310 = value; break;
                    case 311: Field311 = value; break;
                    case 312: Field312 = value; break;
                    case 313: Field313 = value; break;
                    case 314: Field314 = value; break;
                    case 315: Field315 = value; break;
                    case 316: Field316 = value; break;
                    case 317: Field317 = value; break;
                    case 318: Field318 = value; break;
                    case 319: Field319 = value; break;
                    case 320: Field320 = value; break;
                    case 321: Field321 = value; break;
                    case 322: Field322 = value; break;
                    case 323: Field323 = value; break;
                    case 324: Field324 = value; break;
                    case 325: Field325 = value; break;
                    case 326: Field326 = value; break;
                    case 327: Field327 = value; break;
                    case 328: Field328 = value; break;
                    case 329: Field329 = value; break;
                    case 330: Field330 = value; break;
                    case 331: Field331 = value; break;
                    case 332: Field332 = value; break;
                    case 333: Field333 = value; break;
                    case 334: Field334 = value; break;
                    case 335: Field335 = value; break;
                    case 336: Field336 = value; break;
                    case 337: Field337 = value; break;
                    case 338: Field338 = value; break;
                    case 339: Field339 = value; break;
                    case 340: Field340 = value; break;
                    case 341: Field341 = value; break;
                    case 342: Field342 = value; break;
                    case 343: Field343 = value; break;
                    case 344: Field344 = value; break;
                    case 345: Field345 = value; break;
                    case 346: Field346 = value; break;
                    case 347: Field347 = value; break;
                    case 348: Field348 = value; break;
                    case 349: Field349 = value; break;
                    case 350: Field350 = value; break;
                    case 351: Field351 = value; break;
                    case 352: Field352 = value; break;
                    case 353: Field353 = value; break;
                    case 354: Field354 = value; break;
                    case 355: Field355 = value; break;
                    case 356: Field356 = value; break;
                    case 357: Field357 = value; break;
                    case 358: Field358 = value; break;
                    case 359: Field359 = value; break;
                    case 360: Field360 = value; break;
                    case 361: Field361 = value; break;
                    case 362: Field362 = value; break;
                    case 363: Field363 = value; break;
                    case 364: Field364 = value; break;
                    case 365: Field365 = value; break;
                    case 366: Field366 = value; break;
                    case 367: Field367 = value; break;
                    case 368: Field368 = value; break;
                    case 369: Field369 = value; break;
                    case 370: Field370 = value; break;
                    case 371: Field371 = value; break;
                    case 372: Field372 = value; break;
                    case 373: Field373 = value; break;
                    case 374: Field374 = value; break;
                    case 375: Field375 = value; break;
                    case 376: Field376 = value; break;
                    case 377: Field377 = value; break;
                    case 378: Field378 = value; break;
                    case 379: Field379 = value; break;
                    case 380: Field380 = value; break;
                    case 381: Field381 = value; break;
                    case 382: Field382 = value; break;
                    case 383: Field383 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray384) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray384)other);

        public readonly bool Equals(in FixedLengthByteArray384 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray384 left, in FixedLengthByteArray384 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray384 left, in FixedLengthByteArray384 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
              yield return Field46;
              yield return Field47;
              yield return Field48;
              yield return Field49;
              yield return Field50;
              yield return Field51;
              yield return Field52;
              yield return Field53;
              yield return Field54;
              yield return Field55;
              yield return Field56;
              yield return Field57;
              yield return Field58;
              yield return Field59;
              yield return Field60;
              yield return Field61;
              yield return Field62;
              yield return Field63;
              yield return Field64;
              yield return Field65;
              yield return Field66;
              yield return Field67;
              yield return Field68;
              yield return Field69;
              yield return Field70;
              yield return Field71;
              yield return Field72;
              yield return Field73;
              yield return Field74;
              yield return Field75;
              yield return Field76;
              yield return Field77;
              yield return Field78;
              yield return Field79;
              yield return Field80;
              yield return Field81;
              yield return Field82;
              yield return Field83;
              yield return Field84;
              yield return Field85;
              yield return Field86;
              yield return Field87;
              yield return Field88;
              yield return Field89;
              yield return Field90;
              yield return Field91;
              yield return Field92;
              yield return Field93;
              yield return Field94;
              yield return Field95;
              yield return Field96;
              yield return Field97;
              yield return Field98;
              yield return Field99;
              yield return Field100;
              yield return Field101;
              yield return Field102;
              yield return Field103;
              yield return Field104;
              yield return Field105;
              yield return Field106;
              yield return Field107;
              yield return Field108;
              yield return Field109;
              yield return Field110;
              yield return Field111;
              yield return Field112;
              yield return Field113;
              yield return Field114;
              yield return Field115;
              yield return Field116;
              yield return Field117;
              yield return Field118;
              yield return Field119;
              yield return Field120;
              yield return Field121;
              yield return Field122;
              yield return Field123;
              yield return Field124;
              yield return Field125;
              yield return Field126;
              yield return Field127;
              yield return Field128;
              yield return Field129;
              yield return Field130;
              yield return Field131;
              yield return Field132;
              yield return Field133;
              yield return Field134;
              yield return Field135;
              yield return Field136;
              yield return Field137;
              yield return Field138;
              yield return Field139;
              yield return Field140;
              yield return Field141;
              yield return Field142;
              yield return Field143;
              yield return Field144;
              yield return Field145;
              yield return Field146;
              yield return Field147;
              yield return Field148;
              yield return Field149;
              yield return Field150;
              yield return Field151;
              yield return Field152;
              yield return Field153;
              yield return Field154;
              yield return Field155;
              yield return Field156;
              yield return Field157;
              yield return Field158;
              yield return Field159;
              yield return Field160;
              yield return Field161;
              yield return Field162;
              yield return Field163;
              yield return Field164;
              yield return Field165;
              yield return Field166;
              yield return Field167;
              yield return Field168;
              yield return Field169;
              yield return Field170;
              yield return Field171;
              yield return Field172;
              yield return Field173;
              yield return Field174;
              yield return Field175;
              yield return Field176;
              yield return Field177;
              yield return Field178;
              yield return Field179;
              yield return Field180;
              yield return Field181;
              yield return Field182;
              yield return Field183;
              yield return Field184;
              yield return Field185;
              yield return Field186;
              yield return Field187;
              yield return Field188;
              yield return Field189;
              yield return Field190;
              yield return Field191;
              yield return Field192;
              yield return Field193;
              yield return Field194;
              yield return Field195;
              yield return Field196;
              yield return Field197;
              yield return Field198;
              yield return Field199;
              yield return Field200;
              yield return Field201;
              yield return Field202;
              yield return Field203;
              yield return Field204;
              yield return Field205;
              yield return Field206;
              yield return Field207;
              yield return Field208;
              yield return Field209;
              yield return Field210;
              yield return Field211;
              yield return Field212;
              yield return Field213;
              yield return Field214;
              yield return Field215;
              yield return Field216;
              yield return Field217;
              yield return Field218;
              yield return Field219;
              yield return Field220;
              yield return Field221;
              yield return Field222;
              yield return Field223;
              yield return Field224;
              yield return Field225;
              yield return Field226;
              yield return Field227;
              yield return Field228;
              yield return Field229;
              yield return Field230;
              yield return Field231;
              yield return Field232;
              yield return Field233;
              yield return Field234;
              yield return Field235;
              yield return Field236;
              yield return Field237;
              yield return Field238;
              yield return Field239;
              yield return Field240;
              yield return Field241;
              yield return Field242;
              yield return Field243;
              yield return Field244;
              yield return Field245;
              yield return Field246;
              yield return Field247;
              yield return Field248;
              yield return Field249;
              yield return Field250;
              yield return Field251;
              yield return Field252;
              yield return Field253;
              yield return Field254;
              yield return Field255;
              yield return Field256;
              yield return Field257;
              yield return Field258;
              yield return Field259;
              yield return Field260;
              yield return Field261;
              yield return Field262;
              yield return Field263;
              yield return Field264;
              yield return Field265;
              yield return Field266;
              yield return Field267;
              yield return Field268;
              yield return Field269;
              yield return Field270;
              yield return Field271;
              yield return Field272;
              yield return Field273;
              yield return Field274;
              yield return Field275;
              yield return Field276;
              yield return Field277;
              yield return Field278;
              yield return Field279;
              yield return Field280;
              yield return Field281;
              yield return Field282;
              yield return Field283;
              yield return Field284;
              yield return Field285;
              yield return Field286;
              yield return Field287;
              yield return Field288;
              yield return Field289;
              yield return Field290;
              yield return Field291;
              yield return Field292;
              yield return Field293;
              yield return Field294;
              yield return Field295;
              yield return Field296;
              yield return Field297;
              yield return Field298;
              yield return Field299;
              yield return Field300;
              yield return Field301;
              yield return Field302;
              yield return Field303;
              yield return Field304;
              yield return Field305;
              yield return Field306;
              yield return Field307;
              yield return Field308;
              yield return Field309;
              yield return Field310;
              yield return Field311;
              yield return Field312;
              yield return Field313;
              yield return Field314;
              yield return Field315;
              yield return Field316;
              yield return Field317;
              yield return Field318;
              yield return Field319;
              yield return Field320;
              yield return Field321;
              yield return Field322;
              yield return Field323;
              yield return Field324;
              yield return Field325;
              yield return Field326;
              yield return Field327;
              yield return Field328;
              yield return Field329;
              yield return Field330;
              yield return Field331;
              yield return Field332;
              yield return Field333;
              yield return Field334;
              yield return Field335;
              yield return Field336;
              yield return Field337;
              yield return Field338;
              yield return Field339;
              yield return Field340;
              yield return Field341;
              yield return Field342;
              yield return Field343;
              yield return Field344;
              yield return Field345;
              yield return Field346;
              yield return Field347;
              yield return Field348;
              yield return Field349;
              yield return Field350;
              yield return Field351;
              yield return Field352;
              yield return Field353;
              yield return Field354;
              yield return Field355;
              yield return Field356;
              yield return Field357;
              yield return Field358;
              yield return Field359;
              yield return Field360;
              yield return Field361;
              yield return Field362;
              yield return Field363;
              yield return Field364;
              yield return Field365;
              yield return Field366;
              yield return Field367;
              yield return Field368;
              yield return Field369;
              yield return Field370;
              yield return Field371;
              yield return Field372;
              yield return Field373;
              yield return Field374;
              yield return Field375;
              yield return Field376;
              yield return Field377;
              yield return Field378;
              yield return Field379;
              yield return Field380;
              yield return Field381;
              yield return Field382;
              yield return Field383;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray384 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray384 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray384 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray384 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
                case 46: return ref array.Field46;
                case 47: return ref array.Field47;
                case 48: return ref array.Field48;
                case 49: return ref array.Field49;
                case 50: return ref array.Field50;
                case 51: return ref array.Field51;
                case 52: return ref array.Field52;
                case 53: return ref array.Field53;
                case 54: return ref array.Field54;
                case 55: return ref array.Field55;
                case 56: return ref array.Field56;
                case 57: return ref array.Field57;
                case 58: return ref array.Field58;
                case 59: return ref array.Field59;
                case 60: return ref array.Field60;
                case 61: return ref array.Field61;
                case 62: return ref array.Field62;
                case 63: return ref array.Field63;
                case 64: return ref array.Field64;
                case 65: return ref array.Field65;
                case 66: return ref array.Field66;
                case 67: return ref array.Field67;
                case 68: return ref array.Field68;
                case 69: return ref array.Field69;
                case 70: return ref array.Field70;
                case 71: return ref array.Field71;
                case 72: return ref array.Field72;
                case 73: return ref array.Field73;
                case 74: return ref array.Field74;
                case 75: return ref array.Field75;
                case 76: return ref array.Field76;
                case 77: return ref array.Field77;
                case 78: return ref array.Field78;
                case 79: return ref array.Field79;
                case 80: return ref array.Field80;
                case 81: return ref array.Field81;
                case 82: return ref array.Field82;
                case 83: return ref array.Field83;
                case 84: return ref array.Field84;
                case 85: return ref array.Field85;
                case 86: return ref array.Field86;
                case 87: return ref array.Field87;
                case 88: return ref array.Field88;
                case 89: return ref array.Field89;
                case 90: return ref array.Field90;
                case 91: return ref array.Field91;
                case 92: return ref array.Field92;
                case 93: return ref array.Field93;
                case 94: return ref array.Field94;
                case 95: return ref array.Field95;
                case 96: return ref array.Field96;
                case 97: return ref array.Field97;
                case 98: return ref array.Field98;
                case 99: return ref array.Field99;
                case 100: return ref array.Field100;
                case 101: return ref array.Field101;
                case 102: return ref array.Field102;
                case 103: return ref array.Field103;
                case 104: return ref array.Field104;
                case 105: return ref array.Field105;
                case 106: return ref array.Field106;
                case 107: return ref array.Field107;
                case 108: return ref array.Field108;
                case 109: return ref array.Field109;
                case 110: return ref array.Field110;
                case 111: return ref array.Field111;
                case 112: return ref array.Field112;
                case 113: return ref array.Field113;
                case 114: return ref array.Field114;
                case 115: return ref array.Field115;
                case 116: return ref array.Field116;
                case 117: return ref array.Field117;
                case 118: return ref array.Field118;
                case 119: return ref array.Field119;
                case 120: return ref array.Field120;
                case 121: return ref array.Field121;
                case 122: return ref array.Field122;
                case 123: return ref array.Field123;
                case 124: return ref array.Field124;
                case 125: return ref array.Field125;
                case 126: return ref array.Field126;
                case 127: return ref array.Field127;
                case 128: return ref array.Field128;
                case 129: return ref array.Field129;
                case 130: return ref array.Field130;
                case 131: return ref array.Field131;
                case 132: return ref array.Field132;
                case 133: return ref array.Field133;
                case 134: return ref array.Field134;
                case 135: return ref array.Field135;
                case 136: return ref array.Field136;
                case 137: return ref array.Field137;
                case 138: return ref array.Field138;
                case 139: return ref array.Field139;
                case 140: return ref array.Field140;
                case 141: return ref array.Field141;
                case 142: return ref array.Field142;
                case 143: return ref array.Field143;
                case 144: return ref array.Field144;
                case 145: return ref array.Field145;
                case 146: return ref array.Field146;
                case 147: return ref array.Field147;
                case 148: return ref array.Field148;
                case 149: return ref array.Field149;
                case 150: return ref array.Field150;
                case 151: return ref array.Field151;
                case 152: return ref array.Field152;
                case 153: return ref array.Field153;
                case 154: return ref array.Field154;
                case 155: return ref array.Field155;
                case 156: return ref array.Field156;
                case 157: return ref array.Field157;
                case 158: return ref array.Field158;
                case 159: return ref array.Field159;
                case 160: return ref array.Field160;
                case 161: return ref array.Field161;
                case 162: return ref array.Field162;
                case 163: return ref array.Field163;
                case 164: return ref array.Field164;
                case 165: return ref array.Field165;
                case 166: return ref array.Field166;
                case 167: return ref array.Field167;
                case 168: return ref array.Field168;
                case 169: return ref array.Field169;
                case 170: return ref array.Field170;
                case 171: return ref array.Field171;
                case 172: return ref array.Field172;
                case 173: return ref array.Field173;
                case 174: return ref array.Field174;
                case 175: return ref array.Field175;
                case 176: return ref array.Field176;
                case 177: return ref array.Field177;
                case 178: return ref array.Field178;
                case 179: return ref array.Field179;
                case 180: return ref array.Field180;
                case 181: return ref array.Field181;
                case 182: return ref array.Field182;
                case 183: return ref array.Field183;
                case 184: return ref array.Field184;
                case 185: return ref array.Field185;
                case 186: return ref array.Field186;
                case 187: return ref array.Field187;
                case 188: return ref array.Field188;
                case 189: return ref array.Field189;
                case 190: return ref array.Field190;
                case 191: return ref array.Field191;
                case 192: return ref array.Field192;
                case 193: return ref array.Field193;
                case 194: return ref array.Field194;
                case 195: return ref array.Field195;
                case 196: return ref array.Field196;
                case 197: return ref array.Field197;
                case 198: return ref array.Field198;
                case 199: return ref array.Field199;
                case 200: return ref array.Field200;
                case 201: return ref array.Field201;
                case 202: return ref array.Field202;
                case 203: return ref array.Field203;
                case 204: return ref array.Field204;
                case 205: return ref array.Field205;
                case 206: return ref array.Field206;
                case 207: return ref array.Field207;
                case 208: return ref array.Field208;
                case 209: return ref array.Field209;
                case 210: return ref array.Field210;
                case 211: return ref array.Field211;
                case 212: return ref array.Field212;
                case 213: return ref array.Field213;
                case 214: return ref array.Field214;
                case 215: return ref array.Field215;
                case 216: return ref array.Field216;
                case 217: return ref array.Field217;
                case 218: return ref array.Field218;
                case 219: return ref array.Field219;
                case 220: return ref array.Field220;
                case 221: return ref array.Field221;
                case 222: return ref array.Field222;
                case 223: return ref array.Field223;
                case 224: return ref array.Field224;
                case 225: return ref array.Field225;
                case 226: return ref array.Field226;
                case 227: return ref array.Field227;
                case 228: return ref array.Field228;
                case 229: return ref array.Field229;
                case 230: return ref array.Field230;
                case 231: return ref array.Field231;
                case 232: return ref array.Field232;
                case 233: return ref array.Field233;
                case 234: return ref array.Field234;
                case 235: return ref array.Field235;
                case 236: return ref array.Field236;
                case 237: return ref array.Field237;
                case 238: return ref array.Field238;
                case 239: return ref array.Field239;
                case 240: return ref array.Field240;
                case 241: return ref array.Field241;
                case 242: return ref array.Field242;
                case 243: return ref array.Field243;
                case 244: return ref array.Field244;
                case 245: return ref array.Field245;
                case 246: return ref array.Field246;
                case 247: return ref array.Field247;
                case 248: return ref array.Field248;
                case 249: return ref array.Field249;
                case 250: return ref array.Field250;
                case 251: return ref array.Field251;
                case 252: return ref array.Field252;
                case 253: return ref array.Field253;
                case 254: return ref array.Field254;
                case 255: return ref array.Field255;
                case 256: return ref array.Field256;
                case 257: return ref array.Field257;
                case 258: return ref array.Field258;
                case 259: return ref array.Field259;
                case 260: return ref array.Field260;
                case 261: return ref array.Field261;
                case 262: return ref array.Field262;
                case 263: return ref array.Field263;
                case 264: return ref array.Field264;
                case 265: return ref array.Field265;
                case 266: return ref array.Field266;
                case 267: return ref array.Field267;
                case 268: return ref array.Field268;
                case 269: return ref array.Field269;
                case 270: return ref array.Field270;
                case 271: return ref array.Field271;
                case 272: return ref array.Field272;
                case 273: return ref array.Field273;
                case 274: return ref array.Field274;
                case 275: return ref array.Field275;
                case 276: return ref array.Field276;
                case 277: return ref array.Field277;
                case 278: return ref array.Field278;
                case 279: return ref array.Field279;
                case 280: return ref array.Field280;
                case 281: return ref array.Field281;
                case 282: return ref array.Field282;
                case 283: return ref array.Field283;
                case 284: return ref array.Field284;
                case 285: return ref array.Field285;
                case 286: return ref array.Field286;
                case 287: return ref array.Field287;
                case 288: return ref array.Field288;
                case 289: return ref array.Field289;
                case 290: return ref array.Field290;
                case 291: return ref array.Field291;
                case 292: return ref array.Field292;
                case 293: return ref array.Field293;
                case 294: return ref array.Field294;
                case 295: return ref array.Field295;
                case 296: return ref array.Field296;
                case 297: return ref array.Field297;
                case 298: return ref array.Field298;
                case 299: return ref array.Field299;
                case 300: return ref array.Field300;
                case 301: return ref array.Field301;
                case 302: return ref array.Field302;
                case 303: return ref array.Field303;
                case 304: return ref array.Field304;
                case 305: return ref array.Field305;
                case 306: return ref array.Field306;
                case 307: return ref array.Field307;
                case 308: return ref array.Field308;
                case 309: return ref array.Field309;
                case 310: return ref array.Field310;
                case 311: return ref array.Field311;
                case 312: return ref array.Field312;
                case 313: return ref array.Field313;
                case 314: return ref array.Field314;
                case 315: return ref array.Field315;
                case 316: return ref array.Field316;
                case 317: return ref array.Field317;
                case 318: return ref array.Field318;
                case 319: return ref array.Field319;
                case 320: return ref array.Field320;
                case 321: return ref array.Field321;
                case 322: return ref array.Field322;
                case 323: return ref array.Field323;
                case 324: return ref array.Field324;
                case 325: return ref array.Field325;
                case 326: return ref array.Field326;
                case 327: return ref array.Field327;
                case 328: return ref array.Field328;
                case 329: return ref array.Field329;
                case 330: return ref array.Field330;
                case 331: return ref array.Field331;
                case 332: return ref array.Field332;
                case 333: return ref array.Field333;
                case 334: return ref array.Field334;
                case 335: return ref array.Field335;
                case 336: return ref array.Field336;
                case 337: return ref array.Field337;
                case 338: return ref array.Field338;
                case 339: return ref array.Field339;
                case 340: return ref array.Field340;
                case 341: return ref array.Field341;
                case 342: return ref array.Field342;
                case 343: return ref array.Field343;
                case 344: return ref array.Field344;
                case 345: return ref array.Field345;
                case 346: return ref array.Field346;
                case 347: return ref array.Field347;
                case 348: return ref array.Field348;
                case 349: return ref array.Field349;
                case 350: return ref array.Field350;
                case 351: return ref array.Field351;
                case 352: return ref array.Field352;
                case 353: return ref array.Field353;
                case 354: return ref array.Field354;
                case 355: return ref array.Field355;
                case 356: return ref array.Field356;
                case 357: return ref array.Field357;
                case 358: return ref array.Field358;
                case 359: return ref array.Field359;
                case 360: return ref array.Field360;
                case 361: return ref array.Field361;
                case 362: return ref array.Field362;
                case 363: return ref array.Field363;
                case 364: return ref array.Field364;
                case 365: return ref array.Field365;
                case 366: return ref array.Field366;
                case 367: return ref array.Field367;
                case 368: return ref array.Field368;
                case 369: return ref array.Field369;
                case 370: return ref array.Field370;
                case 371: return ref array.Field371;
                case 372: return ref array.Field372;
                case 373: return ref array.Field373;
                case 374: return ref array.Field374;
                case 375: return ref array.Field375;
                case 376: return ref array.Field376;
                case 377: return ref array.Field377;
                case 378: return ref array.Field378;
                case 379: return ref array.Field379;
                case 380: return ref array.Field380;
                case 381: return ref array.Field381;
                case 382: return ref array.Field382;
                case 383: return ref array.Field383;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray384 array1, in FixedLengthByteArray384 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray384 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray384 array1, in FixedLengthByteArray384 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray384 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray384 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray384 array1, in FixedLengthByteArray384 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray384 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray384 array1, in FixedLengthByteArray384 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray384 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 512 * sizeof(Byte), CharSet = CharSet.Unicode)]
	public struct FixedLengthByteArray512
#if GENERATE_ENUMERABLE
		: IEnumerable<Byte>
#endif
	{
		private static readonly FixedLengthByteArray512 _Zero = default;
		public static ref readonly FixedLengthByteArray512 Zero => ref _Zero;

		public const int ConstLength = 512;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthByteArray512(
			Byte field0
			, Byte field1
			, Byte field2
			, Byte field3
			, Byte field4
			, Byte field5
			, Byte field6
			, Byte field7
			, Byte field8
			, Byte field9
			, Byte field10
			, Byte field11
			, Byte field12
			, Byte field13
			, Byte field14
			, Byte field15
			, Byte field16
			, Byte field17
			, Byte field18
			, Byte field19
			, Byte field20
			, Byte field21
			, Byte field22
			, Byte field23
			, Byte field24
			, Byte field25
			, Byte field26
			, Byte field27
			, Byte field28
			, Byte field29
			, Byte field30
			, Byte field31
			, Byte field32
			, Byte field33
			, Byte field34
			, Byte field35
			, Byte field36
			, Byte field37
			, Byte field38
			, Byte field39
			, Byte field40
			, Byte field41
			, Byte field42
			, Byte field43
			, Byte field44
			, Byte field45
			, Byte field46
			, Byte field47
			, Byte field48
			, Byte field49
			, Byte field50
			, Byte field51
			, Byte field52
			, Byte field53
			, Byte field54
			, Byte field55
			, Byte field56
			, Byte field57
			, Byte field58
			, Byte field59
			, Byte field60
			, Byte field61
			, Byte field62
			, Byte field63
			, Byte field64
			, Byte field65
			, Byte field66
			, Byte field67
			, Byte field68
			, Byte field69
			, Byte field70
			, Byte field71
			, Byte field72
			, Byte field73
			, Byte field74
			, Byte field75
			, Byte field76
			, Byte field77
			, Byte field78
			, Byte field79
			, Byte field80
			, Byte field81
			, Byte field82
			, Byte field83
			, Byte field84
			, Byte field85
			, Byte field86
			, Byte field87
			, Byte field88
			, Byte field89
			, Byte field90
			, Byte field91
			, Byte field92
			, Byte field93
			, Byte field94
			, Byte field95
			, Byte field96
			, Byte field97
			, Byte field98
			, Byte field99
			, Byte field100
			, Byte field101
			, Byte field102
			, Byte field103
			, Byte field104
			, Byte field105
			, Byte field106
			, Byte field107
			, Byte field108
			, Byte field109
			, Byte field110
			, Byte field111
			, Byte field112
			, Byte field113
			, Byte field114
			, Byte field115
			, Byte field116
			, Byte field117
			, Byte field118
			, Byte field119
			, Byte field120
			, Byte field121
			, Byte field122
			, Byte field123
			, Byte field124
			, Byte field125
			, Byte field126
			, Byte field127
			, Byte field128
			, Byte field129
			, Byte field130
			, Byte field131
			, Byte field132
			, Byte field133
			, Byte field134
			, Byte field135
			, Byte field136
			, Byte field137
			, Byte field138
			, Byte field139
			, Byte field140
			, Byte field141
			, Byte field142
			, Byte field143
			, Byte field144
			, Byte field145
			, Byte field146
			, Byte field147
			, Byte field148
			, Byte field149
			, Byte field150
			, Byte field151
			, Byte field152
			, Byte field153
			, Byte field154
			, Byte field155
			, Byte field156
			, Byte field157
			, Byte field158
			, Byte field159
			, Byte field160
			, Byte field161
			, Byte field162
			, Byte field163
			, Byte field164
			, Byte field165
			, Byte field166
			, Byte field167
			, Byte field168
			, Byte field169
			, Byte field170
			, Byte field171
			, Byte field172
			, Byte field173
			, Byte field174
			, Byte field175
			, Byte field176
			, Byte field177
			, Byte field178
			, Byte field179
			, Byte field180
			, Byte field181
			, Byte field182
			, Byte field183
			, Byte field184
			, Byte field185
			, Byte field186
			, Byte field187
			, Byte field188
			, Byte field189
			, Byte field190
			, Byte field191
			, Byte field192
			, Byte field193
			, Byte field194
			, Byte field195
			, Byte field196
			, Byte field197
			, Byte field198
			, Byte field199
			, Byte field200
			, Byte field201
			, Byte field202
			, Byte field203
			, Byte field204
			, Byte field205
			, Byte field206
			, Byte field207
			, Byte field208
			, Byte field209
			, Byte field210
			, Byte field211
			, Byte field212
			, Byte field213
			, Byte field214
			, Byte field215
			, Byte field216
			, Byte field217
			, Byte field218
			, Byte field219
			, Byte field220
			, Byte field221
			, Byte field222
			, Byte field223
			, Byte field224
			, Byte field225
			, Byte field226
			, Byte field227
			, Byte field228
			, Byte field229
			, Byte field230
			, Byte field231
			, Byte field232
			, Byte field233
			, Byte field234
			, Byte field235
			, Byte field236
			, Byte field237
			, Byte field238
			, Byte field239
			, Byte field240
			, Byte field241
			, Byte field242
			, Byte field243
			, Byte field244
			, Byte field245
			, Byte field246
			, Byte field247
			, Byte field248
			, Byte field249
			, Byte field250
			, Byte field251
			, Byte field252
			, Byte field253
			, Byte field254
			, Byte field255
			, Byte field256
			, Byte field257
			, Byte field258
			, Byte field259
			, Byte field260
			, Byte field261
			, Byte field262
			, Byte field263
			, Byte field264
			, Byte field265
			, Byte field266
			, Byte field267
			, Byte field268
			, Byte field269
			, Byte field270
			, Byte field271
			, Byte field272
			, Byte field273
			, Byte field274
			, Byte field275
			, Byte field276
			, Byte field277
			, Byte field278
			, Byte field279
			, Byte field280
			, Byte field281
			, Byte field282
			, Byte field283
			, Byte field284
			, Byte field285
			, Byte field286
			, Byte field287
			, Byte field288
			, Byte field289
			, Byte field290
			, Byte field291
			, Byte field292
			, Byte field293
			, Byte field294
			, Byte field295
			, Byte field296
			, Byte field297
			, Byte field298
			, Byte field299
			, Byte field300
			, Byte field301
			, Byte field302
			, Byte field303
			, Byte field304
			, Byte field305
			, Byte field306
			, Byte field307
			, Byte field308
			, Byte field309
			, Byte field310
			, Byte field311
			, Byte field312
			, Byte field313
			, Byte field314
			, Byte field315
			, Byte field316
			, Byte field317
			, Byte field318
			, Byte field319
			, Byte field320
			, Byte field321
			, Byte field322
			, Byte field323
			, Byte field324
			, Byte field325
			, Byte field326
			, Byte field327
			, Byte field328
			, Byte field329
			, Byte field330
			, Byte field331
			, Byte field332
			, Byte field333
			, Byte field334
			, Byte field335
			, Byte field336
			, Byte field337
			, Byte field338
			, Byte field339
			, Byte field340
			, Byte field341
			, Byte field342
			, Byte field343
			, Byte field344
			, Byte field345
			, Byte field346
			, Byte field347
			, Byte field348
			, Byte field349
			, Byte field350
			, Byte field351
			, Byte field352
			, Byte field353
			, Byte field354
			, Byte field355
			, Byte field356
			, Byte field357
			, Byte field358
			, Byte field359
			, Byte field360
			, Byte field361
			, Byte field362
			, Byte field363
			, Byte field364
			, Byte field365
			, Byte field366
			, Byte field367
			, Byte field368
			, Byte field369
			, Byte field370
			, Byte field371
			, Byte field372
			, Byte field373
			, Byte field374
			, Byte field375
			, Byte field376
			, Byte field377
			, Byte field378
			, Byte field379
			, Byte field380
			, Byte field381
			, Byte field382
			, Byte field383
			, Byte field384
			, Byte field385
			, Byte field386
			, Byte field387
			, Byte field388
			, Byte field389
			, Byte field390
			, Byte field391
			, Byte field392
			, Byte field393
			, Byte field394
			, Byte field395
			, Byte field396
			, Byte field397
			, Byte field398
			, Byte field399
			, Byte field400
			, Byte field401
			, Byte field402
			, Byte field403
			, Byte field404
			, Byte field405
			, Byte field406
			, Byte field407
			, Byte field408
			, Byte field409
			, Byte field410
			, Byte field411
			, Byte field412
			, Byte field413
			, Byte field414
			, Byte field415
			, Byte field416
			, Byte field417
			, Byte field418
			, Byte field419
			, Byte field420
			, Byte field421
			, Byte field422
			, Byte field423
			, Byte field424
			, Byte field425
			, Byte field426
			, Byte field427
			, Byte field428
			, Byte field429
			, Byte field430
			, Byte field431
			, Byte field432
			, Byte field433
			, Byte field434
			, Byte field435
			, Byte field436
			, Byte field437
			, Byte field438
			, Byte field439
			, Byte field440
			, Byte field441
			, Byte field442
			, Byte field443
			, Byte field444
			, Byte field445
			, Byte field446
			, Byte field447
			, Byte field448
			, Byte field449
			, Byte field450
			, Byte field451
			, Byte field452
			, Byte field453
			, Byte field454
			, Byte field455
			, Byte field456
			, Byte field457
			, Byte field458
			, Byte field459
			, Byte field460
			, Byte field461
			, Byte field462
			, Byte field463
			, Byte field464
			, Byte field465
			, Byte field466
			, Byte field467
			, Byte field468
			, Byte field469
			, Byte field470
			, Byte field471
			, Byte field472
			, Byte field473
			, Byte field474
			, Byte field475
			, Byte field476
			, Byte field477
			, Byte field478
			, Byte field479
			, Byte field480
			, Byte field481
			, Byte field482
			, Byte field483
			, Byte field484
			, Byte field485
			, Byte field486
			, Byte field487
			, Byte field488
			, Byte field489
			, Byte field490
			, Byte field491
			, Byte field492
			, Byte field493
			, Byte field494
			, Byte field495
			, Byte field496
			, Byte field497
			, Byte field498
			, Byte field499
			, Byte field500
			, Byte field501
			, Byte field502
			, Byte field503
			, Byte field504
			, Byte field505
			, Byte field506
			, Byte field507
			, Byte field508
			, Byte field509
			, Byte field510
			, Byte field511
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
			Field46 = field46;
			Field47 = field47;
			Field48 = field48;
			Field49 = field49;
			Field50 = field50;
			Field51 = field51;
			Field52 = field52;
			Field53 = field53;
			Field54 = field54;
			Field55 = field55;
			Field56 = field56;
			Field57 = field57;
			Field58 = field58;
			Field59 = field59;
			Field60 = field60;
			Field61 = field61;
			Field62 = field62;
			Field63 = field63;
			Field64 = field64;
			Field65 = field65;
			Field66 = field66;
			Field67 = field67;
			Field68 = field68;
			Field69 = field69;
			Field70 = field70;
			Field71 = field71;
			Field72 = field72;
			Field73 = field73;
			Field74 = field74;
			Field75 = field75;
			Field76 = field76;
			Field77 = field77;
			Field78 = field78;
			Field79 = field79;
			Field80 = field80;
			Field81 = field81;
			Field82 = field82;
			Field83 = field83;
			Field84 = field84;
			Field85 = field85;
			Field86 = field86;
			Field87 = field87;
			Field88 = field88;
			Field89 = field89;
			Field90 = field90;
			Field91 = field91;
			Field92 = field92;
			Field93 = field93;
			Field94 = field94;
			Field95 = field95;
			Field96 = field96;
			Field97 = field97;
			Field98 = field98;
			Field99 = field99;
			Field100 = field100;
			Field101 = field101;
			Field102 = field102;
			Field103 = field103;
			Field104 = field104;
			Field105 = field105;
			Field106 = field106;
			Field107 = field107;
			Field108 = field108;
			Field109 = field109;
			Field110 = field110;
			Field111 = field111;
			Field112 = field112;
			Field113 = field113;
			Field114 = field114;
			Field115 = field115;
			Field116 = field116;
			Field117 = field117;
			Field118 = field118;
			Field119 = field119;
			Field120 = field120;
			Field121 = field121;
			Field122 = field122;
			Field123 = field123;
			Field124 = field124;
			Field125 = field125;
			Field126 = field126;
			Field127 = field127;
			Field128 = field128;
			Field129 = field129;
			Field130 = field130;
			Field131 = field131;
			Field132 = field132;
			Field133 = field133;
			Field134 = field134;
			Field135 = field135;
			Field136 = field136;
			Field137 = field137;
			Field138 = field138;
			Field139 = field139;
			Field140 = field140;
			Field141 = field141;
			Field142 = field142;
			Field143 = field143;
			Field144 = field144;
			Field145 = field145;
			Field146 = field146;
			Field147 = field147;
			Field148 = field148;
			Field149 = field149;
			Field150 = field150;
			Field151 = field151;
			Field152 = field152;
			Field153 = field153;
			Field154 = field154;
			Field155 = field155;
			Field156 = field156;
			Field157 = field157;
			Field158 = field158;
			Field159 = field159;
			Field160 = field160;
			Field161 = field161;
			Field162 = field162;
			Field163 = field163;
			Field164 = field164;
			Field165 = field165;
			Field166 = field166;
			Field167 = field167;
			Field168 = field168;
			Field169 = field169;
			Field170 = field170;
			Field171 = field171;
			Field172 = field172;
			Field173 = field173;
			Field174 = field174;
			Field175 = field175;
			Field176 = field176;
			Field177 = field177;
			Field178 = field178;
			Field179 = field179;
			Field180 = field180;
			Field181 = field181;
			Field182 = field182;
			Field183 = field183;
			Field184 = field184;
			Field185 = field185;
			Field186 = field186;
			Field187 = field187;
			Field188 = field188;
			Field189 = field189;
			Field190 = field190;
			Field191 = field191;
			Field192 = field192;
			Field193 = field193;
			Field194 = field194;
			Field195 = field195;
			Field196 = field196;
			Field197 = field197;
			Field198 = field198;
			Field199 = field199;
			Field200 = field200;
			Field201 = field201;
			Field202 = field202;
			Field203 = field203;
			Field204 = field204;
			Field205 = field205;
			Field206 = field206;
			Field207 = field207;
			Field208 = field208;
			Field209 = field209;
			Field210 = field210;
			Field211 = field211;
			Field212 = field212;
			Field213 = field213;
			Field214 = field214;
			Field215 = field215;
			Field216 = field216;
			Field217 = field217;
			Field218 = field218;
			Field219 = field219;
			Field220 = field220;
			Field221 = field221;
			Field222 = field222;
			Field223 = field223;
			Field224 = field224;
			Field225 = field225;
			Field226 = field226;
			Field227 = field227;
			Field228 = field228;
			Field229 = field229;
			Field230 = field230;
			Field231 = field231;
			Field232 = field232;
			Field233 = field233;
			Field234 = field234;
			Field235 = field235;
			Field236 = field236;
			Field237 = field237;
			Field238 = field238;
			Field239 = field239;
			Field240 = field240;
			Field241 = field241;
			Field242 = field242;
			Field243 = field243;
			Field244 = field244;
			Field245 = field245;
			Field246 = field246;
			Field247 = field247;
			Field248 = field248;
			Field249 = field249;
			Field250 = field250;
			Field251 = field251;
			Field252 = field252;
			Field253 = field253;
			Field254 = field254;
			Field255 = field255;
			Field256 = field256;
			Field257 = field257;
			Field258 = field258;
			Field259 = field259;
			Field260 = field260;
			Field261 = field261;
			Field262 = field262;
			Field263 = field263;
			Field264 = field264;
			Field265 = field265;
			Field266 = field266;
			Field267 = field267;
			Field268 = field268;
			Field269 = field269;
			Field270 = field270;
			Field271 = field271;
			Field272 = field272;
			Field273 = field273;
			Field274 = field274;
			Field275 = field275;
			Field276 = field276;
			Field277 = field277;
			Field278 = field278;
			Field279 = field279;
			Field280 = field280;
			Field281 = field281;
			Field282 = field282;
			Field283 = field283;
			Field284 = field284;
			Field285 = field285;
			Field286 = field286;
			Field287 = field287;
			Field288 = field288;
			Field289 = field289;
			Field290 = field290;
			Field291 = field291;
			Field292 = field292;
			Field293 = field293;
			Field294 = field294;
			Field295 = field295;
			Field296 = field296;
			Field297 = field297;
			Field298 = field298;
			Field299 = field299;
			Field300 = field300;
			Field301 = field301;
			Field302 = field302;
			Field303 = field303;
			Field304 = field304;
			Field305 = field305;
			Field306 = field306;
			Field307 = field307;
			Field308 = field308;
			Field309 = field309;
			Field310 = field310;
			Field311 = field311;
			Field312 = field312;
			Field313 = field313;
			Field314 = field314;
			Field315 = field315;
			Field316 = field316;
			Field317 = field317;
			Field318 = field318;
			Field319 = field319;
			Field320 = field320;
			Field321 = field321;
			Field322 = field322;
			Field323 = field323;
			Field324 = field324;
			Field325 = field325;
			Field326 = field326;
			Field327 = field327;
			Field328 = field328;
			Field329 = field329;
			Field330 = field330;
			Field331 = field331;
			Field332 = field332;
			Field333 = field333;
			Field334 = field334;
			Field335 = field335;
			Field336 = field336;
			Field337 = field337;
			Field338 = field338;
			Field339 = field339;
			Field340 = field340;
			Field341 = field341;
			Field342 = field342;
			Field343 = field343;
			Field344 = field344;
			Field345 = field345;
			Field346 = field346;
			Field347 = field347;
			Field348 = field348;
			Field349 = field349;
			Field350 = field350;
			Field351 = field351;
			Field352 = field352;
			Field353 = field353;
			Field354 = field354;
			Field355 = field355;
			Field356 = field356;
			Field357 = field357;
			Field358 = field358;
			Field359 = field359;
			Field360 = field360;
			Field361 = field361;
			Field362 = field362;
			Field363 = field363;
			Field364 = field364;
			Field365 = field365;
			Field366 = field366;
			Field367 = field367;
			Field368 = field368;
			Field369 = field369;
			Field370 = field370;
			Field371 = field371;
			Field372 = field372;
			Field373 = field373;
			Field374 = field374;
			Field375 = field375;
			Field376 = field376;
			Field377 = field377;
			Field378 = field378;
			Field379 = field379;
			Field380 = field380;
			Field381 = field381;
			Field382 = field382;
			Field383 = field383;
			Field384 = field384;
			Field385 = field385;
			Field386 = field386;
			Field387 = field387;
			Field388 = field388;
			Field389 = field389;
			Field390 = field390;
			Field391 = field391;
			Field392 = field392;
			Field393 = field393;
			Field394 = field394;
			Field395 = field395;
			Field396 = field396;
			Field397 = field397;
			Field398 = field398;
			Field399 = field399;
			Field400 = field400;
			Field401 = field401;
			Field402 = field402;
			Field403 = field403;
			Field404 = field404;
			Field405 = field405;
			Field406 = field406;
			Field407 = field407;
			Field408 = field408;
			Field409 = field409;
			Field410 = field410;
			Field411 = field411;
			Field412 = field412;
			Field413 = field413;
			Field414 = field414;
			Field415 = field415;
			Field416 = field416;
			Field417 = field417;
			Field418 = field418;
			Field419 = field419;
			Field420 = field420;
			Field421 = field421;
			Field422 = field422;
			Field423 = field423;
			Field424 = field424;
			Field425 = field425;
			Field426 = field426;
			Field427 = field427;
			Field428 = field428;
			Field429 = field429;
			Field430 = field430;
			Field431 = field431;
			Field432 = field432;
			Field433 = field433;
			Field434 = field434;
			Field435 = field435;
			Field436 = field436;
			Field437 = field437;
			Field438 = field438;
			Field439 = field439;
			Field440 = field440;
			Field441 = field441;
			Field442 = field442;
			Field443 = field443;
			Field444 = field444;
			Field445 = field445;
			Field446 = field446;
			Field447 = field447;
			Field448 = field448;
			Field449 = field449;
			Field450 = field450;
			Field451 = field451;
			Field452 = field452;
			Field453 = field453;
			Field454 = field454;
			Field455 = field455;
			Field456 = field456;
			Field457 = field457;
			Field458 = field458;
			Field459 = field459;
			Field460 = field460;
			Field461 = field461;
			Field462 = field462;
			Field463 = field463;
			Field464 = field464;
			Field465 = field465;
			Field466 = field466;
			Field467 = field467;
			Field468 = field468;
			Field469 = field469;
			Field470 = field470;
			Field471 = field471;
			Field472 = field472;
			Field473 = field473;
			Field474 = field474;
			Field475 = field475;
			Field476 = field476;
			Field477 = field477;
			Field478 = field478;
			Field479 = field479;
			Field480 = field480;
			Field481 = field481;
			Field482 = field482;
			Field483 = field483;
			Field484 = field484;
			Field485 = field485;
			Field486 = field486;
			Field487 = field487;
			Field488 = field488;
			Field489 = field489;
			Field490 = field490;
			Field491 = field491;
			Field492 = field492;
			Field493 = field493;
			Field494 = field494;
			Field495 = field495;
			Field496 = field496;
			Field497 = field497;
			Field498 = field498;
			Field499 = field499;
			Field500 = field500;
			Field501 = field501;
			Field502 = field502;
			Field503 = field503;
			Field504 = field504;
			Field505 = field505;
			Field506 = field506;
			Field507 = field507;
			Field508 = field508;
			Field509 = field509;
			Field510 = field510;
			Field511 = field511;
		}
#endif
		public Byte Field0;
#if GENERATE_ALL_FIELDS
		public Byte Field1;
		public Byte Field2;
		public Byte Field3;
		public Byte Field4;
		public Byte Field5;
		public Byte Field6;
		public Byte Field7;
		public Byte Field8;
		public Byte Field9;
		public Byte Field10;
		public Byte Field11;
		public Byte Field12;
		public Byte Field13;
		public Byte Field14;
		public Byte Field15;
		public Byte Field16;
		public Byte Field17;
		public Byte Field18;
		public Byte Field19;
		public Byte Field20;
		public Byte Field21;
		public Byte Field22;
		public Byte Field23;
		public Byte Field24;
		public Byte Field25;
		public Byte Field26;
		public Byte Field27;
		public Byte Field28;
		public Byte Field29;
		public Byte Field30;
		public Byte Field31;
		public Byte Field32;
		public Byte Field33;
		public Byte Field34;
		public Byte Field35;
		public Byte Field36;
		public Byte Field37;
		public Byte Field38;
		public Byte Field39;
		public Byte Field40;
		public Byte Field41;
		public Byte Field42;
		public Byte Field43;
		public Byte Field44;
		public Byte Field45;
		public Byte Field46;
		public Byte Field47;
		public Byte Field48;
		public Byte Field49;
		public Byte Field50;
		public Byte Field51;
		public Byte Field52;
		public Byte Field53;
		public Byte Field54;
		public Byte Field55;
		public Byte Field56;
		public Byte Field57;
		public Byte Field58;
		public Byte Field59;
		public Byte Field60;
		public Byte Field61;
		public Byte Field62;
		public Byte Field63;
		public Byte Field64;
		public Byte Field65;
		public Byte Field66;
		public Byte Field67;
		public Byte Field68;
		public Byte Field69;
		public Byte Field70;
		public Byte Field71;
		public Byte Field72;
		public Byte Field73;
		public Byte Field74;
		public Byte Field75;
		public Byte Field76;
		public Byte Field77;
		public Byte Field78;
		public Byte Field79;
		public Byte Field80;
		public Byte Field81;
		public Byte Field82;
		public Byte Field83;
		public Byte Field84;
		public Byte Field85;
		public Byte Field86;
		public Byte Field87;
		public Byte Field88;
		public Byte Field89;
		public Byte Field90;
		public Byte Field91;
		public Byte Field92;
		public Byte Field93;
		public Byte Field94;
		public Byte Field95;
		public Byte Field96;
		public Byte Field97;
		public Byte Field98;
		public Byte Field99;
		public Byte Field100;
		public Byte Field101;
		public Byte Field102;
		public Byte Field103;
		public Byte Field104;
		public Byte Field105;
		public Byte Field106;
		public Byte Field107;
		public Byte Field108;
		public Byte Field109;
		public Byte Field110;
		public Byte Field111;
		public Byte Field112;
		public Byte Field113;
		public Byte Field114;
		public Byte Field115;
		public Byte Field116;
		public Byte Field117;
		public Byte Field118;
		public Byte Field119;
		public Byte Field120;
		public Byte Field121;
		public Byte Field122;
		public Byte Field123;
		public Byte Field124;
		public Byte Field125;
		public Byte Field126;
		public Byte Field127;
		public Byte Field128;
		public Byte Field129;
		public Byte Field130;
		public Byte Field131;
		public Byte Field132;
		public Byte Field133;
		public Byte Field134;
		public Byte Field135;
		public Byte Field136;
		public Byte Field137;
		public Byte Field138;
		public Byte Field139;
		public Byte Field140;
		public Byte Field141;
		public Byte Field142;
		public Byte Field143;
		public Byte Field144;
		public Byte Field145;
		public Byte Field146;
		public Byte Field147;
		public Byte Field148;
		public Byte Field149;
		public Byte Field150;
		public Byte Field151;
		public Byte Field152;
		public Byte Field153;
		public Byte Field154;
		public Byte Field155;
		public Byte Field156;
		public Byte Field157;
		public Byte Field158;
		public Byte Field159;
		public Byte Field160;
		public Byte Field161;
		public Byte Field162;
		public Byte Field163;
		public Byte Field164;
		public Byte Field165;
		public Byte Field166;
		public Byte Field167;
		public Byte Field168;
		public Byte Field169;
		public Byte Field170;
		public Byte Field171;
		public Byte Field172;
		public Byte Field173;
		public Byte Field174;
		public Byte Field175;
		public Byte Field176;
		public Byte Field177;
		public Byte Field178;
		public Byte Field179;
		public Byte Field180;
		public Byte Field181;
		public Byte Field182;
		public Byte Field183;
		public Byte Field184;
		public Byte Field185;
		public Byte Field186;
		public Byte Field187;
		public Byte Field188;
		public Byte Field189;
		public Byte Field190;
		public Byte Field191;
		public Byte Field192;
		public Byte Field193;
		public Byte Field194;
		public Byte Field195;
		public Byte Field196;
		public Byte Field197;
		public Byte Field198;
		public Byte Field199;
		public Byte Field200;
		public Byte Field201;
		public Byte Field202;
		public Byte Field203;
		public Byte Field204;
		public Byte Field205;
		public Byte Field206;
		public Byte Field207;
		public Byte Field208;
		public Byte Field209;
		public Byte Field210;
		public Byte Field211;
		public Byte Field212;
		public Byte Field213;
		public Byte Field214;
		public Byte Field215;
		public Byte Field216;
		public Byte Field217;
		public Byte Field218;
		public Byte Field219;
		public Byte Field220;
		public Byte Field221;
		public Byte Field222;
		public Byte Field223;
		public Byte Field224;
		public Byte Field225;
		public Byte Field226;
		public Byte Field227;
		public Byte Field228;
		public Byte Field229;
		public Byte Field230;
		public Byte Field231;
		public Byte Field232;
		public Byte Field233;
		public Byte Field234;
		public Byte Field235;
		public Byte Field236;
		public Byte Field237;
		public Byte Field238;
		public Byte Field239;
		public Byte Field240;
		public Byte Field241;
		public Byte Field242;
		public Byte Field243;
		public Byte Field244;
		public Byte Field245;
		public Byte Field246;
		public Byte Field247;
		public Byte Field248;
		public Byte Field249;
		public Byte Field250;
		public Byte Field251;
		public Byte Field252;
		public Byte Field253;
		public Byte Field254;
		public Byte Field255;
		public Byte Field256;
		public Byte Field257;
		public Byte Field258;
		public Byte Field259;
		public Byte Field260;
		public Byte Field261;
		public Byte Field262;
		public Byte Field263;
		public Byte Field264;
		public Byte Field265;
		public Byte Field266;
		public Byte Field267;
		public Byte Field268;
		public Byte Field269;
		public Byte Field270;
		public Byte Field271;
		public Byte Field272;
		public Byte Field273;
		public Byte Field274;
		public Byte Field275;
		public Byte Field276;
		public Byte Field277;
		public Byte Field278;
		public Byte Field279;
		public Byte Field280;
		public Byte Field281;
		public Byte Field282;
		public Byte Field283;
		public Byte Field284;
		public Byte Field285;
		public Byte Field286;
		public Byte Field287;
		public Byte Field288;
		public Byte Field289;
		public Byte Field290;
		public Byte Field291;
		public Byte Field292;
		public Byte Field293;
		public Byte Field294;
		public Byte Field295;
		public Byte Field296;
		public Byte Field297;
		public Byte Field298;
		public Byte Field299;
		public Byte Field300;
		public Byte Field301;
		public Byte Field302;
		public Byte Field303;
		public Byte Field304;
		public Byte Field305;
		public Byte Field306;
		public Byte Field307;
		public Byte Field308;
		public Byte Field309;
		public Byte Field310;
		public Byte Field311;
		public Byte Field312;
		public Byte Field313;
		public Byte Field314;
		public Byte Field315;
		public Byte Field316;
		public Byte Field317;
		public Byte Field318;
		public Byte Field319;
		public Byte Field320;
		public Byte Field321;
		public Byte Field322;
		public Byte Field323;
		public Byte Field324;
		public Byte Field325;
		public Byte Field326;
		public Byte Field327;
		public Byte Field328;
		public Byte Field329;
		public Byte Field330;
		public Byte Field331;
		public Byte Field332;
		public Byte Field333;
		public Byte Field334;
		public Byte Field335;
		public Byte Field336;
		public Byte Field337;
		public Byte Field338;
		public Byte Field339;
		public Byte Field340;
		public Byte Field341;
		public Byte Field342;
		public Byte Field343;
		public Byte Field344;
		public Byte Field345;
		public Byte Field346;
		public Byte Field347;
		public Byte Field348;
		public Byte Field349;
		public Byte Field350;
		public Byte Field351;
		public Byte Field352;
		public Byte Field353;
		public Byte Field354;
		public Byte Field355;
		public Byte Field356;
		public Byte Field357;
		public Byte Field358;
		public Byte Field359;
		public Byte Field360;
		public Byte Field361;
		public Byte Field362;
		public Byte Field363;
		public Byte Field364;
		public Byte Field365;
		public Byte Field366;
		public Byte Field367;
		public Byte Field368;
		public Byte Field369;
		public Byte Field370;
		public Byte Field371;
		public Byte Field372;
		public Byte Field373;
		public Byte Field374;
		public Byte Field375;
		public Byte Field376;
		public Byte Field377;
		public Byte Field378;
		public Byte Field379;
		public Byte Field380;
		public Byte Field381;
		public Byte Field382;
		public Byte Field383;
		public Byte Field384;
		public Byte Field385;
		public Byte Field386;
		public Byte Field387;
		public Byte Field388;
		public Byte Field389;
		public Byte Field390;
		public Byte Field391;
		public Byte Field392;
		public Byte Field393;
		public Byte Field394;
		public Byte Field395;
		public Byte Field396;
		public Byte Field397;
		public Byte Field398;
		public Byte Field399;
		public Byte Field400;
		public Byte Field401;
		public Byte Field402;
		public Byte Field403;
		public Byte Field404;
		public Byte Field405;
		public Byte Field406;
		public Byte Field407;
		public Byte Field408;
		public Byte Field409;
		public Byte Field410;
		public Byte Field411;
		public Byte Field412;
		public Byte Field413;
		public Byte Field414;
		public Byte Field415;
		public Byte Field416;
		public Byte Field417;
		public Byte Field418;
		public Byte Field419;
		public Byte Field420;
		public Byte Field421;
		public Byte Field422;
		public Byte Field423;
		public Byte Field424;
		public Byte Field425;
		public Byte Field426;
		public Byte Field427;
		public Byte Field428;
		public Byte Field429;
		public Byte Field430;
		public Byte Field431;
		public Byte Field432;
		public Byte Field433;
		public Byte Field434;
		public Byte Field435;
		public Byte Field436;
		public Byte Field437;
		public Byte Field438;
		public Byte Field439;
		public Byte Field440;
		public Byte Field441;
		public Byte Field442;
		public Byte Field443;
		public Byte Field444;
		public Byte Field445;
		public Byte Field446;
		public Byte Field447;
		public Byte Field448;
		public Byte Field449;
		public Byte Field450;
		public Byte Field451;
		public Byte Field452;
		public Byte Field453;
		public Byte Field454;
		public Byte Field455;
		public Byte Field456;
		public Byte Field457;
		public Byte Field458;
		public Byte Field459;
		public Byte Field460;
		public Byte Field461;
		public Byte Field462;
		public Byte Field463;
		public Byte Field464;
		public Byte Field465;
		public Byte Field466;
		public Byte Field467;
		public Byte Field468;
		public Byte Field469;
		public Byte Field470;
		public Byte Field471;
		public Byte Field472;
		public Byte Field473;
		public Byte Field474;
		public Byte Field475;
		public Byte Field476;
		public Byte Field477;
		public Byte Field478;
		public Byte Field479;
		public Byte Field480;
		public Byte Field481;
		public Byte Field482;
		public Byte Field483;
		public Byte Field484;
		public Byte Field485;
		public Byte Field486;
		public Byte Field487;
		public Byte Field488;
		public Byte Field489;
		public Byte Field490;
		public Byte Field491;
		public Byte Field492;
		public Byte Field493;
		public Byte Field494;
		public Byte Field495;
		public Byte Field496;
		public Byte Field497;
		public Byte Field498;
		public Byte Field499;
		public Byte Field500;
		public Byte Field501;
		public Byte Field502;
		public Byte Field503;
		public Byte Field504;
		public Byte Field505;
		public Byte Field506;
		public Byte Field507;
		public Byte Field508;
		public Byte Field509;
		public Byte Field510;
		public Byte Field511;
#endif
        public Byte this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                46 => Field46,
                47 => Field47,
                48 => Field48,
                49 => Field49,
                50 => Field50,
                51 => Field51,
                52 => Field52,
                53 => Field53,
                54 => Field54,
                55 => Field55,
                56 => Field56,
                57 => Field57,
                58 => Field58,
                59 => Field59,
                60 => Field60,
                61 => Field61,
                62 => Field62,
                63 => Field63,
                64 => Field64,
                65 => Field65,
                66 => Field66,
                67 => Field67,
                68 => Field68,
                69 => Field69,
                70 => Field70,
                71 => Field71,
                72 => Field72,
                73 => Field73,
                74 => Field74,
                75 => Field75,
                76 => Field76,
                77 => Field77,
                78 => Field78,
                79 => Field79,
                80 => Field80,
                81 => Field81,
                82 => Field82,
                83 => Field83,
                84 => Field84,
                85 => Field85,
                86 => Field86,
                87 => Field87,
                88 => Field88,
                89 => Field89,
                90 => Field90,
                91 => Field91,
                92 => Field92,
                93 => Field93,
                94 => Field94,
                95 => Field95,
                96 => Field96,
                97 => Field97,
                98 => Field98,
                99 => Field99,
                100 => Field100,
                101 => Field101,
                102 => Field102,
                103 => Field103,
                104 => Field104,
                105 => Field105,
                106 => Field106,
                107 => Field107,
                108 => Field108,
                109 => Field109,
                110 => Field110,
                111 => Field111,
                112 => Field112,
                113 => Field113,
                114 => Field114,
                115 => Field115,
                116 => Field116,
                117 => Field117,
                118 => Field118,
                119 => Field119,
                120 => Field120,
                121 => Field121,
                122 => Field122,
                123 => Field123,
                124 => Field124,
                125 => Field125,
                126 => Field126,
                127 => Field127,
                128 => Field128,
                129 => Field129,
                130 => Field130,
                131 => Field131,
                132 => Field132,
                133 => Field133,
                134 => Field134,
                135 => Field135,
                136 => Field136,
                137 => Field137,
                138 => Field138,
                139 => Field139,
                140 => Field140,
                141 => Field141,
                142 => Field142,
                143 => Field143,
                144 => Field144,
                145 => Field145,
                146 => Field146,
                147 => Field147,
                148 => Field148,
                149 => Field149,
                150 => Field150,
                151 => Field151,
                152 => Field152,
                153 => Field153,
                154 => Field154,
                155 => Field155,
                156 => Field156,
                157 => Field157,
                158 => Field158,
                159 => Field159,
                160 => Field160,
                161 => Field161,
                162 => Field162,
                163 => Field163,
                164 => Field164,
                165 => Field165,
                166 => Field166,
                167 => Field167,
                168 => Field168,
                169 => Field169,
                170 => Field170,
                171 => Field171,
                172 => Field172,
                173 => Field173,
                174 => Field174,
                175 => Field175,
                176 => Field176,
                177 => Field177,
                178 => Field178,
                179 => Field179,
                180 => Field180,
                181 => Field181,
                182 => Field182,
                183 => Field183,
                184 => Field184,
                185 => Field185,
                186 => Field186,
                187 => Field187,
                188 => Field188,
                189 => Field189,
                190 => Field190,
                191 => Field191,
                192 => Field192,
                193 => Field193,
                194 => Field194,
                195 => Field195,
                196 => Field196,
                197 => Field197,
                198 => Field198,
                199 => Field199,
                200 => Field200,
                201 => Field201,
                202 => Field202,
                203 => Field203,
                204 => Field204,
                205 => Field205,
                206 => Field206,
                207 => Field207,
                208 => Field208,
                209 => Field209,
                210 => Field210,
                211 => Field211,
                212 => Field212,
                213 => Field213,
                214 => Field214,
                215 => Field215,
                216 => Field216,
                217 => Field217,
                218 => Field218,
                219 => Field219,
                220 => Field220,
                221 => Field221,
                222 => Field222,
                223 => Field223,
                224 => Field224,
                225 => Field225,
                226 => Field226,
                227 => Field227,
                228 => Field228,
                229 => Field229,
                230 => Field230,
                231 => Field231,
                232 => Field232,
                233 => Field233,
                234 => Field234,
                235 => Field235,
                236 => Field236,
                237 => Field237,
                238 => Field238,
                239 => Field239,
                240 => Field240,
                241 => Field241,
                242 => Field242,
                243 => Field243,
                244 => Field244,
                245 => Field245,
                246 => Field246,
                247 => Field247,
                248 => Field248,
                249 => Field249,
                250 => Field250,
                251 => Field251,
                252 => Field252,
                253 => Field253,
                254 => Field254,
                255 => Field255,
                256 => Field256,
                257 => Field257,
                258 => Field258,
                259 => Field259,
                260 => Field260,
                261 => Field261,
                262 => Field262,
                263 => Field263,
                264 => Field264,
                265 => Field265,
                266 => Field266,
                267 => Field267,
                268 => Field268,
                269 => Field269,
                270 => Field270,
                271 => Field271,
                272 => Field272,
                273 => Field273,
                274 => Field274,
                275 => Field275,
                276 => Field276,
                277 => Field277,
                278 => Field278,
                279 => Field279,
                280 => Field280,
                281 => Field281,
                282 => Field282,
                283 => Field283,
                284 => Field284,
                285 => Field285,
                286 => Field286,
                287 => Field287,
                288 => Field288,
                289 => Field289,
                290 => Field290,
                291 => Field291,
                292 => Field292,
                293 => Field293,
                294 => Field294,
                295 => Field295,
                296 => Field296,
                297 => Field297,
                298 => Field298,
                299 => Field299,
                300 => Field300,
                301 => Field301,
                302 => Field302,
                303 => Field303,
                304 => Field304,
                305 => Field305,
                306 => Field306,
                307 => Field307,
                308 => Field308,
                309 => Field309,
                310 => Field310,
                311 => Field311,
                312 => Field312,
                313 => Field313,
                314 => Field314,
                315 => Field315,
                316 => Field316,
                317 => Field317,
                318 => Field318,
                319 => Field319,
                320 => Field320,
                321 => Field321,
                322 => Field322,
                323 => Field323,
                324 => Field324,
                325 => Field325,
                326 => Field326,
                327 => Field327,
                328 => Field328,
                329 => Field329,
                330 => Field330,
                331 => Field331,
                332 => Field332,
                333 => Field333,
                334 => Field334,
                335 => Field335,
                336 => Field336,
                337 => Field337,
                338 => Field338,
                339 => Field339,
                340 => Field340,
                341 => Field341,
                342 => Field342,
                343 => Field343,
                344 => Field344,
                345 => Field345,
                346 => Field346,
                347 => Field347,
                348 => Field348,
                349 => Field349,
                350 => Field350,
                351 => Field351,
                352 => Field352,
                353 => Field353,
                354 => Field354,
                355 => Field355,
                356 => Field356,
                357 => Field357,
                358 => Field358,
                359 => Field359,
                360 => Field360,
                361 => Field361,
                362 => Field362,
                363 => Field363,
                364 => Field364,
                365 => Field365,
                366 => Field366,
                367 => Field367,
                368 => Field368,
                369 => Field369,
                370 => Field370,
                371 => Field371,
                372 => Field372,
                373 => Field373,
                374 => Field374,
                375 => Field375,
                376 => Field376,
                377 => Field377,
                378 => Field378,
                379 => Field379,
                380 => Field380,
                381 => Field381,
                382 => Field382,
                383 => Field383,
                384 => Field384,
                385 => Field385,
                386 => Field386,
                387 => Field387,
                388 => Field388,
                389 => Field389,
                390 => Field390,
                391 => Field391,
                392 => Field392,
                393 => Field393,
                394 => Field394,
                395 => Field395,
                396 => Field396,
                397 => Field397,
                398 => Field398,
                399 => Field399,
                400 => Field400,
                401 => Field401,
                402 => Field402,
                403 => Field403,
                404 => Field404,
                405 => Field405,
                406 => Field406,
                407 => Field407,
                408 => Field408,
                409 => Field409,
                410 => Field410,
                411 => Field411,
                412 => Field412,
                413 => Field413,
                414 => Field414,
                415 => Field415,
                416 => Field416,
                417 => Field417,
                418 => Field418,
                419 => Field419,
                420 => Field420,
                421 => Field421,
                422 => Field422,
                423 => Field423,
                424 => Field424,
                425 => Field425,
                426 => Field426,
                427 => Field427,
                428 => Field428,
                429 => Field429,
                430 => Field430,
                431 => Field431,
                432 => Field432,
                433 => Field433,
                434 => Field434,
                435 => Field435,
                436 => Field436,
                437 => Field437,
                438 => Field438,
                439 => Field439,
                440 => Field440,
                441 => Field441,
                442 => Field442,
                443 => Field443,
                444 => Field444,
                445 => Field445,
                446 => Field446,
                447 => Field447,
                448 => Field448,
                449 => Field449,
                450 => Field450,
                451 => Field451,
                452 => Field452,
                453 => Field453,
                454 => Field454,
                455 => Field455,
                456 => Field456,
                457 => Field457,
                458 => Field458,
                459 => Field459,
                460 => Field460,
                461 => Field461,
                462 => Field462,
                463 => Field463,
                464 => Field464,
                465 => Field465,
                466 => Field466,
                467 => Field467,
                468 => Field468,
                469 => Field469,
                470 => Field470,
                471 => Field471,
                472 => Field472,
                473 => Field473,
                474 => Field474,
                475 => Field475,
                476 => Field476,
                477 => Field477,
                478 => Field478,
                479 => Field479,
                480 => Field480,
                481 => Field481,
                482 => Field482,
                483 => Field483,
                484 => Field484,
                485 => Field485,
                486 => Field486,
                487 => Field487,
                488 => Field488,
                489 => Field489,
                490 => Field490,
                491 => Field491,
                492 => Field492,
                493 => Field493,
                494 => Field494,
                495 => Field495,
                496 => Field496,
                497 => Field497,
                498 => Field498,
                499 => Field499,
                500 => Field500,
                501 => Field501,
                502 => Field502,
                503 => Field503,
                504 => Field504,
                505 => Field505,
                506 => Field506,
                507 => Field507,
                508 => Field508,
                509 => Field509,
                510 => Field510,
                511 => Field511,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
                    case 46: Field46 = value; break;
                    case 47: Field47 = value; break;
                    case 48: Field48 = value; break;
                    case 49: Field49 = value; break;
                    case 50: Field50 = value; break;
                    case 51: Field51 = value; break;
                    case 52: Field52 = value; break;
                    case 53: Field53 = value; break;
                    case 54: Field54 = value; break;
                    case 55: Field55 = value; break;
                    case 56: Field56 = value; break;
                    case 57: Field57 = value; break;
                    case 58: Field58 = value; break;
                    case 59: Field59 = value; break;
                    case 60: Field60 = value; break;
                    case 61: Field61 = value; break;
                    case 62: Field62 = value; break;
                    case 63: Field63 = value; break;
                    case 64: Field64 = value; break;
                    case 65: Field65 = value; break;
                    case 66: Field66 = value; break;
                    case 67: Field67 = value; break;
                    case 68: Field68 = value; break;
                    case 69: Field69 = value; break;
                    case 70: Field70 = value; break;
                    case 71: Field71 = value; break;
                    case 72: Field72 = value; break;
                    case 73: Field73 = value; break;
                    case 74: Field74 = value; break;
                    case 75: Field75 = value; break;
                    case 76: Field76 = value; break;
                    case 77: Field77 = value; break;
                    case 78: Field78 = value; break;
                    case 79: Field79 = value; break;
                    case 80: Field80 = value; break;
                    case 81: Field81 = value; break;
                    case 82: Field82 = value; break;
                    case 83: Field83 = value; break;
                    case 84: Field84 = value; break;
                    case 85: Field85 = value; break;
                    case 86: Field86 = value; break;
                    case 87: Field87 = value; break;
                    case 88: Field88 = value; break;
                    case 89: Field89 = value; break;
                    case 90: Field90 = value; break;
                    case 91: Field91 = value; break;
                    case 92: Field92 = value; break;
                    case 93: Field93 = value; break;
                    case 94: Field94 = value; break;
                    case 95: Field95 = value; break;
                    case 96: Field96 = value; break;
                    case 97: Field97 = value; break;
                    case 98: Field98 = value; break;
                    case 99: Field99 = value; break;
                    case 100: Field100 = value; break;
                    case 101: Field101 = value; break;
                    case 102: Field102 = value; break;
                    case 103: Field103 = value; break;
                    case 104: Field104 = value; break;
                    case 105: Field105 = value; break;
                    case 106: Field106 = value; break;
                    case 107: Field107 = value; break;
                    case 108: Field108 = value; break;
                    case 109: Field109 = value; break;
                    case 110: Field110 = value; break;
                    case 111: Field111 = value; break;
                    case 112: Field112 = value; break;
                    case 113: Field113 = value; break;
                    case 114: Field114 = value; break;
                    case 115: Field115 = value; break;
                    case 116: Field116 = value; break;
                    case 117: Field117 = value; break;
                    case 118: Field118 = value; break;
                    case 119: Field119 = value; break;
                    case 120: Field120 = value; break;
                    case 121: Field121 = value; break;
                    case 122: Field122 = value; break;
                    case 123: Field123 = value; break;
                    case 124: Field124 = value; break;
                    case 125: Field125 = value; break;
                    case 126: Field126 = value; break;
                    case 127: Field127 = value; break;
                    case 128: Field128 = value; break;
                    case 129: Field129 = value; break;
                    case 130: Field130 = value; break;
                    case 131: Field131 = value; break;
                    case 132: Field132 = value; break;
                    case 133: Field133 = value; break;
                    case 134: Field134 = value; break;
                    case 135: Field135 = value; break;
                    case 136: Field136 = value; break;
                    case 137: Field137 = value; break;
                    case 138: Field138 = value; break;
                    case 139: Field139 = value; break;
                    case 140: Field140 = value; break;
                    case 141: Field141 = value; break;
                    case 142: Field142 = value; break;
                    case 143: Field143 = value; break;
                    case 144: Field144 = value; break;
                    case 145: Field145 = value; break;
                    case 146: Field146 = value; break;
                    case 147: Field147 = value; break;
                    case 148: Field148 = value; break;
                    case 149: Field149 = value; break;
                    case 150: Field150 = value; break;
                    case 151: Field151 = value; break;
                    case 152: Field152 = value; break;
                    case 153: Field153 = value; break;
                    case 154: Field154 = value; break;
                    case 155: Field155 = value; break;
                    case 156: Field156 = value; break;
                    case 157: Field157 = value; break;
                    case 158: Field158 = value; break;
                    case 159: Field159 = value; break;
                    case 160: Field160 = value; break;
                    case 161: Field161 = value; break;
                    case 162: Field162 = value; break;
                    case 163: Field163 = value; break;
                    case 164: Field164 = value; break;
                    case 165: Field165 = value; break;
                    case 166: Field166 = value; break;
                    case 167: Field167 = value; break;
                    case 168: Field168 = value; break;
                    case 169: Field169 = value; break;
                    case 170: Field170 = value; break;
                    case 171: Field171 = value; break;
                    case 172: Field172 = value; break;
                    case 173: Field173 = value; break;
                    case 174: Field174 = value; break;
                    case 175: Field175 = value; break;
                    case 176: Field176 = value; break;
                    case 177: Field177 = value; break;
                    case 178: Field178 = value; break;
                    case 179: Field179 = value; break;
                    case 180: Field180 = value; break;
                    case 181: Field181 = value; break;
                    case 182: Field182 = value; break;
                    case 183: Field183 = value; break;
                    case 184: Field184 = value; break;
                    case 185: Field185 = value; break;
                    case 186: Field186 = value; break;
                    case 187: Field187 = value; break;
                    case 188: Field188 = value; break;
                    case 189: Field189 = value; break;
                    case 190: Field190 = value; break;
                    case 191: Field191 = value; break;
                    case 192: Field192 = value; break;
                    case 193: Field193 = value; break;
                    case 194: Field194 = value; break;
                    case 195: Field195 = value; break;
                    case 196: Field196 = value; break;
                    case 197: Field197 = value; break;
                    case 198: Field198 = value; break;
                    case 199: Field199 = value; break;
                    case 200: Field200 = value; break;
                    case 201: Field201 = value; break;
                    case 202: Field202 = value; break;
                    case 203: Field203 = value; break;
                    case 204: Field204 = value; break;
                    case 205: Field205 = value; break;
                    case 206: Field206 = value; break;
                    case 207: Field207 = value; break;
                    case 208: Field208 = value; break;
                    case 209: Field209 = value; break;
                    case 210: Field210 = value; break;
                    case 211: Field211 = value; break;
                    case 212: Field212 = value; break;
                    case 213: Field213 = value; break;
                    case 214: Field214 = value; break;
                    case 215: Field215 = value; break;
                    case 216: Field216 = value; break;
                    case 217: Field217 = value; break;
                    case 218: Field218 = value; break;
                    case 219: Field219 = value; break;
                    case 220: Field220 = value; break;
                    case 221: Field221 = value; break;
                    case 222: Field222 = value; break;
                    case 223: Field223 = value; break;
                    case 224: Field224 = value; break;
                    case 225: Field225 = value; break;
                    case 226: Field226 = value; break;
                    case 227: Field227 = value; break;
                    case 228: Field228 = value; break;
                    case 229: Field229 = value; break;
                    case 230: Field230 = value; break;
                    case 231: Field231 = value; break;
                    case 232: Field232 = value; break;
                    case 233: Field233 = value; break;
                    case 234: Field234 = value; break;
                    case 235: Field235 = value; break;
                    case 236: Field236 = value; break;
                    case 237: Field237 = value; break;
                    case 238: Field238 = value; break;
                    case 239: Field239 = value; break;
                    case 240: Field240 = value; break;
                    case 241: Field241 = value; break;
                    case 242: Field242 = value; break;
                    case 243: Field243 = value; break;
                    case 244: Field244 = value; break;
                    case 245: Field245 = value; break;
                    case 246: Field246 = value; break;
                    case 247: Field247 = value; break;
                    case 248: Field248 = value; break;
                    case 249: Field249 = value; break;
                    case 250: Field250 = value; break;
                    case 251: Field251 = value; break;
                    case 252: Field252 = value; break;
                    case 253: Field253 = value; break;
                    case 254: Field254 = value; break;
                    case 255: Field255 = value; break;
                    case 256: Field256 = value; break;
                    case 257: Field257 = value; break;
                    case 258: Field258 = value; break;
                    case 259: Field259 = value; break;
                    case 260: Field260 = value; break;
                    case 261: Field261 = value; break;
                    case 262: Field262 = value; break;
                    case 263: Field263 = value; break;
                    case 264: Field264 = value; break;
                    case 265: Field265 = value; break;
                    case 266: Field266 = value; break;
                    case 267: Field267 = value; break;
                    case 268: Field268 = value; break;
                    case 269: Field269 = value; break;
                    case 270: Field270 = value; break;
                    case 271: Field271 = value; break;
                    case 272: Field272 = value; break;
                    case 273: Field273 = value; break;
                    case 274: Field274 = value; break;
                    case 275: Field275 = value; break;
                    case 276: Field276 = value; break;
                    case 277: Field277 = value; break;
                    case 278: Field278 = value; break;
                    case 279: Field279 = value; break;
                    case 280: Field280 = value; break;
                    case 281: Field281 = value; break;
                    case 282: Field282 = value; break;
                    case 283: Field283 = value; break;
                    case 284: Field284 = value; break;
                    case 285: Field285 = value; break;
                    case 286: Field286 = value; break;
                    case 287: Field287 = value; break;
                    case 288: Field288 = value; break;
                    case 289: Field289 = value; break;
                    case 290: Field290 = value; break;
                    case 291: Field291 = value; break;
                    case 292: Field292 = value; break;
                    case 293: Field293 = value; break;
                    case 294: Field294 = value; break;
                    case 295: Field295 = value; break;
                    case 296: Field296 = value; break;
                    case 297: Field297 = value; break;
                    case 298: Field298 = value; break;
                    case 299: Field299 = value; break;
                    case 300: Field300 = value; break;
                    case 301: Field301 = value; break;
                    case 302: Field302 = value; break;
                    case 303: Field303 = value; break;
                    case 304: Field304 = value; break;
                    case 305: Field305 = value; break;
                    case 306: Field306 = value; break;
                    case 307: Field307 = value; break;
                    case 308: Field308 = value; break;
                    case 309: Field309 = value; break;
                    case 310: Field310 = value; break;
                    case 311: Field311 = value; break;
                    case 312: Field312 = value; break;
                    case 313: Field313 = value; break;
                    case 314: Field314 = value; break;
                    case 315: Field315 = value; break;
                    case 316: Field316 = value; break;
                    case 317: Field317 = value; break;
                    case 318: Field318 = value; break;
                    case 319: Field319 = value; break;
                    case 320: Field320 = value; break;
                    case 321: Field321 = value; break;
                    case 322: Field322 = value; break;
                    case 323: Field323 = value; break;
                    case 324: Field324 = value; break;
                    case 325: Field325 = value; break;
                    case 326: Field326 = value; break;
                    case 327: Field327 = value; break;
                    case 328: Field328 = value; break;
                    case 329: Field329 = value; break;
                    case 330: Field330 = value; break;
                    case 331: Field331 = value; break;
                    case 332: Field332 = value; break;
                    case 333: Field333 = value; break;
                    case 334: Field334 = value; break;
                    case 335: Field335 = value; break;
                    case 336: Field336 = value; break;
                    case 337: Field337 = value; break;
                    case 338: Field338 = value; break;
                    case 339: Field339 = value; break;
                    case 340: Field340 = value; break;
                    case 341: Field341 = value; break;
                    case 342: Field342 = value; break;
                    case 343: Field343 = value; break;
                    case 344: Field344 = value; break;
                    case 345: Field345 = value; break;
                    case 346: Field346 = value; break;
                    case 347: Field347 = value; break;
                    case 348: Field348 = value; break;
                    case 349: Field349 = value; break;
                    case 350: Field350 = value; break;
                    case 351: Field351 = value; break;
                    case 352: Field352 = value; break;
                    case 353: Field353 = value; break;
                    case 354: Field354 = value; break;
                    case 355: Field355 = value; break;
                    case 356: Field356 = value; break;
                    case 357: Field357 = value; break;
                    case 358: Field358 = value; break;
                    case 359: Field359 = value; break;
                    case 360: Field360 = value; break;
                    case 361: Field361 = value; break;
                    case 362: Field362 = value; break;
                    case 363: Field363 = value; break;
                    case 364: Field364 = value; break;
                    case 365: Field365 = value; break;
                    case 366: Field366 = value; break;
                    case 367: Field367 = value; break;
                    case 368: Field368 = value; break;
                    case 369: Field369 = value; break;
                    case 370: Field370 = value; break;
                    case 371: Field371 = value; break;
                    case 372: Field372 = value; break;
                    case 373: Field373 = value; break;
                    case 374: Field374 = value; break;
                    case 375: Field375 = value; break;
                    case 376: Field376 = value; break;
                    case 377: Field377 = value; break;
                    case 378: Field378 = value; break;
                    case 379: Field379 = value; break;
                    case 380: Field380 = value; break;
                    case 381: Field381 = value; break;
                    case 382: Field382 = value; break;
                    case 383: Field383 = value; break;
                    case 384: Field384 = value; break;
                    case 385: Field385 = value; break;
                    case 386: Field386 = value; break;
                    case 387: Field387 = value; break;
                    case 388: Field388 = value; break;
                    case 389: Field389 = value; break;
                    case 390: Field390 = value; break;
                    case 391: Field391 = value; break;
                    case 392: Field392 = value; break;
                    case 393: Field393 = value; break;
                    case 394: Field394 = value; break;
                    case 395: Field395 = value; break;
                    case 396: Field396 = value; break;
                    case 397: Field397 = value; break;
                    case 398: Field398 = value; break;
                    case 399: Field399 = value; break;
                    case 400: Field400 = value; break;
                    case 401: Field401 = value; break;
                    case 402: Field402 = value; break;
                    case 403: Field403 = value; break;
                    case 404: Field404 = value; break;
                    case 405: Field405 = value; break;
                    case 406: Field406 = value; break;
                    case 407: Field407 = value; break;
                    case 408: Field408 = value; break;
                    case 409: Field409 = value; break;
                    case 410: Field410 = value; break;
                    case 411: Field411 = value; break;
                    case 412: Field412 = value; break;
                    case 413: Field413 = value; break;
                    case 414: Field414 = value; break;
                    case 415: Field415 = value; break;
                    case 416: Field416 = value; break;
                    case 417: Field417 = value; break;
                    case 418: Field418 = value; break;
                    case 419: Field419 = value; break;
                    case 420: Field420 = value; break;
                    case 421: Field421 = value; break;
                    case 422: Field422 = value; break;
                    case 423: Field423 = value; break;
                    case 424: Field424 = value; break;
                    case 425: Field425 = value; break;
                    case 426: Field426 = value; break;
                    case 427: Field427 = value; break;
                    case 428: Field428 = value; break;
                    case 429: Field429 = value; break;
                    case 430: Field430 = value; break;
                    case 431: Field431 = value; break;
                    case 432: Field432 = value; break;
                    case 433: Field433 = value; break;
                    case 434: Field434 = value; break;
                    case 435: Field435 = value; break;
                    case 436: Field436 = value; break;
                    case 437: Field437 = value; break;
                    case 438: Field438 = value; break;
                    case 439: Field439 = value; break;
                    case 440: Field440 = value; break;
                    case 441: Field441 = value; break;
                    case 442: Field442 = value; break;
                    case 443: Field443 = value; break;
                    case 444: Field444 = value; break;
                    case 445: Field445 = value; break;
                    case 446: Field446 = value; break;
                    case 447: Field447 = value; break;
                    case 448: Field448 = value; break;
                    case 449: Field449 = value; break;
                    case 450: Field450 = value; break;
                    case 451: Field451 = value; break;
                    case 452: Field452 = value; break;
                    case 453: Field453 = value; break;
                    case 454: Field454 = value; break;
                    case 455: Field455 = value; break;
                    case 456: Field456 = value; break;
                    case 457: Field457 = value; break;
                    case 458: Field458 = value; break;
                    case 459: Field459 = value; break;
                    case 460: Field460 = value; break;
                    case 461: Field461 = value; break;
                    case 462: Field462 = value; break;
                    case 463: Field463 = value; break;
                    case 464: Field464 = value; break;
                    case 465: Field465 = value; break;
                    case 466: Field466 = value; break;
                    case 467: Field467 = value; break;
                    case 468: Field468 = value; break;
                    case 469: Field469 = value; break;
                    case 470: Field470 = value; break;
                    case 471: Field471 = value; break;
                    case 472: Field472 = value; break;
                    case 473: Field473 = value; break;
                    case 474: Field474 = value; break;
                    case 475: Field475 = value; break;
                    case 476: Field476 = value; break;
                    case 477: Field477 = value; break;
                    case 478: Field478 = value; break;
                    case 479: Field479 = value; break;
                    case 480: Field480 = value; break;
                    case 481: Field481 = value; break;
                    case 482: Field482 = value; break;
                    case 483: Field483 = value; break;
                    case 484: Field484 = value; break;
                    case 485: Field485 = value; break;
                    case 486: Field486 = value; break;
                    case 487: Field487 = value; break;
                    case 488: Field488 = value; break;
                    case 489: Field489 = value; break;
                    case 490: Field490 = value; break;
                    case 491: Field491 = value; break;
                    case 492: Field492 = value; break;
                    case 493: Field493 = value; break;
                    case 494: Field494 = value; break;
                    case 495: Field495 = value; break;
                    case 496: Field496 = value; break;
                    case 497: Field497 = value; break;
                    case 498: Field498 = value; break;
                    case 499: Field499 = value; break;
                    case 500: Field500 = value; break;
                    case 501: Field501 = value; break;
                    case 502: Field502 = value; break;
                    case 503: Field503 = value; break;
                    case 504: Field504 = value; break;
                    case 505: Field505 = value; break;
                    case 506: Field506 = value; break;
                    case 507: Field507 = value; break;
                    case 508: Field508 = value; break;
                    case 509: Field509 = value; break;
                    case 510: Field510 = value; break;
                    case 511: Field511 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthByteArray512) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthByteArray512)other);

        public readonly bool Equals(in FixedLengthByteArray512 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthByteArray512 left, in FixedLengthByteArray512 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthByteArray512 left, in FixedLengthByteArray512 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Byte> IEnumerable<Byte>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
              yield return Field46;
              yield return Field47;
              yield return Field48;
              yield return Field49;
              yield return Field50;
              yield return Field51;
              yield return Field52;
              yield return Field53;
              yield return Field54;
              yield return Field55;
              yield return Field56;
              yield return Field57;
              yield return Field58;
              yield return Field59;
              yield return Field60;
              yield return Field61;
              yield return Field62;
              yield return Field63;
              yield return Field64;
              yield return Field65;
              yield return Field66;
              yield return Field67;
              yield return Field68;
              yield return Field69;
              yield return Field70;
              yield return Field71;
              yield return Field72;
              yield return Field73;
              yield return Field74;
              yield return Field75;
              yield return Field76;
              yield return Field77;
              yield return Field78;
              yield return Field79;
              yield return Field80;
              yield return Field81;
              yield return Field82;
              yield return Field83;
              yield return Field84;
              yield return Field85;
              yield return Field86;
              yield return Field87;
              yield return Field88;
              yield return Field89;
              yield return Field90;
              yield return Field91;
              yield return Field92;
              yield return Field93;
              yield return Field94;
              yield return Field95;
              yield return Field96;
              yield return Field97;
              yield return Field98;
              yield return Field99;
              yield return Field100;
              yield return Field101;
              yield return Field102;
              yield return Field103;
              yield return Field104;
              yield return Field105;
              yield return Field106;
              yield return Field107;
              yield return Field108;
              yield return Field109;
              yield return Field110;
              yield return Field111;
              yield return Field112;
              yield return Field113;
              yield return Field114;
              yield return Field115;
              yield return Field116;
              yield return Field117;
              yield return Field118;
              yield return Field119;
              yield return Field120;
              yield return Field121;
              yield return Field122;
              yield return Field123;
              yield return Field124;
              yield return Field125;
              yield return Field126;
              yield return Field127;
              yield return Field128;
              yield return Field129;
              yield return Field130;
              yield return Field131;
              yield return Field132;
              yield return Field133;
              yield return Field134;
              yield return Field135;
              yield return Field136;
              yield return Field137;
              yield return Field138;
              yield return Field139;
              yield return Field140;
              yield return Field141;
              yield return Field142;
              yield return Field143;
              yield return Field144;
              yield return Field145;
              yield return Field146;
              yield return Field147;
              yield return Field148;
              yield return Field149;
              yield return Field150;
              yield return Field151;
              yield return Field152;
              yield return Field153;
              yield return Field154;
              yield return Field155;
              yield return Field156;
              yield return Field157;
              yield return Field158;
              yield return Field159;
              yield return Field160;
              yield return Field161;
              yield return Field162;
              yield return Field163;
              yield return Field164;
              yield return Field165;
              yield return Field166;
              yield return Field167;
              yield return Field168;
              yield return Field169;
              yield return Field170;
              yield return Field171;
              yield return Field172;
              yield return Field173;
              yield return Field174;
              yield return Field175;
              yield return Field176;
              yield return Field177;
              yield return Field178;
              yield return Field179;
              yield return Field180;
              yield return Field181;
              yield return Field182;
              yield return Field183;
              yield return Field184;
              yield return Field185;
              yield return Field186;
              yield return Field187;
              yield return Field188;
              yield return Field189;
              yield return Field190;
              yield return Field191;
              yield return Field192;
              yield return Field193;
              yield return Field194;
              yield return Field195;
              yield return Field196;
              yield return Field197;
              yield return Field198;
              yield return Field199;
              yield return Field200;
              yield return Field201;
              yield return Field202;
              yield return Field203;
              yield return Field204;
              yield return Field205;
              yield return Field206;
              yield return Field207;
              yield return Field208;
              yield return Field209;
              yield return Field210;
              yield return Field211;
              yield return Field212;
              yield return Field213;
              yield return Field214;
              yield return Field215;
              yield return Field216;
              yield return Field217;
              yield return Field218;
              yield return Field219;
              yield return Field220;
              yield return Field221;
              yield return Field222;
              yield return Field223;
              yield return Field224;
              yield return Field225;
              yield return Field226;
              yield return Field227;
              yield return Field228;
              yield return Field229;
              yield return Field230;
              yield return Field231;
              yield return Field232;
              yield return Field233;
              yield return Field234;
              yield return Field235;
              yield return Field236;
              yield return Field237;
              yield return Field238;
              yield return Field239;
              yield return Field240;
              yield return Field241;
              yield return Field242;
              yield return Field243;
              yield return Field244;
              yield return Field245;
              yield return Field246;
              yield return Field247;
              yield return Field248;
              yield return Field249;
              yield return Field250;
              yield return Field251;
              yield return Field252;
              yield return Field253;
              yield return Field254;
              yield return Field255;
              yield return Field256;
              yield return Field257;
              yield return Field258;
              yield return Field259;
              yield return Field260;
              yield return Field261;
              yield return Field262;
              yield return Field263;
              yield return Field264;
              yield return Field265;
              yield return Field266;
              yield return Field267;
              yield return Field268;
              yield return Field269;
              yield return Field270;
              yield return Field271;
              yield return Field272;
              yield return Field273;
              yield return Field274;
              yield return Field275;
              yield return Field276;
              yield return Field277;
              yield return Field278;
              yield return Field279;
              yield return Field280;
              yield return Field281;
              yield return Field282;
              yield return Field283;
              yield return Field284;
              yield return Field285;
              yield return Field286;
              yield return Field287;
              yield return Field288;
              yield return Field289;
              yield return Field290;
              yield return Field291;
              yield return Field292;
              yield return Field293;
              yield return Field294;
              yield return Field295;
              yield return Field296;
              yield return Field297;
              yield return Field298;
              yield return Field299;
              yield return Field300;
              yield return Field301;
              yield return Field302;
              yield return Field303;
              yield return Field304;
              yield return Field305;
              yield return Field306;
              yield return Field307;
              yield return Field308;
              yield return Field309;
              yield return Field310;
              yield return Field311;
              yield return Field312;
              yield return Field313;
              yield return Field314;
              yield return Field315;
              yield return Field316;
              yield return Field317;
              yield return Field318;
              yield return Field319;
              yield return Field320;
              yield return Field321;
              yield return Field322;
              yield return Field323;
              yield return Field324;
              yield return Field325;
              yield return Field326;
              yield return Field327;
              yield return Field328;
              yield return Field329;
              yield return Field330;
              yield return Field331;
              yield return Field332;
              yield return Field333;
              yield return Field334;
              yield return Field335;
              yield return Field336;
              yield return Field337;
              yield return Field338;
              yield return Field339;
              yield return Field340;
              yield return Field341;
              yield return Field342;
              yield return Field343;
              yield return Field344;
              yield return Field345;
              yield return Field346;
              yield return Field347;
              yield return Field348;
              yield return Field349;
              yield return Field350;
              yield return Field351;
              yield return Field352;
              yield return Field353;
              yield return Field354;
              yield return Field355;
              yield return Field356;
              yield return Field357;
              yield return Field358;
              yield return Field359;
              yield return Field360;
              yield return Field361;
              yield return Field362;
              yield return Field363;
              yield return Field364;
              yield return Field365;
              yield return Field366;
              yield return Field367;
              yield return Field368;
              yield return Field369;
              yield return Field370;
              yield return Field371;
              yield return Field372;
              yield return Field373;
              yield return Field374;
              yield return Field375;
              yield return Field376;
              yield return Field377;
              yield return Field378;
              yield return Field379;
              yield return Field380;
              yield return Field381;
              yield return Field382;
              yield return Field383;
              yield return Field384;
              yield return Field385;
              yield return Field386;
              yield return Field387;
              yield return Field388;
              yield return Field389;
              yield return Field390;
              yield return Field391;
              yield return Field392;
              yield return Field393;
              yield return Field394;
              yield return Field395;
              yield return Field396;
              yield return Field397;
              yield return Field398;
              yield return Field399;
              yield return Field400;
              yield return Field401;
              yield return Field402;
              yield return Field403;
              yield return Field404;
              yield return Field405;
              yield return Field406;
              yield return Field407;
              yield return Field408;
              yield return Field409;
              yield return Field410;
              yield return Field411;
              yield return Field412;
              yield return Field413;
              yield return Field414;
              yield return Field415;
              yield return Field416;
              yield return Field417;
              yield return Field418;
              yield return Field419;
              yield return Field420;
              yield return Field421;
              yield return Field422;
              yield return Field423;
              yield return Field424;
              yield return Field425;
              yield return Field426;
              yield return Field427;
              yield return Field428;
              yield return Field429;
              yield return Field430;
              yield return Field431;
              yield return Field432;
              yield return Field433;
              yield return Field434;
              yield return Field435;
              yield return Field436;
              yield return Field437;
              yield return Field438;
              yield return Field439;
              yield return Field440;
              yield return Field441;
              yield return Field442;
              yield return Field443;
              yield return Field444;
              yield return Field445;
              yield return Field446;
              yield return Field447;
              yield return Field448;
              yield return Field449;
              yield return Field450;
              yield return Field451;
              yield return Field452;
              yield return Field453;
              yield return Field454;
              yield return Field455;
              yield return Field456;
              yield return Field457;
              yield return Field458;
              yield return Field459;
              yield return Field460;
              yield return Field461;
              yield return Field462;
              yield return Field463;
              yield return Field464;
              yield return Field465;
              yield return Field466;
              yield return Field467;
              yield return Field468;
              yield return Field469;
              yield return Field470;
              yield return Field471;
              yield return Field472;
              yield return Field473;
              yield return Field474;
              yield return Field475;
              yield return Field476;
              yield return Field477;
              yield return Field478;
              yield return Field479;
              yield return Field480;
              yield return Field481;
              yield return Field482;
              yield return Field483;
              yield return Field484;
              yield return Field485;
              yield return Field486;
              yield return Field487;
              yield return Field488;
              yield return Field489;
              yield return Field490;
              yield return Field491;
              yield return Field492;
              yield return Field493;
              yield return Field494;
              yield return Field495;
              yield return Field496;
              yield return Field497;
              yield return Field498;
              yield return Field499;
              yield return Field500;
              yield return Field501;
              yield return Field502;
              yield return Field503;
              yield return Field504;
              yield return Field505;
              yield return Field506;
              yield return Field507;
              yield return Field508;
              yield return Field509;
              yield return Field510;
              yield return Field511;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Byte>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Byte>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Byte>(in FixedLengthByteArray512 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Byte> AsSpan(this ref FixedLengthByteArray512 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Byte> AsReadOnlySpan(this in FixedLengthByteArray512 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Byte At(this ref FixedLengthByteArray512 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
                case 46: return ref array.Field46;
                case 47: return ref array.Field47;
                case 48: return ref array.Field48;
                case 49: return ref array.Field49;
                case 50: return ref array.Field50;
                case 51: return ref array.Field51;
                case 52: return ref array.Field52;
                case 53: return ref array.Field53;
                case 54: return ref array.Field54;
                case 55: return ref array.Field55;
                case 56: return ref array.Field56;
                case 57: return ref array.Field57;
                case 58: return ref array.Field58;
                case 59: return ref array.Field59;
                case 60: return ref array.Field60;
                case 61: return ref array.Field61;
                case 62: return ref array.Field62;
                case 63: return ref array.Field63;
                case 64: return ref array.Field64;
                case 65: return ref array.Field65;
                case 66: return ref array.Field66;
                case 67: return ref array.Field67;
                case 68: return ref array.Field68;
                case 69: return ref array.Field69;
                case 70: return ref array.Field70;
                case 71: return ref array.Field71;
                case 72: return ref array.Field72;
                case 73: return ref array.Field73;
                case 74: return ref array.Field74;
                case 75: return ref array.Field75;
                case 76: return ref array.Field76;
                case 77: return ref array.Field77;
                case 78: return ref array.Field78;
                case 79: return ref array.Field79;
                case 80: return ref array.Field80;
                case 81: return ref array.Field81;
                case 82: return ref array.Field82;
                case 83: return ref array.Field83;
                case 84: return ref array.Field84;
                case 85: return ref array.Field85;
                case 86: return ref array.Field86;
                case 87: return ref array.Field87;
                case 88: return ref array.Field88;
                case 89: return ref array.Field89;
                case 90: return ref array.Field90;
                case 91: return ref array.Field91;
                case 92: return ref array.Field92;
                case 93: return ref array.Field93;
                case 94: return ref array.Field94;
                case 95: return ref array.Field95;
                case 96: return ref array.Field96;
                case 97: return ref array.Field97;
                case 98: return ref array.Field98;
                case 99: return ref array.Field99;
                case 100: return ref array.Field100;
                case 101: return ref array.Field101;
                case 102: return ref array.Field102;
                case 103: return ref array.Field103;
                case 104: return ref array.Field104;
                case 105: return ref array.Field105;
                case 106: return ref array.Field106;
                case 107: return ref array.Field107;
                case 108: return ref array.Field108;
                case 109: return ref array.Field109;
                case 110: return ref array.Field110;
                case 111: return ref array.Field111;
                case 112: return ref array.Field112;
                case 113: return ref array.Field113;
                case 114: return ref array.Field114;
                case 115: return ref array.Field115;
                case 116: return ref array.Field116;
                case 117: return ref array.Field117;
                case 118: return ref array.Field118;
                case 119: return ref array.Field119;
                case 120: return ref array.Field120;
                case 121: return ref array.Field121;
                case 122: return ref array.Field122;
                case 123: return ref array.Field123;
                case 124: return ref array.Field124;
                case 125: return ref array.Field125;
                case 126: return ref array.Field126;
                case 127: return ref array.Field127;
                case 128: return ref array.Field128;
                case 129: return ref array.Field129;
                case 130: return ref array.Field130;
                case 131: return ref array.Field131;
                case 132: return ref array.Field132;
                case 133: return ref array.Field133;
                case 134: return ref array.Field134;
                case 135: return ref array.Field135;
                case 136: return ref array.Field136;
                case 137: return ref array.Field137;
                case 138: return ref array.Field138;
                case 139: return ref array.Field139;
                case 140: return ref array.Field140;
                case 141: return ref array.Field141;
                case 142: return ref array.Field142;
                case 143: return ref array.Field143;
                case 144: return ref array.Field144;
                case 145: return ref array.Field145;
                case 146: return ref array.Field146;
                case 147: return ref array.Field147;
                case 148: return ref array.Field148;
                case 149: return ref array.Field149;
                case 150: return ref array.Field150;
                case 151: return ref array.Field151;
                case 152: return ref array.Field152;
                case 153: return ref array.Field153;
                case 154: return ref array.Field154;
                case 155: return ref array.Field155;
                case 156: return ref array.Field156;
                case 157: return ref array.Field157;
                case 158: return ref array.Field158;
                case 159: return ref array.Field159;
                case 160: return ref array.Field160;
                case 161: return ref array.Field161;
                case 162: return ref array.Field162;
                case 163: return ref array.Field163;
                case 164: return ref array.Field164;
                case 165: return ref array.Field165;
                case 166: return ref array.Field166;
                case 167: return ref array.Field167;
                case 168: return ref array.Field168;
                case 169: return ref array.Field169;
                case 170: return ref array.Field170;
                case 171: return ref array.Field171;
                case 172: return ref array.Field172;
                case 173: return ref array.Field173;
                case 174: return ref array.Field174;
                case 175: return ref array.Field175;
                case 176: return ref array.Field176;
                case 177: return ref array.Field177;
                case 178: return ref array.Field178;
                case 179: return ref array.Field179;
                case 180: return ref array.Field180;
                case 181: return ref array.Field181;
                case 182: return ref array.Field182;
                case 183: return ref array.Field183;
                case 184: return ref array.Field184;
                case 185: return ref array.Field185;
                case 186: return ref array.Field186;
                case 187: return ref array.Field187;
                case 188: return ref array.Field188;
                case 189: return ref array.Field189;
                case 190: return ref array.Field190;
                case 191: return ref array.Field191;
                case 192: return ref array.Field192;
                case 193: return ref array.Field193;
                case 194: return ref array.Field194;
                case 195: return ref array.Field195;
                case 196: return ref array.Field196;
                case 197: return ref array.Field197;
                case 198: return ref array.Field198;
                case 199: return ref array.Field199;
                case 200: return ref array.Field200;
                case 201: return ref array.Field201;
                case 202: return ref array.Field202;
                case 203: return ref array.Field203;
                case 204: return ref array.Field204;
                case 205: return ref array.Field205;
                case 206: return ref array.Field206;
                case 207: return ref array.Field207;
                case 208: return ref array.Field208;
                case 209: return ref array.Field209;
                case 210: return ref array.Field210;
                case 211: return ref array.Field211;
                case 212: return ref array.Field212;
                case 213: return ref array.Field213;
                case 214: return ref array.Field214;
                case 215: return ref array.Field215;
                case 216: return ref array.Field216;
                case 217: return ref array.Field217;
                case 218: return ref array.Field218;
                case 219: return ref array.Field219;
                case 220: return ref array.Field220;
                case 221: return ref array.Field221;
                case 222: return ref array.Field222;
                case 223: return ref array.Field223;
                case 224: return ref array.Field224;
                case 225: return ref array.Field225;
                case 226: return ref array.Field226;
                case 227: return ref array.Field227;
                case 228: return ref array.Field228;
                case 229: return ref array.Field229;
                case 230: return ref array.Field230;
                case 231: return ref array.Field231;
                case 232: return ref array.Field232;
                case 233: return ref array.Field233;
                case 234: return ref array.Field234;
                case 235: return ref array.Field235;
                case 236: return ref array.Field236;
                case 237: return ref array.Field237;
                case 238: return ref array.Field238;
                case 239: return ref array.Field239;
                case 240: return ref array.Field240;
                case 241: return ref array.Field241;
                case 242: return ref array.Field242;
                case 243: return ref array.Field243;
                case 244: return ref array.Field244;
                case 245: return ref array.Field245;
                case 246: return ref array.Field246;
                case 247: return ref array.Field247;
                case 248: return ref array.Field248;
                case 249: return ref array.Field249;
                case 250: return ref array.Field250;
                case 251: return ref array.Field251;
                case 252: return ref array.Field252;
                case 253: return ref array.Field253;
                case 254: return ref array.Field254;
                case 255: return ref array.Field255;
                case 256: return ref array.Field256;
                case 257: return ref array.Field257;
                case 258: return ref array.Field258;
                case 259: return ref array.Field259;
                case 260: return ref array.Field260;
                case 261: return ref array.Field261;
                case 262: return ref array.Field262;
                case 263: return ref array.Field263;
                case 264: return ref array.Field264;
                case 265: return ref array.Field265;
                case 266: return ref array.Field266;
                case 267: return ref array.Field267;
                case 268: return ref array.Field268;
                case 269: return ref array.Field269;
                case 270: return ref array.Field270;
                case 271: return ref array.Field271;
                case 272: return ref array.Field272;
                case 273: return ref array.Field273;
                case 274: return ref array.Field274;
                case 275: return ref array.Field275;
                case 276: return ref array.Field276;
                case 277: return ref array.Field277;
                case 278: return ref array.Field278;
                case 279: return ref array.Field279;
                case 280: return ref array.Field280;
                case 281: return ref array.Field281;
                case 282: return ref array.Field282;
                case 283: return ref array.Field283;
                case 284: return ref array.Field284;
                case 285: return ref array.Field285;
                case 286: return ref array.Field286;
                case 287: return ref array.Field287;
                case 288: return ref array.Field288;
                case 289: return ref array.Field289;
                case 290: return ref array.Field290;
                case 291: return ref array.Field291;
                case 292: return ref array.Field292;
                case 293: return ref array.Field293;
                case 294: return ref array.Field294;
                case 295: return ref array.Field295;
                case 296: return ref array.Field296;
                case 297: return ref array.Field297;
                case 298: return ref array.Field298;
                case 299: return ref array.Field299;
                case 300: return ref array.Field300;
                case 301: return ref array.Field301;
                case 302: return ref array.Field302;
                case 303: return ref array.Field303;
                case 304: return ref array.Field304;
                case 305: return ref array.Field305;
                case 306: return ref array.Field306;
                case 307: return ref array.Field307;
                case 308: return ref array.Field308;
                case 309: return ref array.Field309;
                case 310: return ref array.Field310;
                case 311: return ref array.Field311;
                case 312: return ref array.Field312;
                case 313: return ref array.Field313;
                case 314: return ref array.Field314;
                case 315: return ref array.Field315;
                case 316: return ref array.Field316;
                case 317: return ref array.Field317;
                case 318: return ref array.Field318;
                case 319: return ref array.Field319;
                case 320: return ref array.Field320;
                case 321: return ref array.Field321;
                case 322: return ref array.Field322;
                case 323: return ref array.Field323;
                case 324: return ref array.Field324;
                case 325: return ref array.Field325;
                case 326: return ref array.Field326;
                case 327: return ref array.Field327;
                case 328: return ref array.Field328;
                case 329: return ref array.Field329;
                case 330: return ref array.Field330;
                case 331: return ref array.Field331;
                case 332: return ref array.Field332;
                case 333: return ref array.Field333;
                case 334: return ref array.Field334;
                case 335: return ref array.Field335;
                case 336: return ref array.Field336;
                case 337: return ref array.Field337;
                case 338: return ref array.Field338;
                case 339: return ref array.Field339;
                case 340: return ref array.Field340;
                case 341: return ref array.Field341;
                case 342: return ref array.Field342;
                case 343: return ref array.Field343;
                case 344: return ref array.Field344;
                case 345: return ref array.Field345;
                case 346: return ref array.Field346;
                case 347: return ref array.Field347;
                case 348: return ref array.Field348;
                case 349: return ref array.Field349;
                case 350: return ref array.Field350;
                case 351: return ref array.Field351;
                case 352: return ref array.Field352;
                case 353: return ref array.Field353;
                case 354: return ref array.Field354;
                case 355: return ref array.Field355;
                case 356: return ref array.Field356;
                case 357: return ref array.Field357;
                case 358: return ref array.Field358;
                case 359: return ref array.Field359;
                case 360: return ref array.Field360;
                case 361: return ref array.Field361;
                case 362: return ref array.Field362;
                case 363: return ref array.Field363;
                case 364: return ref array.Field364;
                case 365: return ref array.Field365;
                case 366: return ref array.Field366;
                case 367: return ref array.Field367;
                case 368: return ref array.Field368;
                case 369: return ref array.Field369;
                case 370: return ref array.Field370;
                case 371: return ref array.Field371;
                case 372: return ref array.Field372;
                case 373: return ref array.Field373;
                case 374: return ref array.Field374;
                case 375: return ref array.Field375;
                case 376: return ref array.Field376;
                case 377: return ref array.Field377;
                case 378: return ref array.Field378;
                case 379: return ref array.Field379;
                case 380: return ref array.Field380;
                case 381: return ref array.Field381;
                case 382: return ref array.Field382;
                case 383: return ref array.Field383;
                case 384: return ref array.Field384;
                case 385: return ref array.Field385;
                case 386: return ref array.Field386;
                case 387: return ref array.Field387;
                case 388: return ref array.Field388;
                case 389: return ref array.Field389;
                case 390: return ref array.Field390;
                case 391: return ref array.Field391;
                case 392: return ref array.Field392;
                case 393: return ref array.Field393;
                case 394: return ref array.Field394;
                case 395: return ref array.Field395;
                case 396: return ref array.Field396;
                case 397: return ref array.Field397;
                case 398: return ref array.Field398;
                case 399: return ref array.Field399;
                case 400: return ref array.Field400;
                case 401: return ref array.Field401;
                case 402: return ref array.Field402;
                case 403: return ref array.Field403;
                case 404: return ref array.Field404;
                case 405: return ref array.Field405;
                case 406: return ref array.Field406;
                case 407: return ref array.Field407;
                case 408: return ref array.Field408;
                case 409: return ref array.Field409;
                case 410: return ref array.Field410;
                case 411: return ref array.Field411;
                case 412: return ref array.Field412;
                case 413: return ref array.Field413;
                case 414: return ref array.Field414;
                case 415: return ref array.Field415;
                case 416: return ref array.Field416;
                case 417: return ref array.Field417;
                case 418: return ref array.Field418;
                case 419: return ref array.Field419;
                case 420: return ref array.Field420;
                case 421: return ref array.Field421;
                case 422: return ref array.Field422;
                case 423: return ref array.Field423;
                case 424: return ref array.Field424;
                case 425: return ref array.Field425;
                case 426: return ref array.Field426;
                case 427: return ref array.Field427;
                case 428: return ref array.Field428;
                case 429: return ref array.Field429;
                case 430: return ref array.Field430;
                case 431: return ref array.Field431;
                case 432: return ref array.Field432;
                case 433: return ref array.Field433;
                case 434: return ref array.Field434;
                case 435: return ref array.Field435;
                case 436: return ref array.Field436;
                case 437: return ref array.Field437;
                case 438: return ref array.Field438;
                case 439: return ref array.Field439;
                case 440: return ref array.Field440;
                case 441: return ref array.Field441;
                case 442: return ref array.Field442;
                case 443: return ref array.Field443;
                case 444: return ref array.Field444;
                case 445: return ref array.Field445;
                case 446: return ref array.Field446;
                case 447: return ref array.Field447;
                case 448: return ref array.Field448;
                case 449: return ref array.Field449;
                case 450: return ref array.Field450;
                case 451: return ref array.Field451;
                case 452: return ref array.Field452;
                case 453: return ref array.Field453;
                case 454: return ref array.Field454;
                case 455: return ref array.Field455;
                case 456: return ref array.Field456;
                case 457: return ref array.Field457;
                case 458: return ref array.Field458;
                case 459: return ref array.Field459;
                case 460: return ref array.Field460;
                case 461: return ref array.Field461;
                case 462: return ref array.Field462;
                case 463: return ref array.Field463;
                case 464: return ref array.Field464;
                case 465: return ref array.Field465;
                case 466: return ref array.Field466;
                case 467: return ref array.Field467;
                case 468: return ref array.Field468;
                case 469: return ref array.Field469;
                case 470: return ref array.Field470;
                case 471: return ref array.Field471;
                case 472: return ref array.Field472;
                case 473: return ref array.Field473;
                case 474: return ref array.Field474;
                case 475: return ref array.Field475;
                case 476: return ref array.Field476;
                case 477: return ref array.Field477;
                case 478: return ref array.Field478;
                case 479: return ref array.Field479;
                case 480: return ref array.Field480;
                case 481: return ref array.Field481;
                case 482: return ref array.Field482;
                case 483: return ref array.Field483;
                case 484: return ref array.Field484;
                case 485: return ref array.Field485;
                case 486: return ref array.Field486;
                case 487: return ref array.Field487;
                case 488: return ref array.Field488;
                case 489: return ref array.Field489;
                case 490: return ref array.Field490;
                case 491: return ref array.Field491;
                case 492: return ref array.Field492;
                case 493: return ref array.Field493;
                case 494: return ref array.Field494;
                case 495: return ref array.Field495;
                case 496: return ref array.Field496;
                case 497: return ref array.Field497;
                case 498: return ref array.Field498;
                case 499: return ref array.Field499;
                case 500: return ref array.Field500;
                case 501: return ref array.Field501;
                case 502: return ref array.Field502;
                case 503: return ref array.Field503;
                case 504: return ref array.Field504;
                case 505: return ref array.Field505;
                case 506: return ref array.Field506;
                case 507: return ref array.Field507;
                case 508: return ref array.Field508;
                case 509: return ref array.Field509;
                case 510: return ref array.Field510;
                case 511: return ref array.Field511;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthByteArray512 array1, in FixedLengthByteArray512 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthByteArray512 array, Byte[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthByteArray512 array1, in FixedLengthByteArray512 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthByteArray512 array, Byte value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Byte At(this ref FixedLengthByteArray512 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthByteArray512 array1, in FixedLengthByteArray512 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthByteArray512 array, Span<Byte> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthByteArray512 array1, in FixedLengthByteArray512 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthByteArray512 array, Byte value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 2 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray2
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray2 _Zero = default;
		public static ref readonly FixedLengthCharArray2 Zero => ref _Zero;

		public const int ConstLength = 2;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray2(
			Char field0
			, Char field1
		)
		{
			Field0 = field0;
			Field1 = field1;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray2) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray2)other);

        public readonly bool Equals(in FixedLengthCharArray2 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray2 left, in FixedLengthCharArray2 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray2 left, in FixedLengthCharArray2 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray2 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray2 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray2 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray2 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray2 array1, in FixedLengthCharArray2 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray2 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray2 array1, in FixedLengthCharArray2 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray2 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray2 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray2 array1, in FixedLengthCharArray2 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray2 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray2 array1, in FixedLengthCharArray2 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray2 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 3 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray3
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray3 _Zero = default;
		public static ref readonly FixedLengthCharArray3 Zero => ref _Zero;

		public const int ConstLength = 3;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray3(
			Char field0
			, Char field1
			, Char field2
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray3) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray3)other);

        public readonly bool Equals(in FixedLengthCharArray3 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray3 left, in FixedLengthCharArray3 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray3 left, in FixedLengthCharArray3 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray3 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray3 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray3 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray3 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray3 array1, in FixedLengthCharArray3 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray3 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray3 array1, in FixedLengthCharArray3 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray3 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray3 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray3 array1, in FixedLengthCharArray3 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray3 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray3 array1, in FixedLengthCharArray3 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray3 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 4 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray4
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray4 _Zero = default;
		public static ref readonly FixedLengthCharArray4 Zero => ref _Zero;

		public const int ConstLength = 4;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray4(
			Char field0
			, Char field1
			, Char field2
			, Char field3
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray4) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray4)other);

        public readonly bool Equals(in FixedLengthCharArray4 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray4 left, in FixedLengthCharArray4 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray4 left, in FixedLengthCharArray4 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray4 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray4 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray4 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray4 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray4 array1, in FixedLengthCharArray4 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray4 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray4 array1, in FixedLengthCharArray4 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray4 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray4 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray4 array1, in FixedLengthCharArray4 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray4 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray4 array1, in FixedLengthCharArray4 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray4 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 5 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray5
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray5 _Zero = default;
		public static ref readonly FixedLengthCharArray5 Zero => ref _Zero;

		public const int ConstLength = 5;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray5(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray5) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray5)other);

        public readonly bool Equals(in FixedLengthCharArray5 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray5 left, in FixedLengthCharArray5 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray5 left, in FixedLengthCharArray5 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray5 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray5 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray5 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray5 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray5 array1, in FixedLengthCharArray5 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray5 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray5 array1, in FixedLengthCharArray5 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray5 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray5 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray5 array1, in FixedLengthCharArray5 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray5 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray5 array1, in FixedLengthCharArray5 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray5 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 6 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray6
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray6 _Zero = default;
		public static ref readonly FixedLengthCharArray6 Zero => ref _Zero;

		public const int ConstLength = 6;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray6(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray6) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray6)other);

        public readonly bool Equals(in FixedLengthCharArray6 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray6 left, in FixedLengthCharArray6 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray6 left, in FixedLengthCharArray6 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray6 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray6 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray6 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray6 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray6 array1, in FixedLengthCharArray6 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray6 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray6 array1, in FixedLengthCharArray6 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray6 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray6 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray6 array1, in FixedLengthCharArray6 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray6 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray6 array1, in FixedLengthCharArray6 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray6 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 7 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray7
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray7 _Zero = default;
		public static ref readonly FixedLengthCharArray7 Zero => ref _Zero;

		public const int ConstLength = 7;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray7(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray7) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray7)other);

        public readonly bool Equals(in FixedLengthCharArray7 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray7 left, in FixedLengthCharArray7 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray7 left, in FixedLengthCharArray7 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray7 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray7 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray7 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray7 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray7 array1, in FixedLengthCharArray7 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray7 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray7 array1, in FixedLengthCharArray7 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray7 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray7 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray7 array1, in FixedLengthCharArray7 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray7 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray7 array1, in FixedLengthCharArray7 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray7 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 8 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray8
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray8 _Zero = default;
		public static ref readonly FixedLengthCharArray8 Zero => ref _Zero;

		public const int ConstLength = 8;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray8(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray8) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray8)other);

        public readonly bool Equals(in FixedLengthCharArray8 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray8 left, in FixedLengthCharArray8 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray8 left, in FixedLengthCharArray8 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray8 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray8 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray8 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray8 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray8 array1, in FixedLengthCharArray8 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray8 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray8 array1, in FixedLengthCharArray8 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray8 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray8 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray8 array1, in FixedLengthCharArray8 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray8 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray8 array1, in FixedLengthCharArray8 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray8 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 9 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray9
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray9 _Zero = default;
		public static ref readonly FixedLengthCharArray9 Zero => ref _Zero;

		public const int ConstLength = 9;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray9(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray9) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray9)other);

        public readonly bool Equals(in FixedLengthCharArray9 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray9 left, in FixedLengthCharArray9 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray9 left, in FixedLengthCharArray9 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray9 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray9 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray9 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray9 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray9 array1, in FixedLengthCharArray9 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray9 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray9 array1, in FixedLengthCharArray9 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray9 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray9 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray9 array1, in FixedLengthCharArray9 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray9 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray9 array1, in FixedLengthCharArray9 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray9 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 10 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray10
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray10 _Zero = default;
		public static ref readonly FixedLengthCharArray10 Zero => ref _Zero;

		public const int ConstLength = 10;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray10(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray10) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray10)other);

        public readonly bool Equals(in FixedLengthCharArray10 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray10 left, in FixedLengthCharArray10 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray10 left, in FixedLengthCharArray10 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray10 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray10 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray10 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray10 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray10 array1, in FixedLengthCharArray10 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray10 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray10 array1, in FixedLengthCharArray10 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray10 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray10 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray10 array1, in FixedLengthCharArray10 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray10 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray10 array1, in FixedLengthCharArray10 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray10 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 11 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray11
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray11 _Zero = default;
		public static ref readonly FixedLengthCharArray11 Zero => ref _Zero;

		public const int ConstLength = 11;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray11(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray11) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray11)other);

        public readonly bool Equals(in FixedLengthCharArray11 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray11 left, in FixedLengthCharArray11 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray11 left, in FixedLengthCharArray11 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray11 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray11 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray11 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray11 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray11 array1, in FixedLengthCharArray11 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray11 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray11 array1, in FixedLengthCharArray11 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray11 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray11 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray11 array1, in FixedLengthCharArray11 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray11 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray11 array1, in FixedLengthCharArray11 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray11 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 12 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray12
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray12 _Zero = default;
		public static ref readonly FixedLengthCharArray12 Zero => ref _Zero;

		public const int ConstLength = 12;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray12(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray12) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray12)other);

        public readonly bool Equals(in FixedLengthCharArray12 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray12 left, in FixedLengthCharArray12 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray12 left, in FixedLengthCharArray12 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray12 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray12 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray12 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray12 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray12 array1, in FixedLengthCharArray12 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray12 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray12 array1, in FixedLengthCharArray12 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray12 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray12 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray12 array1, in FixedLengthCharArray12 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray12 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray12 array1, in FixedLengthCharArray12 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray12 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 13 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray13
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray13 _Zero = default;
		public static ref readonly FixedLengthCharArray13 Zero => ref _Zero;

		public const int ConstLength = 13;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray13(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray13) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray13)other);

        public readonly bool Equals(in FixedLengthCharArray13 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray13 left, in FixedLengthCharArray13 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray13 left, in FixedLengthCharArray13 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray13 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray13 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray13 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray13 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray13 array1, in FixedLengthCharArray13 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray13 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray13 array1, in FixedLengthCharArray13 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray13 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray13 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray13 array1, in FixedLengthCharArray13 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray13 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray13 array1, in FixedLengthCharArray13 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray13 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 14 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray14
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray14 _Zero = default;
		public static ref readonly FixedLengthCharArray14 Zero => ref _Zero;

		public const int ConstLength = 14;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray14(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray14) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray14)other);

        public readonly bool Equals(in FixedLengthCharArray14 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray14 left, in FixedLengthCharArray14 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray14 left, in FixedLengthCharArray14 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray14 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray14 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray14 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray14 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray14 array1, in FixedLengthCharArray14 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray14 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray14 array1, in FixedLengthCharArray14 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray14 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray14 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray14 array1, in FixedLengthCharArray14 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray14 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray14 array1, in FixedLengthCharArray14 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray14 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 15 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray15
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray15 _Zero = default;
		public static ref readonly FixedLengthCharArray15 Zero => ref _Zero;

		public const int ConstLength = 15;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray15(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray15) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray15)other);

        public readonly bool Equals(in FixedLengthCharArray15 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray15 left, in FixedLengthCharArray15 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray15 left, in FixedLengthCharArray15 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray15 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray15 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray15 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray15 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray15 array1, in FixedLengthCharArray15 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray15 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray15 array1, in FixedLengthCharArray15 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray15 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray15 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray15 array1, in FixedLengthCharArray15 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray15 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray15 array1, in FixedLengthCharArray15 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray15 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 16 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray16
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray16 _Zero = default;
		public static ref readonly FixedLengthCharArray16 Zero => ref _Zero;

		public const int ConstLength = 16;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray16(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray16) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray16)other);

        public readonly bool Equals(in FixedLengthCharArray16 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray16 left, in FixedLengthCharArray16 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray16 left, in FixedLengthCharArray16 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray16 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray16 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray16 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray16 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray16 array1, in FixedLengthCharArray16 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray16 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray16 array1, in FixedLengthCharArray16 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray16 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray16 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray16 array1, in FixedLengthCharArray16 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray16 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray16 array1, in FixedLengthCharArray16 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray16 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 17 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray17
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray17 _Zero = default;
		public static ref readonly FixedLengthCharArray17 Zero => ref _Zero;

		public const int ConstLength = 17;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray17(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray17) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray17)other);

        public readonly bool Equals(in FixedLengthCharArray17 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray17 left, in FixedLengthCharArray17 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray17 left, in FixedLengthCharArray17 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray17 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray17 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray17 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray17 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray17 array1, in FixedLengthCharArray17 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray17 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray17 array1, in FixedLengthCharArray17 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray17 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray17 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray17 array1, in FixedLengthCharArray17 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray17 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray17 array1, in FixedLengthCharArray17 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray17 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 18 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray18
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray18 _Zero = default;
		public static ref readonly FixedLengthCharArray18 Zero => ref _Zero;

		public const int ConstLength = 18;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray18(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray18) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray18)other);

        public readonly bool Equals(in FixedLengthCharArray18 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray18 left, in FixedLengthCharArray18 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray18 left, in FixedLengthCharArray18 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray18 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray18 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray18 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray18 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray18 array1, in FixedLengthCharArray18 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray18 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray18 array1, in FixedLengthCharArray18 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray18 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray18 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray18 array1, in FixedLengthCharArray18 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray18 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray18 array1, in FixedLengthCharArray18 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray18 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 19 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray19
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray19 _Zero = default;
		public static ref readonly FixedLengthCharArray19 Zero => ref _Zero;

		public const int ConstLength = 19;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray19(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray19) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray19)other);

        public readonly bool Equals(in FixedLengthCharArray19 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray19 left, in FixedLengthCharArray19 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray19 left, in FixedLengthCharArray19 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray19 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray19 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray19 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray19 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray19 array1, in FixedLengthCharArray19 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray19 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray19 array1, in FixedLengthCharArray19 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray19 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray19 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray19 array1, in FixedLengthCharArray19 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray19 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray19 array1, in FixedLengthCharArray19 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray19 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 20 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray20
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray20 _Zero = default;
		public static ref readonly FixedLengthCharArray20 Zero => ref _Zero;

		public const int ConstLength = 20;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray20(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray20) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray20)other);

        public readonly bool Equals(in FixedLengthCharArray20 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray20 left, in FixedLengthCharArray20 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray20 left, in FixedLengthCharArray20 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray20 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray20 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray20 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray20 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray20 array1, in FixedLengthCharArray20 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray20 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray20 array1, in FixedLengthCharArray20 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray20 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray20 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray20 array1, in FixedLengthCharArray20 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray20 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray20 array1, in FixedLengthCharArray20 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray20 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 21 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray21
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray21 _Zero = default;
		public static ref readonly FixedLengthCharArray21 Zero => ref _Zero;

		public const int ConstLength = 21;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray21(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
			, Char field20
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
		public Char Field20;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray21) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray21)other);

        public readonly bool Equals(in FixedLengthCharArray21 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray21 left, in FixedLengthCharArray21 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray21 left, in FixedLengthCharArray21 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray21 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray21 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray21 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray21 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray21 array1, in FixedLengthCharArray21 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray21 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray21 array1, in FixedLengthCharArray21 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray21 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray21 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray21 array1, in FixedLengthCharArray21 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray21 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray21 array1, in FixedLengthCharArray21 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray21 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 22 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray22
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray22 _Zero = default;
		public static ref readonly FixedLengthCharArray22 Zero => ref _Zero;

		public const int ConstLength = 22;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray22(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
			, Char field20
			, Char field21
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
		public Char Field20;
		public Char Field21;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray22) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray22)other);

        public readonly bool Equals(in FixedLengthCharArray22 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray22 left, in FixedLengthCharArray22 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray22 left, in FixedLengthCharArray22 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray22 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray22 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray22 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray22 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray22 array1, in FixedLengthCharArray22 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray22 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray22 array1, in FixedLengthCharArray22 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray22 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray22 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray22 array1, in FixedLengthCharArray22 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray22 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray22 array1, in FixedLengthCharArray22 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray22 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 23 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray23
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray23 _Zero = default;
		public static ref readonly FixedLengthCharArray23 Zero => ref _Zero;

		public const int ConstLength = 23;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray23(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
			, Char field20
			, Char field21
			, Char field22
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
		public Char Field20;
		public Char Field21;
		public Char Field22;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray23) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray23)other);

        public readonly bool Equals(in FixedLengthCharArray23 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray23 left, in FixedLengthCharArray23 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray23 left, in FixedLengthCharArray23 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray23 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray23 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray23 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray23 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray23 array1, in FixedLengthCharArray23 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray23 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray23 array1, in FixedLengthCharArray23 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray23 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray23 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray23 array1, in FixedLengthCharArray23 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray23 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray23 array1, in FixedLengthCharArray23 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray23 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 24 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray24
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray24 _Zero = default;
		public static ref readonly FixedLengthCharArray24 Zero => ref _Zero;

		public const int ConstLength = 24;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray24(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
			, Char field20
			, Char field21
			, Char field22
			, Char field23
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
		public Char Field20;
		public Char Field21;
		public Char Field22;
		public Char Field23;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray24) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray24)other);

        public readonly bool Equals(in FixedLengthCharArray24 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray24 left, in FixedLengthCharArray24 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray24 left, in FixedLengthCharArray24 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray24 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray24 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray24 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray24 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray24 array1, in FixedLengthCharArray24 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray24 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray24 array1, in FixedLengthCharArray24 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray24 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray24 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray24 array1, in FixedLengthCharArray24 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray24 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray24 array1, in FixedLengthCharArray24 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray24 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 25 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray25
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray25 _Zero = default;
		public static ref readonly FixedLengthCharArray25 Zero => ref _Zero;

		public const int ConstLength = 25;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray25(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
			, Char field20
			, Char field21
			, Char field22
			, Char field23
			, Char field24
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
		public Char Field20;
		public Char Field21;
		public Char Field22;
		public Char Field23;
		public Char Field24;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray25) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray25)other);

        public readonly bool Equals(in FixedLengthCharArray25 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray25 left, in FixedLengthCharArray25 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray25 left, in FixedLengthCharArray25 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray25 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray25 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray25 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray25 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray25 array1, in FixedLengthCharArray25 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray25 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray25 array1, in FixedLengthCharArray25 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray25 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray25 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray25 array1, in FixedLengthCharArray25 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray25 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray25 array1, in FixedLengthCharArray25 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray25 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 26 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray26
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray26 _Zero = default;
		public static ref readonly FixedLengthCharArray26 Zero => ref _Zero;

		public const int ConstLength = 26;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray26(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
			, Char field20
			, Char field21
			, Char field22
			, Char field23
			, Char field24
			, Char field25
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
		public Char Field20;
		public Char Field21;
		public Char Field22;
		public Char Field23;
		public Char Field24;
		public Char Field25;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray26) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray26)other);

        public readonly bool Equals(in FixedLengthCharArray26 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray26 left, in FixedLengthCharArray26 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray26 left, in FixedLengthCharArray26 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray26 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray26 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray26 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray26 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray26 array1, in FixedLengthCharArray26 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray26 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray26 array1, in FixedLengthCharArray26 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray26 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray26 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray26 array1, in FixedLengthCharArray26 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray26 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray26 array1, in FixedLengthCharArray26 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray26 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 27 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray27
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray27 _Zero = default;
		public static ref readonly FixedLengthCharArray27 Zero => ref _Zero;

		public const int ConstLength = 27;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray27(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
			, Char field20
			, Char field21
			, Char field22
			, Char field23
			, Char field24
			, Char field25
			, Char field26
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
		public Char Field20;
		public Char Field21;
		public Char Field22;
		public Char Field23;
		public Char Field24;
		public Char Field25;
		public Char Field26;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray27) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray27)other);

        public readonly bool Equals(in FixedLengthCharArray27 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray27 left, in FixedLengthCharArray27 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray27 left, in FixedLengthCharArray27 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray27 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray27 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray27 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray27 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray27 array1, in FixedLengthCharArray27 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray27 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray27 array1, in FixedLengthCharArray27 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray27 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray27 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray27 array1, in FixedLengthCharArray27 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray27 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray27 array1, in FixedLengthCharArray27 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray27 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 28 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray28
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray28 _Zero = default;
		public static ref readonly FixedLengthCharArray28 Zero => ref _Zero;

		public const int ConstLength = 28;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray28(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
			, Char field20
			, Char field21
			, Char field22
			, Char field23
			, Char field24
			, Char field25
			, Char field26
			, Char field27
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
		public Char Field20;
		public Char Field21;
		public Char Field22;
		public Char Field23;
		public Char Field24;
		public Char Field25;
		public Char Field26;
		public Char Field27;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray28) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray28)other);

        public readonly bool Equals(in FixedLengthCharArray28 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray28 left, in FixedLengthCharArray28 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray28 left, in FixedLengthCharArray28 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray28 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray28 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray28 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray28 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray28 array1, in FixedLengthCharArray28 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray28 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray28 array1, in FixedLengthCharArray28 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray28 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray28 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray28 array1, in FixedLengthCharArray28 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray28 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray28 array1, in FixedLengthCharArray28 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray28 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 29 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray29
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray29 _Zero = default;
		public static ref readonly FixedLengthCharArray29 Zero => ref _Zero;

		public const int ConstLength = 29;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray29(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
			, Char field20
			, Char field21
			, Char field22
			, Char field23
			, Char field24
			, Char field25
			, Char field26
			, Char field27
			, Char field28
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
		public Char Field20;
		public Char Field21;
		public Char Field22;
		public Char Field23;
		public Char Field24;
		public Char Field25;
		public Char Field26;
		public Char Field27;
		public Char Field28;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray29) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray29)other);

        public readonly bool Equals(in FixedLengthCharArray29 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray29 left, in FixedLengthCharArray29 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray29 left, in FixedLengthCharArray29 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray29 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray29 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray29 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray29 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray29 array1, in FixedLengthCharArray29 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray29 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray29 array1, in FixedLengthCharArray29 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray29 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray29 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray29 array1, in FixedLengthCharArray29 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray29 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray29 array1, in FixedLengthCharArray29 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray29 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 30 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray30
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray30 _Zero = default;
		public static ref readonly FixedLengthCharArray30 Zero => ref _Zero;

		public const int ConstLength = 30;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray30(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
			, Char field20
			, Char field21
			, Char field22
			, Char field23
			, Char field24
			, Char field25
			, Char field26
			, Char field27
			, Char field28
			, Char field29
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
		public Char Field20;
		public Char Field21;
		public Char Field22;
		public Char Field23;
		public Char Field24;
		public Char Field25;
		public Char Field26;
		public Char Field27;
		public Char Field28;
		public Char Field29;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray30) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray30)other);

        public readonly bool Equals(in FixedLengthCharArray30 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray30 left, in FixedLengthCharArray30 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray30 left, in FixedLengthCharArray30 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray30 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray30 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray30 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray30 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray30 array1, in FixedLengthCharArray30 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray30 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray30 array1, in FixedLengthCharArray30 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray30 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray30 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray30 array1, in FixedLengthCharArray30 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray30 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray30 array1, in FixedLengthCharArray30 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray30 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 31 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray31
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray31 _Zero = default;
		public static ref readonly FixedLengthCharArray31 Zero => ref _Zero;

		public const int ConstLength = 31;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray31(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
			, Char field20
			, Char field21
			, Char field22
			, Char field23
			, Char field24
			, Char field25
			, Char field26
			, Char field27
			, Char field28
			, Char field29
			, Char field30
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
		public Char Field20;
		public Char Field21;
		public Char Field22;
		public Char Field23;
		public Char Field24;
		public Char Field25;
		public Char Field26;
		public Char Field27;
		public Char Field28;
		public Char Field29;
		public Char Field30;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray31) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray31)other);

        public readonly bool Equals(in FixedLengthCharArray31 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray31 left, in FixedLengthCharArray31 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray31 left, in FixedLengthCharArray31 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray31 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray31 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray31 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray31 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray31 array1, in FixedLengthCharArray31 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray31 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray31 array1, in FixedLengthCharArray31 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray31 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray31 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray31 array1, in FixedLengthCharArray31 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray31 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray31 array1, in FixedLengthCharArray31 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray31 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 32 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray32
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray32 _Zero = default;
		public static ref readonly FixedLengthCharArray32 Zero => ref _Zero;

		public const int ConstLength = 32;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray32(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
			, Char field20
			, Char field21
			, Char field22
			, Char field23
			, Char field24
			, Char field25
			, Char field26
			, Char field27
			, Char field28
			, Char field29
			, Char field30
			, Char field31
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
		public Char Field20;
		public Char Field21;
		public Char Field22;
		public Char Field23;
		public Char Field24;
		public Char Field25;
		public Char Field26;
		public Char Field27;
		public Char Field28;
		public Char Field29;
		public Char Field30;
		public Char Field31;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray32) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray32)other);

        public readonly bool Equals(in FixedLengthCharArray32 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray32 left, in FixedLengthCharArray32 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray32 left, in FixedLengthCharArray32 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray32 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray32 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray32 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray32 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray32 array1, in FixedLengthCharArray32 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray32 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray32 array1, in FixedLengthCharArray32 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray32 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray32 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray32 array1, in FixedLengthCharArray32 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray32 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray32 array1, in FixedLengthCharArray32 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray32 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 33 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray33
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray33 _Zero = default;
		public static ref readonly FixedLengthCharArray33 Zero => ref _Zero;

		public const int ConstLength = 33;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray33(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
			, Char field20
			, Char field21
			, Char field22
			, Char field23
			, Char field24
			, Char field25
			, Char field26
			, Char field27
			, Char field28
			, Char field29
			, Char field30
			, Char field31
			, Char field32
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
		public Char Field20;
		public Char Field21;
		public Char Field22;
		public Char Field23;
		public Char Field24;
		public Char Field25;
		public Char Field26;
		public Char Field27;
		public Char Field28;
		public Char Field29;
		public Char Field30;
		public Char Field31;
		public Char Field32;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray33) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray33)other);

        public readonly bool Equals(in FixedLengthCharArray33 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray33 left, in FixedLengthCharArray33 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray33 left, in FixedLengthCharArray33 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray33 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray33 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray33 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray33 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray33 array1, in FixedLengthCharArray33 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray33 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray33 array1, in FixedLengthCharArray33 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray33 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray33 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray33 array1, in FixedLengthCharArray33 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray33 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray33 array1, in FixedLengthCharArray33 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray33 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 34 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray34
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray34 _Zero = default;
		public static ref readonly FixedLengthCharArray34 Zero => ref _Zero;

		public const int ConstLength = 34;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray34(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
			, Char field20
			, Char field21
			, Char field22
			, Char field23
			, Char field24
			, Char field25
			, Char field26
			, Char field27
			, Char field28
			, Char field29
			, Char field30
			, Char field31
			, Char field32
			, Char field33
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
		public Char Field20;
		public Char Field21;
		public Char Field22;
		public Char Field23;
		public Char Field24;
		public Char Field25;
		public Char Field26;
		public Char Field27;
		public Char Field28;
		public Char Field29;
		public Char Field30;
		public Char Field31;
		public Char Field32;
		public Char Field33;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray34) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray34)other);

        public readonly bool Equals(in FixedLengthCharArray34 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray34 left, in FixedLengthCharArray34 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray34 left, in FixedLengthCharArray34 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray34 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray34 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray34 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray34 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray34 array1, in FixedLengthCharArray34 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray34 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray34 array1, in FixedLengthCharArray34 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray34 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray34 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray34 array1, in FixedLengthCharArray34 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray34 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray34 array1, in FixedLengthCharArray34 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray34 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 35 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray35
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray35 _Zero = default;
		public static ref readonly FixedLengthCharArray35 Zero => ref _Zero;

		public const int ConstLength = 35;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray35(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
			, Char field20
			, Char field21
			, Char field22
			, Char field23
			, Char field24
			, Char field25
			, Char field26
			, Char field27
			, Char field28
			, Char field29
			, Char field30
			, Char field31
			, Char field32
			, Char field33
			, Char field34
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
		public Char Field20;
		public Char Field21;
		public Char Field22;
		public Char Field23;
		public Char Field24;
		public Char Field25;
		public Char Field26;
		public Char Field27;
		public Char Field28;
		public Char Field29;
		public Char Field30;
		public Char Field31;
		public Char Field32;
		public Char Field33;
		public Char Field34;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray35) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray35)other);

        public readonly bool Equals(in FixedLengthCharArray35 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray35 left, in FixedLengthCharArray35 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray35 left, in FixedLengthCharArray35 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray35 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray35 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray35 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray35 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray35 array1, in FixedLengthCharArray35 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray35 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray35 array1, in FixedLengthCharArray35 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray35 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray35 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray35 array1, in FixedLengthCharArray35 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray35 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray35 array1, in FixedLengthCharArray35 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray35 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 36 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray36
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray36 _Zero = default;
		public static ref readonly FixedLengthCharArray36 Zero => ref _Zero;

		public const int ConstLength = 36;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray36(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
			, Char field20
			, Char field21
			, Char field22
			, Char field23
			, Char field24
			, Char field25
			, Char field26
			, Char field27
			, Char field28
			, Char field29
			, Char field30
			, Char field31
			, Char field32
			, Char field33
			, Char field34
			, Char field35
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
		public Char Field20;
		public Char Field21;
		public Char Field22;
		public Char Field23;
		public Char Field24;
		public Char Field25;
		public Char Field26;
		public Char Field27;
		public Char Field28;
		public Char Field29;
		public Char Field30;
		public Char Field31;
		public Char Field32;
		public Char Field33;
		public Char Field34;
		public Char Field35;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray36) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray36)other);

        public readonly bool Equals(in FixedLengthCharArray36 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray36 left, in FixedLengthCharArray36 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray36 left, in FixedLengthCharArray36 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray36 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray36 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray36 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray36 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray36 array1, in FixedLengthCharArray36 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray36 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray36 array1, in FixedLengthCharArray36 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray36 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray36 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray36 array1, in FixedLengthCharArray36 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray36 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray36 array1, in FixedLengthCharArray36 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray36 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 37 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray37
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray37 _Zero = default;
		public static ref readonly FixedLengthCharArray37 Zero => ref _Zero;

		public const int ConstLength = 37;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray37(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
			, Char field20
			, Char field21
			, Char field22
			, Char field23
			, Char field24
			, Char field25
			, Char field26
			, Char field27
			, Char field28
			, Char field29
			, Char field30
			, Char field31
			, Char field32
			, Char field33
			, Char field34
			, Char field35
			, Char field36
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
		public Char Field20;
		public Char Field21;
		public Char Field22;
		public Char Field23;
		public Char Field24;
		public Char Field25;
		public Char Field26;
		public Char Field27;
		public Char Field28;
		public Char Field29;
		public Char Field30;
		public Char Field31;
		public Char Field32;
		public Char Field33;
		public Char Field34;
		public Char Field35;
		public Char Field36;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray37) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray37)other);

        public readonly bool Equals(in FixedLengthCharArray37 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray37 left, in FixedLengthCharArray37 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray37 left, in FixedLengthCharArray37 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray37 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray37 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray37 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray37 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray37 array1, in FixedLengthCharArray37 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray37 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray37 array1, in FixedLengthCharArray37 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray37 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray37 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray37 array1, in FixedLengthCharArray37 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray37 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray37 array1, in FixedLengthCharArray37 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray37 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 38 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray38
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray38 _Zero = default;
		public static ref readonly FixedLengthCharArray38 Zero => ref _Zero;

		public const int ConstLength = 38;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray38(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
			, Char field20
			, Char field21
			, Char field22
			, Char field23
			, Char field24
			, Char field25
			, Char field26
			, Char field27
			, Char field28
			, Char field29
			, Char field30
			, Char field31
			, Char field32
			, Char field33
			, Char field34
			, Char field35
			, Char field36
			, Char field37
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
		public Char Field20;
		public Char Field21;
		public Char Field22;
		public Char Field23;
		public Char Field24;
		public Char Field25;
		public Char Field26;
		public Char Field27;
		public Char Field28;
		public Char Field29;
		public Char Field30;
		public Char Field31;
		public Char Field32;
		public Char Field33;
		public Char Field34;
		public Char Field35;
		public Char Field36;
		public Char Field37;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray38) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray38)other);

        public readonly bool Equals(in FixedLengthCharArray38 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray38 left, in FixedLengthCharArray38 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray38 left, in FixedLengthCharArray38 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray38 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray38 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray38 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray38 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray38 array1, in FixedLengthCharArray38 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray38 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray38 array1, in FixedLengthCharArray38 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray38 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray38 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray38 array1, in FixedLengthCharArray38 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray38 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray38 array1, in FixedLengthCharArray38 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray38 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 39 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray39
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray39 _Zero = default;
		public static ref readonly FixedLengthCharArray39 Zero => ref _Zero;

		public const int ConstLength = 39;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray39(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
			, Char field20
			, Char field21
			, Char field22
			, Char field23
			, Char field24
			, Char field25
			, Char field26
			, Char field27
			, Char field28
			, Char field29
			, Char field30
			, Char field31
			, Char field32
			, Char field33
			, Char field34
			, Char field35
			, Char field36
			, Char field37
			, Char field38
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
		public Char Field20;
		public Char Field21;
		public Char Field22;
		public Char Field23;
		public Char Field24;
		public Char Field25;
		public Char Field26;
		public Char Field27;
		public Char Field28;
		public Char Field29;
		public Char Field30;
		public Char Field31;
		public Char Field32;
		public Char Field33;
		public Char Field34;
		public Char Field35;
		public Char Field36;
		public Char Field37;
		public Char Field38;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray39) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray39)other);

        public readonly bool Equals(in FixedLengthCharArray39 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray39 left, in FixedLengthCharArray39 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray39 left, in FixedLengthCharArray39 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray39 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray39 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray39 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray39 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray39 array1, in FixedLengthCharArray39 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray39 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray39 array1, in FixedLengthCharArray39 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray39 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray39 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray39 array1, in FixedLengthCharArray39 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray39 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray39 array1, in FixedLengthCharArray39 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray39 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 40 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray40
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray40 _Zero = default;
		public static ref readonly FixedLengthCharArray40 Zero => ref _Zero;

		public const int ConstLength = 40;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray40(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
			, Char field20
			, Char field21
			, Char field22
			, Char field23
			, Char field24
			, Char field25
			, Char field26
			, Char field27
			, Char field28
			, Char field29
			, Char field30
			, Char field31
			, Char field32
			, Char field33
			, Char field34
			, Char field35
			, Char field36
			, Char field37
			, Char field38
			, Char field39
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
		public Char Field20;
		public Char Field21;
		public Char Field22;
		public Char Field23;
		public Char Field24;
		public Char Field25;
		public Char Field26;
		public Char Field27;
		public Char Field28;
		public Char Field29;
		public Char Field30;
		public Char Field31;
		public Char Field32;
		public Char Field33;
		public Char Field34;
		public Char Field35;
		public Char Field36;
		public Char Field37;
		public Char Field38;
		public Char Field39;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray40) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray40)other);

        public readonly bool Equals(in FixedLengthCharArray40 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray40 left, in FixedLengthCharArray40 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray40 left, in FixedLengthCharArray40 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray40 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray40 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray40 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray40 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray40 array1, in FixedLengthCharArray40 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray40 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray40 array1, in FixedLengthCharArray40 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray40 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray40 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray40 array1, in FixedLengthCharArray40 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray40 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray40 array1, in FixedLengthCharArray40 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray40 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 41 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray41
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray41 _Zero = default;
		public static ref readonly FixedLengthCharArray41 Zero => ref _Zero;

		public const int ConstLength = 41;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray41(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
			, Char field20
			, Char field21
			, Char field22
			, Char field23
			, Char field24
			, Char field25
			, Char field26
			, Char field27
			, Char field28
			, Char field29
			, Char field30
			, Char field31
			, Char field32
			, Char field33
			, Char field34
			, Char field35
			, Char field36
			, Char field37
			, Char field38
			, Char field39
			, Char field40
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
		public Char Field20;
		public Char Field21;
		public Char Field22;
		public Char Field23;
		public Char Field24;
		public Char Field25;
		public Char Field26;
		public Char Field27;
		public Char Field28;
		public Char Field29;
		public Char Field30;
		public Char Field31;
		public Char Field32;
		public Char Field33;
		public Char Field34;
		public Char Field35;
		public Char Field36;
		public Char Field37;
		public Char Field38;
		public Char Field39;
		public Char Field40;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray41) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray41)other);

        public readonly bool Equals(in FixedLengthCharArray41 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray41 left, in FixedLengthCharArray41 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray41 left, in FixedLengthCharArray41 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray41 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray41 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray41 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray41 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray41 array1, in FixedLengthCharArray41 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray41 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray41 array1, in FixedLengthCharArray41 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray41 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray41 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray41 array1, in FixedLengthCharArray41 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray41 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray41 array1, in FixedLengthCharArray41 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray41 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 42 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray42
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray42 _Zero = default;
		public static ref readonly FixedLengthCharArray42 Zero => ref _Zero;

		public const int ConstLength = 42;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray42(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
			, Char field20
			, Char field21
			, Char field22
			, Char field23
			, Char field24
			, Char field25
			, Char field26
			, Char field27
			, Char field28
			, Char field29
			, Char field30
			, Char field31
			, Char field32
			, Char field33
			, Char field34
			, Char field35
			, Char field36
			, Char field37
			, Char field38
			, Char field39
			, Char field40
			, Char field41
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
		public Char Field20;
		public Char Field21;
		public Char Field22;
		public Char Field23;
		public Char Field24;
		public Char Field25;
		public Char Field26;
		public Char Field27;
		public Char Field28;
		public Char Field29;
		public Char Field30;
		public Char Field31;
		public Char Field32;
		public Char Field33;
		public Char Field34;
		public Char Field35;
		public Char Field36;
		public Char Field37;
		public Char Field38;
		public Char Field39;
		public Char Field40;
		public Char Field41;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray42) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray42)other);

        public readonly bool Equals(in FixedLengthCharArray42 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray42 left, in FixedLengthCharArray42 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray42 left, in FixedLengthCharArray42 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray42 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray42 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray42 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray42 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray42 array1, in FixedLengthCharArray42 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray42 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray42 array1, in FixedLengthCharArray42 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray42 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray42 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray42 array1, in FixedLengthCharArray42 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray42 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray42 array1, in FixedLengthCharArray42 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray42 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 43 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray43
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray43 _Zero = default;
		public static ref readonly FixedLengthCharArray43 Zero => ref _Zero;

		public const int ConstLength = 43;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray43(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
			, Char field20
			, Char field21
			, Char field22
			, Char field23
			, Char field24
			, Char field25
			, Char field26
			, Char field27
			, Char field28
			, Char field29
			, Char field30
			, Char field31
			, Char field32
			, Char field33
			, Char field34
			, Char field35
			, Char field36
			, Char field37
			, Char field38
			, Char field39
			, Char field40
			, Char field41
			, Char field42
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
		public Char Field20;
		public Char Field21;
		public Char Field22;
		public Char Field23;
		public Char Field24;
		public Char Field25;
		public Char Field26;
		public Char Field27;
		public Char Field28;
		public Char Field29;
		public Char Field30;
		public Char Field31;
		public Char Field32;
		public Char Field33;
		public Char Field34;
		public Char Field35;
		public Char Field36;
		public Char Field37;
		public Char Field38;
		public Char Field39;
		public Char Field40;
		public Char Field41;
		public Char Field42;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray43) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray43)other);

        public readonly bool Equals(in FixedLengthCharArray43 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray43 left, in FixedLengthCharArray43 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray43 left, in FixedLengthCharArray43 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray43 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray43 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray43 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray43 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray43 array1, in FixedLengthCharArray43 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray43 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray43 array1, in FixedLengthCharArray43 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray43 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray43 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray43 array1, in FixedLengthCharArray43 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray43 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray43 array1, in FixedLengthCharArray43 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray43 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 44 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray44
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray44 _Zero = default;
		public static ref readonly FixedLengthCharArray44 Zero => ref _Zero;

		public const int ConstLength = 44;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray44(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
			, Char field20
			, Char field21
			, Char field22
			, Char field23
			, Char field24
			, Char field25
			, Char field26
			, Char field27
			, Char field28
			, Char field29
			, Char field30
			, Char field31
			, Char field32
			, Char field33
			, Char field34
			, Char field35
			, Char field36
			, Char field37
			, Char field38
			, Char field39
			, Char field40
			, Char field41
			, Char field42
			, Char field43
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
		public Char Field20;
		public Char Field21;
		public Char Field22;
		public Char Field23;
		public Char Field24;
		public Char Field25;
		public Char Field26;
		public Char Field27;
		public Char Field28;
		public Char Field29;
		public Char Field30;
		public Char Field31;
		public Char Field32;
		public Char Field33;
		public Char Field34;
		public Char Field35;
		public Char Field36;
		public Char Field37;
		public Char Field38;
		public Char Field39;
		public Char Field40;
		public Char Field41;
		public Char Field42;
		public Char Field43;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray44) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray44)other);

        public readonly bool Equals(in FixedLengthCharArray44 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray44 left, in FixedLengthCharArray44 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray44 left, in FixedLengthCharArray44 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray44 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray44 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray44 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray44 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray44 array1, in FixedLengthCharArray44 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray44 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray44 array1, in FixedLengthCharArray44 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray44 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray44 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray44 array1, in FixedLengthCharArray44 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray44 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray44 array1, in FixedLengthCharArray44 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray44 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 45 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray45
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray45 _Zero = default;
		public static ref readonly FixedLengthCharArray45 Zero => ref _Zero;

		public const int ConstLength = 45;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray45(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
			, Char field20
			, Char field21
			, Char field22
			, Char field23
			, Char field24
			, Char field25
			, Char field26
			, Char field27
			, Char field28
			, Char field29
			, Char field30
			, Char field31
			, Char field32
			, Char field33
			, Char field34
			, Char field35
			, Char field36
			, Char field37
			, Char field38
			, Char field39
			, Char field40
			, Char field41
			, Char field42
			, Char field43
			, Char field44
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
		public Char Field20;
		public Char Field21;
		public Char Field22;
		public Char Field23;
		public Char Field24;
		public Char Field25;
		public Char Field26;
		public Char Field27;
		public Char Field28;
		public Char Field29;
		public Char Field30;
		public Char Field31;
		public Char Field32;
		public Char Field33;
		public Char Field34;
		public Char Field35;
		public Char Field36;
		public Char Field37;
		public Char Field38;
		public Char Field39;
		public Char Field40;
		public Char Field41;
		public Char Field42;
		public Char Field43;
		public Char Field44;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray45) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray45)other);

        public readonly bool Equals(in FixedLengthCharArray45 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray45 left, in FixedLengthCharArray45 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray45 left, in FixedLengthCharArray45 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray45 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray45 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray45 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray45 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray45 array1, in FixedLengthCharArray45 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray45 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray45 array1, in FixedLengthCharArray45 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray45 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray45 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray45 array1, in FixedLengthCharArray45 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray45 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray45 array1, in FixedLengthCharArray45 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray45 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 46 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray46
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray46 _Zero = default;
		public static ref readonly FixedLengthCharArray46 Zero => ref _Zero;

		public const int ConstLength = 46;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray46(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
			, Char field20
			, Char field21
			, Char field22
			, Char field23
			, Char field24
			, Char field25
			, Char field26
			, Char field27
			, Char field28
			, Char field29
			, Char field30
			, Char field31
			, Char field32
			, Char field33
			, Char field34
			, Char field35
			, Char field36
			, Char field37
			, Char field38
			, Char field39
			, Char field40
			, Char field41
			, Char field42
			, Char field43
			, Char field44
			, Char field45
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
		public Char Field20;
		public Char Field21;
		public Char Field22;
		public Char Field23;
		public Char Field24;
		public Char Field25;
		public Char Field26;
		public Char Field27;
		public Char Field28;
		public Char Field29;
		public Char Field30;
		public Char Field31;
		public Char Field32;
		public Char Field33;
		public Char Field34;
		public Char Field35;
		public Char Field36;
		public Char Field37;
		public Char Field38;
		public Char Field39;
		public Char Field40;
		public Char Field41;
		public Char Field42;
		public Char Field43;
		public Char Field44;
		public Char Field45;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray46) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray46)other);

        public readonly bool Equals(in FixedLengthCharArray46 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray46 left, in FixedLengthCharArray46 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray46 left, in FixedLengthCharArray46 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray46 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray46 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray46 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray46 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray46 array1, in FixedLengthCharArray46 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray46 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray46 array1, in FixedLengthCharArray46 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray46 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray46 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray46 array1, in FixedLengthCharArray46 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray46 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray46 array1, in FixedLengthCharArray46 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray46 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 47 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray47
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray47 _Zero = default;
		public static ref readonly FixedLengthCharArray47 Zero => ref _Zero;

		public const int ConstLength = 47;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray47(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
			, Char field20
			, Char field21
			, Char field22
			, Char field23
			, Char field24
			, Char field25
			, Char field26
			, Char field27
			, Char field28
			, Char field29
			, Char field30
			, Char field31
			, Char field32
			, Char field33
			, Char field34
			, Char field35
			, Char field36
			, Char field37
			, Char field38
			, Char field39
			, Char field40
			, Char field41
			, Char field42
			, Char field43
			, Char field44
			, Char field45
			, Char field46
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
			Field46 = field46;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
		public Char Field20;
		public Char Field21;
		public Char Field22;
		public Char Field23;
		public Char Field24;
		public Char Field25;
		public Char Field26;
		public Char Field27;
		public Char Field28;
		public Char Field29;
		public Char Field30;
		public Char Field31;
		public Char Field32;
		public Char Field33;
		public Char Field34;
		public Char Field35;
		public Char Field36;
		public Char Field37;
		public Char Field38;
		public Char Field39;
		public Char Field40;
		public Char Field41;
		public Char Field42;
		public Char Field43;
		public Char Field44;
		public Char Field45;
		public Char Field46;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                46 => Field46,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
                    case 46: Field46 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray47) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray47)other);

        public readonly bool Equals(in FixedLengthCharArray47 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray47 left, in FixedLengthCharArray47 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray47 left, in FixedLengthCharArray47 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
              yield return Field46;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray47 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray47 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray47 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray47 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
                case 46: return ref array.Field46;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray47 array1, in FixedLengthCharArray47 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray47 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray47 array1, in FixedLengthCharArray47 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray47 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray47 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray47 array1, in FixedLengthCharArray47 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray47 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray47 array1, in FixedLengthCharArray47 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray47 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 48 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray48
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray48 _Zero = default;
		public static ref readonly FixedLengthCharArray48 Zero => ref _Zero;

		public const int ConstLength = 48;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray48(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
			, Char field20
			, Char field21
			, Char field22
			, Char field23
			, Char field24
			, Char field25
			, Char field26
			, Char field27
			, Char field28
			, Char field29
			, Char field30
			, Char field31
			, Char field32
			, Char field33
			, Char field34
			, Char field35
			, Char field36
			, Char field37
			, Char field38
			, Char field39
			, Char field40
			, Char field41
			, Char field42
			, Char field43
			, Char field44
			, Char field45
			, Char field46
			, Char field47
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
			Field46 = field46;
			Field47 = field47;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
		public Char Field20;
		public Char Field21;
		public Char Field22;
		public Char Field23;
		public Char Field24;
		public Char Field25;
		public Char Field26;
		public Char Field27;
		public Char Field28;
		public Char Field29;
		public Char Field30;
		public Char Field31;
		public Char Field32;
		public Char Field33;
		public Char Field34;
		public Char Field35;
		public Char Field36;
		public Char Field37;
		public Char Field38;
		public Char Field39;
		public Char Field40;
		public Char Field41;
		public Char Field42;
		public Char Field43;
		public Char Field44;
		public Char Field45;
		public Char Field46;
		public Char Field47;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                46 => Field46,
                47 => Field47,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
                    case 46: Field46 = value; break;
                    case 47: Field47 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray48) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray48)other);

        public readonly bool Equals(in FixedLengthCharArray48 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray48 left, in FixedLengthCharArray48 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray48 left, in FixedLengthCharArray48 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
              yield return Field46;
              yield return Field47;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray48 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray48 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray48 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray48 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
                case 46: return ref array.Field46;
                case 47: return ref array.Field47;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray48 array1, in FixedLengthCharArray48 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray48 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray48 array1, in FixedLengthCharArray48 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray48 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray48 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray48 array1, in FixedLengthCharArray48 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray48 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray48 array1, in FixedLengthCharArray48 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray48 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 49 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray49
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray49 _Zero = default;
		public static ref readonly FixedLengthCharArray49 Zero => ref _Zero;

		public const int ConstLength = 49;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray49(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
			, Char field20
			, Char field21
			, Char field22
			, Char field23
			, Char field24
			, Char field25
			, Char field26
			, Char field27
			, Char field28
			, Char field29
			, Char field30
			, Char field31
			, Char field32
			, Char field33
			, Char field34
			, Char field35
			, Char field36
			, Char field37
			, Char field38
			, Char field39
			, Char field40
			, Char field41
			, Char field42
			, Char field43
			, Char field44
			, Char field45
			, Char field46
			, Char field47
			, Char field48
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
			Field46 = field46;
			Field47 = field47;
			Field48 = field48;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
		public Char Field20;
		public Char Field21;
		public Char Field22;
		public Char Field23;
		public Char Field24;
		public Char Field25;
		public Char Field26;
		public Char Field27;
		public Char Field28;
		public Char Field29;
		public Char Field30;
		public Char Field31;
		public Char Field32;
		public Char Field33;
		public Char Field34;
		public Char Field35;
		public Char Field36;
		public Char Field37;
		public Char Field38;
		public Char Field39;
		public Char Field40;
		public Char Field41;
		public Char Field42;
		public Char Field43;
		public Char Field44;
		public Char Field45;
		public Char Field46;
		public Char Field47;
		public Char Field48;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                46 => Field46,
                47 => Field47,
                48 => Field48,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
                    case 46: Field46 = value; break;
                    case 47: Field47 = value; break;
                    case 48: Field48 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray49) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray49)other);

        public readonly bool Equals(in FixedLengthCharArray49 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray49 left, in FixedLengthCharArray49 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray49 left, in FixedLengthCharArray49 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
              yield return Field46;
              yield return Field47;
              yield return Field48;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray49 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray49 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray49 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray49 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
                case 46: return ref array.Field46;
                case 47: return ref array.Field47;
                case 48: return ref array.Field48;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray49 array1, in FixedLengthCharArray49 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray49 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray49 array1, in FixedLengthCharArray49 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray49 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray49 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray49 array1, in FixedLengthCharArray49 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray49 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray49 array1, in FixedLengthCharArray49 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray49 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 50 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray50
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray50 _Zero = default;
		public static ref readonly FixedLengthCharArray50 Zero => ref _Zero;

		public const int ConstLength = 50;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray50(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
			, Char field20
			, Char field21
			, Char field22
			, Char field23
			, Char field24
			, Char field25
			, Char field26
			, Char field27
			, Char field28
			, Char field29
			, Char field30
			, Char field31
			, Char field32
			, Char field33
			, Char field34
			, Char field35
			, Char field36
			, Char field37
			, Char field38
			, Char field39
			, Char field40
			, Char field41
			, Char field42
			, Char field43
			, Char field44
			, Char field45
			, Char field46
			, Char field47
			, Char field48
			, Char field49
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
			Field46 = field46;
			Field47 = field47;
			Field48 = field48;
			Field49 = field49;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
		public Char Field20;
		public Char Field21;
		public Char Field22;
		public Char Field23;
		public Char Field24;
		public Char Field25;
		public Char Field26;
		public Char Field27;
		public Char Field28;
		public Char Field29;
		public Char Field30;
		public Char Field31;
		public Char Field32;
		public Char Field33;
		public Char Field34;
		public Char Field35;
		public Char Field36;
		public Char Field37;
		public Char Field38;
		public Char Field39;
		public Char Field40;
		public Char Field41;
		public Char Field42;
		public Char Field43;
		public Char Field44;
		public Char Field45;
		public Char Field46;
		public Char Field47;
		public Char Field48;
		public Char Field49;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                46 => Field46,
                47 => Field47,
                48 => Field48,
                49 => Field49,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
                    case 46: Field46 = value; break;
                    case 47: Field47 = value; break;
                    case 48: Field48 = value; break;
                    case 49: Field49 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray50) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray50)other);

        public readonly bool Equals(in FixedLengthCharArray50 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray50 left, in FixedLengthCharArray50 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray50 left, in FixedLengthCharArray50 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
              yield return Field46;
              yield return Field47;
              yield return Field48;
              yield return Field49;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray50 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray50 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray50 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray50 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
                case 46: return ref array.Field46;
                case 47: return ref array.Field47;
                case 48: return ref array.Field48;
                case 49: return ref array.Field49;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray50 array1, in FixedLengthCharArray50 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray50 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray50 array1, in FixedLengthCharArray50 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray50 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray50 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray50 array1, in FixedLengthCharArray50 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray50 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray50 array1, in FixedLengthCharArray50 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray50 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 51 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray51
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray51 _Zero = default;
		public static ref readonly FixedLengthCharArray51 Zero => ref _Zero;

		public const int ConstLength = 51;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray51(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
			, Char field20
			, Char field21
			, Char field22
			, Char field23
			, Char field24
			, Char field25
			, Char field26
			, Char field27
			, Char field28
			, Char field29
			, Char field30
			, Char field31
			, Char field32
			, Char field33
			, Char field34
			, Char field35
			, Char field36
			, Char field37
			, Char field38
			, Char field39
			, Char field40
			, Char field41
			, Char field42
			, Char field43
			, Char field44
			, Char field45
			, Char field46
			, Char field47
			, Char field48
			, Char field49
			, Char field50
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
			Field46 = field46;
			Field47 = field47;
			Field48 = field48;
			Field49 = field49;
			Field50 = field50;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
		public Char Field20;
		public Char Field21;
		public Char Field22;
		public Char Field23;
		public Char Field24;
		public Char Field25;
		public Char Field26;
		public Char Field27;
		public Char Field28;
		public Char Field29;
		public Char Field30;
		public Char Field31;
		public Char Field32;
		public Char Field33;
		public Char Field34;
		public Char Field35;
		public Char Field36;
		public Char Field37;
		public Char Field38;
		public Char Field39;
		public Char Field40;
		public Char Field41;
		public Char Field42;
		public Char Field43;
		public Char Field44;
		public Char Field45;
		public Char Field46;
		public Char Field47;
		public Char Field48;
		public Char Field49;
		public Char Field50;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                46 => Field46,
                47 => Field47,
                48 => Field48,
                49 => Field49,
                50 => Field50,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
                    case 46: Field46 = value; break;
                    case 47: Field47 = value; break;
                    case 48: Field48 = value; break;
                    case 49: Field49 = value; break;
                    case 50: Field50 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray51) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray51)other);

        public readonly bool Equals(in FixedLengthCharArray51 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray51 left, in FixedLengthCharArray51 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray51 left, in FixedLengthCharArray51 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
              yield return Field46;
              yield return Field47;
              yield return Field48;
              yield return Field49;
              yield return Field50;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray51 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray51 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray51 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray51 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
                case 46: return ref array.Field46;
                case 47: return ref array.Field47;
                case 48: return ref array.Field48;
                case 49: return ref array.Field49;
                case 50: return ref array.Field50;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray51 array1, in FixedLengthCharArray51 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray51 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray51 array1, in FixedLengthCharArray51 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray51 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray51 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray51 array1, in FixedLengthCharArray51 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray51 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray51 array1, in FixedLengthCharArray51 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray51 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 52 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray52
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray52 _Zero = default;
		public static ref readonly FixedLengthCharArray52 Zero => ref _Zero;

		public const int ConstLength = 52;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray52(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
			, Char field20
			, Char field21
			, Char field22
			, Char field23
			, Char field24
			, Char field25
			, Char field26
			, Char field27
			, Char field28
			, Char field29
			, Char field30
			, Char field31
			, Char field32
			, Char field33
			, Char field34
			, Char field35
			, Char field36
			, Char field37
			, Char field38
			, Char field39
			, Char field40
			, Char field41
			, Char field42
			, Char field43
			, Char field44
			, Char field45
			, Char field46
			, Char field47
			, Char field48
			, Char field49
			, Char field50
			, Char field51
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
			Field46 = field46;
			Field47 = field47;
			Field48 = field48;
			Field49 = field49;
			Field50 = field50;
			Field51 = field51;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
		public Char Field20;
		public Char Field21;
		public Char Field22;
		public Char Field23;
		public Char Field24;
		public Char Field25;
		public Char Field26;
		public Char Field27;
		public Char Field28;
		public Char Field29;
		public Char Field30;
		public Char Field31;
		public Char Field32;
		public Char Field33;
		public Char Field34;
		public Char Field35;
		public Char Field36;
		public Char Field37;
		public Char Field38;
		public Char Field39;
		public Char Field40;
		public Char Field41;
		public Char Field42;
		public Char Field43;
		public Char Field44;
		public Char Field45;
		public Char Field46;
		public Char Field47;
		public Char Field48;
		public Char Field49;
		public Char Field50;
		public Char Field51;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                46 => Field46,
                47 => Field47,
                48 => Field48,
                49 => Field49,
                50 => Field50,
                51 => Field51,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
                    case 46: Field46 = value; break;
                    case 47: Field47 = value; break;
                    case 48: Field48 = value; break;
                    case 49: Field49 = value; break;
                    case 50: Field50 = value; break;
                    case 51: Field51 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray52) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray52)other);

        public readonly bool Equals(in FixedLengthCharArray52 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray52 left, in FixedLengthCharArray52 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray52 left, in FixedLengthCharArray52 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
              yield return Field46;
              yield return Field47;
              yield return Field48;
              yield return Field49;
              yield return Field50;
              yield return Field51;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray52 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray52 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray52 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray52 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
                case 46: return ref array.Field46;
                case 47: return ref array.Field47;
                case 48: return ref array.Field48;
                case 49: return ref array.Field49;
                case 50: return ref array.Field50;
                case 51: return ref array.Field51;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray52 array1, in FixedLengthCharArray52 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray52 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray52 array1, in FixedLengthCharArray52 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray52 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray52 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray52 array1, in FixedLengthCharArray52 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray52 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray52 array1, in FixedLengthCharArray52 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray52 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 53 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray53
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray53 _Zero = default;
		public static ref readonly FixedLengthCharArray53 Zero => ref _Zero;

		public const int ConstLength = 53;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray53(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
			, Char field20
			, Char field21
			, Char field22
			, Char field23
			, Char field24
			, Char field25
			, Char field26
			, Char field27
			, Char field28
			, Char field29
			, Char field30
			, Char field31
			, Char field32
			, Char field33
			, Char field34
			, Char field35
			, Char field36
			, Char field37
			, Char field38
			, Char field39
			, Char field40
			, Char field41
			, Char field42
			, Char field43
			, Char field44
			, Char field45
			, Char field46
			, Char field47
			, Char field48
			, Char field49
			, Char field50
			, Char field51
			, Char field52
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
			Field46 = field46;
			Field47 = field47;
			Field48 = field48;
			Field49 = field49;
			Field50 = field50;
			Field51 = field51;
			Field52 = field52;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
		public Char Field20;
		public Char Field21;
		public Char Field22;
		public Char Field23;
		public Char Field24;
		public Char Field25;
		public Char Field26;
		public Char Field27;
		public Char Field28;
		public Char Field29;
		public Char Field30;
		public Char Field31;
		public Char Field32;
		public Char Field33;
		public Char Field34;
		public Char Field35;
		public Char Field36;
		public Char Field37;
		public Char Field38;
		public Char Field39;
		public Char Field40;
		public Char Field41;
		public Char Field42;
		public Char Field43;
		public Char Field44;
		public Char Field45;
		public Char Field46;
		public Char Field47;
		public Char Field48;
		public Char Field49;
		public Char Field50;
		public Char Field51;
		public Char Field52;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                46 => Field46,
                47 => Field47,
                48 => Field48,
                49 => Field49,
                50 => Field50,
                51 => Field51,
                52 => Field52,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
                    case 46: Field46 = value; break;
                    case 47: Field47 = value; break;
                    case 48: Field48 = value; break;
                    case 49: Field49 = value; break;
                    case 50: Field50 = value; break;
                    case 51: Field51 = value; break;
                    case 52: Field52 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray53) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray53)other);

        public readonly bool Equals(in FixedLengthCharArray53 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray53 left, in FixedLengthCharArray53 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray53 left, in FixedLengthCharArray53 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
              yield return Field46;
              yield return Field47;
              yield return Field48;
              yield return Field49;
              yield return Field50;
              yield return Field51;
              yield return Field52;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray53 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray53 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray53 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray53 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
                case 46: return ref array.Field46;
                case 47: return ref array.Field47;
                case 48: return ref array.Field48;
                case 49: return ref array.Field49;
                case 50: return ref array.Field50;
                case 51: return ref array.Field51;
                case 52: return ref array.Field52;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray53 array1, in FixedLengthCharArray53 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray53 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray53 array1, in FixedLengthCharArray53 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray53 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray53 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray53 array1, in FixedLengthCharArray53 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray53 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray53 array1, in FixedLengthCharArray53 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray53 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 54 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray54
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray54 _Zero = default;
		public static ref readonly FixedLengthCharArray54 Zero => ref _Zero;

		public const int ConstLength = 54;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray54(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
			, Char field20
			, Char field21
			, Char field22
			, Char field23
			, Char field24
			, Char field25
			, Char field26
			, Char field27
			, Char field28
			, Char field29
			, Char field30
			, Char field31
			, Char field32
			, Char field33
			, Char field34
			, Char field35
			, Char field36
			, Char field37
			, Char field38
			, Char field39
			, Char field40
			, Char field41
			, Char field42
			, Char field43
			, Char field44
			, Char field45
			, Char field46
			, Char field47
			, Char field48
			, Char field49
			, Char field50
			, Char field51
			, Char field52
			, Char field53
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
			Field46 = field46;
			Field47 = field47;
			Field48 = field48;
			Field49 = field49;
			Field50 = field50;
			Field51 = field51;
			Field52 = field52;
			Field53 = field53;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
		public Char Field20;
		public Char Field21;
		public Char Field22;
		public Char Field23;
		public Char Field24;
		public Char Field25;
		public Char Field26;
		public Char Field27;
		public Char Field28;
		public Char Field29;
		public Char Field30;
		public Char Field31;
		public Char Field32;
		public Char Field33;
		public Char Field34;
		public Char Field35;
		public Char Field36;
		public Char Field37;
		public Char Field38;
		public Char Field39;
		public Char Field40;
		public Char Field41;
		public Char Field42;
		public Char Field43;
		public Char Field44;
		public Char Field45;
		public Char Field46;
		public Char Field47;
		public Char Field48;
		public Char Field49;
		public Char Field50;
		public Char Field51;
		public Char Field52;
		public Char Field53;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                46 => Field46,
                47 => Field47,
                48 => Field48,
                49 => Field49,
                50 => Field50,
                51 => Field51,
                52 => Field52,
                53 => Field53,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
                    case 46: Field46 = value; break;
                    case 47: Field47 = value; break;
                    case 48: Field48 = value; break;
                    case 49: Field49 = value; break;
                    case 50: Field50 = value; break;
                    case 51: Field51 = value; break;
                    case 52: Field52 = value; break;
                    case 53: Field53 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray54) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray54)other);

        public readonly bool Equals(in FixedLengthCharArray54 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray54 left, in FixedLengthCharArray54 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray54 left, in FixedLengthCharArray54 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
              yield return Field46;
              yield return Field47;
              yield return Field48;
              yield return Field49;
              yield return Field50;
              yield return Field51;
              yield return Field52;
              yield return Field53;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray54 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray54 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray54 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray54 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
                case 46: return ref array.Field46;
                case 47: return ref array.Field47;
                case 48: return ref array.Field48;
                case 49: return ref array.Field49;
                case 50: return ref array.Field50;
                case 51: return ref array.Field51;
                case 52: return ref array.Field52;
                case 53: return ref array.Field53;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray54 array1, in FixedLengthCharArray54 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray54 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray54 array1, in FixedLengthCharArray54 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray54 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray54 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray54 array1, in FixedLengthCharArray54 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray54 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray54 array1, in FixedLengthCharArray54 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray54 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 55 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray55
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray55 _Zero = default;
		public static ref readonly FixedLengthCharArray55 Zero => ref _Zero;

		public const int ConstLength = 55;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray55(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
			, Char field20
			, Char field21
			, Char field22
			, Char field23
			, Char field24
			, Char field25
			, Char field26
			, Char field27
			, Char field28
			, Char field29
			, Char field30
			, Char field31
			, Char field32
			, Char field33
			, Char field34
			, Char field35
			, Char field36
			, Char field37
			, Char field38
			, Char field39
			, Char field40
			, Char field41
			, Char field42
			, Char field43
			, Char field44
			, Char field45
			, Char field46
			, Char field47
			, Char field48
			, Char field49
			, Char field50
			, Char field51
			, Char field52
			, Char field53
			, Char field54
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
			Field46 = field46;
			Field47 = field47;
			Field48 = field48;
			Field49 = field49;
			Field50 = field50;
			Field51 = field51;
			Field52 = field52;
			Field53 = field53;
			Field54 = field54;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
		public Char Field20;
		public Char Field21;
		public Char Field22;
		public Char Field23;
		public Char Field24;
		public Char Field25;
		public Char Field26;
		public Char Field27;
		public Char Field28;
		public Char Field29;
		public Char Field30;
		public Char Field31;
		public Char Field32;
		public Char Field33;
		public Char Field34;
		public Char Field35;
		public Char Field36;
		public Char Field37;
		public Char Field38;
		public Char Field39;
		public Char Field40;
		public Char Field41;
		public Char Field42;
		public Char Field43;
		public Char Field44;
		public Char Field45;
		public Char Field46;
		public Char Field47;
		public Char Field48;
		public Char Field49;
		public Char Field50;
		public Char Field51;
		public Char Field52;
		public Char Field53;
		public Char Field54;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                46 => Field46,
                47 => Field47,
                48 => Field48,
                49 => Field49,
                50 => Field50,
                51 => Field51,
                52 => Field52,
                53 => Field53,
                54 => Field54,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
                    case 46: Field46 = value; break;
                    case 47: Field47 = value; break;
                    case 48: Field48 = value; break;
                    case 49: Field49 = value; break;
                    case 50: Field50 = value; break;
                    case 51: Field51 = value; break;
                    case 52: Field52 = value; break;
                    case 53: Field53 = value; break;
                    case 54: Field54 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray55) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray55)other);

        public readonly bool Equals(in FixedLengthCharArray55 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray55 left, in FixedLengthCharArray55 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray55 left, in FixedLengthCharArray55 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
              yield return Field46;
              yield return Field47;
              yield return Field48;
              yield return Field49;
              yield return Field50;
              yield return Field51;
              yield return Field52;
              yield return Field53;
              yield return Field54;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray55 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray55 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray55 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray55 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
                case 46: return ref array.Field46;
                case 47: return ref array.Field47;
                case 48: return ref array.Field48;
                case 49: return ref array.Field49;
                case 50: return ref array.Field50;
                case 51: return ref array.Field51;
                case 52: return ref array.Field52;
                case 53: return ref array.Field53;
                case 54: return ref array.Field54;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray55 array1, in FixedLengthCharArray55 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray55 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray55 array1, in FixedLengthCharArray55 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray55 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray55 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray55 array1, in FixedLengthCharArray55 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray55 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray55 array1, in FixedLengthCharArray55 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray55 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 56 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray56
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray56 _Zero = default;
		public static ref readonly FixedLengthCharArray56 Zero => ref _Zero;

		public const int ConstLength = 56;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray56(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
			, Char field20
			, Char field21
			, Char field22
			, Char field23
			, Char field24
			, Char field25
			, Char field26
			, Char field27
			, Char field28
			, Char field29
			, Char field30
			, Char field31
			, Char field32
			, Char field33
			, Char field34
			, Char field35
			, Char field36
			, Char field37
			, Char field38
			, Char field39
			, Char field40
			, Char field41
			, Char field42
			, Char field43
			, Char field44
			, Char field45
			, Char field46
			, Char field47
			, Char field48
			, Char field49
			, Char field50
			, Char field51
			, Char field52
			, Char field53
			, Char field54
			, Char field55
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
			Field46 = field46;
			Field47 = field47;
			Field48 = field48;
			Field49 = field49;
			Field50 = field50;
			Field51 = field51;
			Field52 = field52;
			Field53 = field53;
			Field54 = field54;
			Field55 = field55;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
		public Char Field20;
		public Char Field21;
		public Char Field22;
		public Char Field23;
		public Char Field24;
		public Char Field25;
		public Char Field26;
		public Char Field27;
		public Char Field28;
		public Char Field29;
		public Char Field30;
		public Char Field31;
		public Char Field32;
		public Char Field33;
		public Char Field34;
		public Char Field35;
		public Char Field36;
		public Char Field37;
		public Char Field38;
		public Char Field39;
		public Char Field40;
		public Char Field41;
		public Char Field42;
		public Char Field43;
		public Char Field44;
		public Char Field45;
		public Char Field46;
		public Char Field47;
		public Char Field48;
		public Char Field49;
		public Char Field50;
		public Char Field51;
		public Char Field52;
		public Char Field53;
		public Char Field54;
		public Char Field55;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                46 => Field46,
                47 => Field47,
                48 => Field48,
                49 => Field49,
                50 => Field50,
                51 => Field51,
                52 => Field52,
                53 => Field53,
                54 => Field54,
                55 => Field55,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
                    case 46: Field46 = value; break;
                    case 47: Field47 = value; break;
                    case 48: Field48 = value; break;
                    case 49: Field49 = value; break;
                    case 50: Field50 = value; break;
                    case 51: Field51 = value; break;
                    case 52: Field52 = value; break;
                    case 53: Field53 = value; break;
                    case 54: Field54 = value; break;
                    case 55: Field55 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray56) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray56)other);

        public readonly bool Equals(in FixedLengthCharArray56 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray56 left, in FixedLengthCharArray56 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray56 left, in FixedLengthCharArray56 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
              yield return Field46;
              yield return Field47;
              yield return Field48;
              yield return Field49;
              yield return Field50;
              yield return Field51;
              yield return Field52;
              yield return Field53;
              yield return Field54;
              yield return Field55;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray56 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray56 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray56 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray56 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
                case 46: return ref array.Field46;
                case 47: return ref array.Field47;
                case 48: return ref array.Field48;
                case 49: return ref array.Field49;
                case 50: return ref array.Field50;
                case 51: return ref array.Field51;
                case 52: return ref array.Field52;
                case 53: return ref array.Field53;
                case 54: return ref array.Field54;
                case 55: return ref array.Field55;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray56 array1, in FixedLengthCharArray56 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray56 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray56 array1, in FixedLengthCharArray56 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray56 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray56 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray56 array1, in FixedLengthCharArray56 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray56 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray56 array1, in FixedLengthCharArray56 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray56 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 57 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray57
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray57 _Zero = default;
		public static ref readonly FixedLengthCharArray57 Zero => ref _Zero;

		public const int ConstLength = 57;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray57(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
			, Char field20
			, Char field21
			, Char field22
			, Char field23
			, Char field24
			, Char field25
			, Char field26
			, Char field27
			, Char field28
			, Char field29
			, Char field30
			, Char field31
			, Char field32
			, Char field33
			, Char field34
			, Char field35
			, Char field36
			, Char field37
			, Char field38
			, Char field39
			, Char field40
			, Char field41
			, Char field42
			, Char field43
			, Char field44
			, Char field45
			, Char field46
			, Char field47
			, Char field48
			, Char field49
			, Char field50
			, Char field51
			, Char field52
			, Char field53
			, Char field54
			, Char field55
			, Char field56
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
			Field46 = field46;
			Field47 = field47;
			Field48 = field48;
			Field49 = field49;
			Field50 = field50;
			Field51 = field51;
			Field52 = field52;
			Field53 = field53;
			Field54 = field54;
			Field55 = field55;
			Field56 = field56;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
		public Char Field20;
		public Char Field21;
		public Char Field22;
		public Char Field23;
		public Char Field24;
		public Char Field25;
		public Char Field26;
		public Char Field27;
		public Char Field28;
		public Char Field29;
		public Char Field30;
		public Char Field31;
		public Char Field32;
		public Char Field33;
		public Char Field34;
		public Char Field35;
		public Char Field36;
		public Char Field37;
		public Char Field38;
		public Char Field39;
		public Char Field40;
		public Char Field41;
		public Char Field42;
		public Char Field43;
		public Char Field44;
		public Char Field45;
		public Char Field46;
		public Char Field47;
		public Char Field48;
		public Char Field49;
		public Char Field50;
		public Char Field51;
		public Char Field52;
		public Char Field53;
		public Char Field54;
		public Char Field55;
		public Char Field56;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                46 => Field46,
                47 => Field47,
                48 => Field48,
                49 => Field49,
                50 => Field50,
                51 => Field51,
                52 => Field52,
                53 => Field53,
                54 => Field54,
                55 => Field55,
                56 => Field56,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
                    case 46: Field46 = value; break;
                    case 47: Field47 = value; break;
                    case 48: Field48 = value; break;
                    case 49: Field49 = value; break;
                    case 50: Field50 = value; break;
                    case 51: Field51 = value; break;
                    case 52: Field52 = value; break;
                    case 53: Field53 = value; break;
                    case 54: Field54 = value; break;
                    case 55: Field55 = value; break;
                    case 56: Field56 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray57) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray57)other);

        public readonly bool Equals(in FixedLengthCharArray57 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray57 left, in FixedLengthCharArray57 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray57 left, in FixedLengthCharArray57 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
              yield return Field46;
              yield return Field47;
              yield return Field48;
              yield return Field49;
              yield return Field50;
              yield return Field51;
              yield return Field52;
              yield return Field53;
              yield return Field54;
              yield return Field55;
              yield return Field56;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray57 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray57 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray57 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray57 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
                case 46: return ref array.Field46;
                case 47: return ref array.Field47;
                case 48: return ref array.Field48;
                case 49: return ref array.Field49;
                case 50: return ref array.Field50;
                case 51: return ref array.Field51;
                case 52: return ref array.Field52;
                case 53: return ref array.Field53;
                case 54: return ref array.Field54;
                case 55: return ref array.Field55;
                case 56: return ref array.Field56;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray57 array1, in FixedLengthCharArray57 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray57 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray57 array1, in FixedLengthCharArray57 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray57 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray57 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray57 array1, in FixedLengthCharArray57 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray57 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray57 array1, in FixedLengthCharArray57 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray57 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 58 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray58
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray58 _Zero = default;
		public static ref readonly FixedLengthCharArray58 Zero => ref _Zero;

		public const int ConstLength = 58;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray58(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
			, Char field20
			, Char field21
			, Char field22
			, Char field23
			, Char field24
			, Char field25
			, Char field26
			, Char field27
			, Char field28
			, Char field29
			, Char field30
			, Char field31
			, Char field32
			, Char field33
			, Char field34
			, Char field35
			, Char field36
			, Char field37
			, Char field38
			, Char field39
			, Char field40
			, Char field41
			, Char field42
			, Char field43
			, Char field44
			, Char field45
			, Char field46
			, Char field47
			, Char field48
			, Char field49
			, Char field50
			, Char field51
			, Char field52
			, Char field53
			, Char field54
			, Char field55
			, Char field56
			, Char field57
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
			Field46 = field46;
			Field47 = field47;
			Field48 = field48;
			Field49 = field49;
			Field50 = field50;
			Field51 = field51;
			Field52 = field52;
			Field53 = field53;
			Field54 = field54;
			Field55 = field55;
			Field56 = field56;
			Field57 = field57;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
		public Char Field20;
		public Char Field21;
		public Char Field22;
		public Char Field23;
		public Char Field24;
		public Char Field25;
		public Char Field26;
		public Char Field27;
		public Char Field28;
		public Char Field29;
		public Char Field30;
		public Char Field31;
		public Char Field32;
		public Char Field33;
		public Char Field34;
		public Char Field35;
		public Char Field36;
		public Char Field37;
		public Char Field38;
		public Char Field39;
		public Char Field40;
		public Char Field41;
		public Char Field42;
		public Char Field43;
		public Char Field44;
		public Char Field45;
		public Char Field46;
		public Char Field47;
		public Char Field48;
		public Char Field49;
		public Char Field50;
		public Char Field51;
		public Char Field52;
		public Char Field53;
		public Char Field54;
		public Char Field55;
		public Char Field56;
		public Char Field57;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                46 => Field46,
                47 => Field47,
                48 => Field48,
                49 => Field49,
                50 => Field50,
                51 => Field51,
                52 => Field52,
                53 => Field53,
                54 => Field54,
                55 => Field55,
                56 => Field56,
                57 => Field57,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
                    case 46: Field46 = value; break;
                    case 47: Field47 = value; break;
                    case 48: Field48 = value; break;
                    case 49: Field49 = value; break;
                    case 50: Field50 = value; break;
                    case 51: Field51 = value; break;
                    case 52: Field52 = value; break;
                    case 53: Field53 = value; break;
                    case 54: Field54 = value; break;
                    case 55: Field55 = value; break;
                    case 56: Field56 = value; break;
                    case 57: Field57 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray58) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray58)other);

        public readonly bool Equals(in FixedLengthCharArray58 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray58 left, in FixedLengthCharArray58 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray58 left, in FixedLengthCharArray58 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
              yield return Field46;
              yield return Field47;
              yield return Field48;
              yield return Field49;
              yield return Field50;
              yield return Field51;
              yield return Field52;
              yield return Field53;
              yield return Field54;
              yield return Field55;
              yield return Field56;
              yield return Field57;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray58 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray58 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray58 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray58 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
                case 46: return ref array.Field46;
                case 47: return ref array.Field47;
                case 48: return ref array.Field48;
                case 49: return ref array.Field49;
                case 50: return ref array.Field50;
                case 51: return ref array.Field51;
                case 52: return ref array.Field52;
                case 53: return ref array.Field53;
                case 54: return ref array.Field54;
                case 55: return ref array.Field55;
                case 56: return ref array.Field56;
                case 57: return ref array.Field57;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray58 array1, in FixedLengthCharArray58 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray58 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray58 array1, in FixedLengthCharArray58 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray58 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray58 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray58 array1, in FixedLengthCharArray58 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray58 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray58 array1, in FixedLengthCharArray58 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray58 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 59 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray59
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray59 _Zero = default;
		public static ref readonly FixedLengthCharArray59 Zero => ref _Zero;

		public const int ConstLength = 59;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray59(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
			, Char field20
			, Char field21
			, Char field22
			, Char field23
			, Char field24
			, Char field25
			, Char field26
			, Char field27
			, Char field28
			, Char field29
			, Char field30
			, Char field31
			, Char field32
			, Char field33
			, Char field34
			, Char field35
			, Char field36
			, Char field37
			, Char field38
			, Char field39
			, Char field40
			, Char field41
			, Char field42
			, Char field43
			, Char field44
			, Char field45
			, Char field46
			, Char field47
			, Char field48
			, Char field49
			, Char field50
			, Char field51
			, Char field52
			, Char field53
			, Char field54
			, Char field55
			, Char field56
			, Char field57
			, Char field58
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
			Field46 = field46;
			Field47 = field47;
			Field48 = field48;
			Field49 = field49;
			Field50 = field50;
			Field51 = field51;
			Field52 = field52;
			Field53 = field53;
			Field54 = field54;
			Field55 = field55;
			Field56 = field56;
			Field57 = field57;
			Field58 = field58;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
		public Char Field20;
		public Char Field21;
		public Char Field22;
		public Char Field23;
		public Char Field24;
		public Char Field25;
		public Char Field26;
		public Char Field27;
		public Char Field28;
		public Char Field29;
		public Char Field30;
		public Char Field31;
		public Char Field32;
		public Char Field33;
		public Char Field34;
		public Char Field35;
		public Char Field36;
		public Char Field37;
		public Char Field38;
		public Char Field39;
		public Char Field40;
		public Char Field41;
		public Char Field42;
		public Char Field43;
		public Char Field44;
		public Char Field45;
		public Char Field46;
		public Char Field47;
		public Char Field48;
		public Char Field49;
		public Char Field50;
		public Char Field51;
		public Char Field52;
		public Char Field53;
		public Char Field54;
		public Char Field55;
		public Char Field56;
		public Char Field57;
		public Char Field58;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                46 => Field46,
                47 => Field47,
                48 => Field48,
                49 => Field49,
                50 => Field50,
                51 => Field51,
                52 => Field52,
                53 => Field53,
                54 => Field54,
                55 => Field55,
                56 => Field56,
                57 => Field57,
                58 => Field58,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
                    case 46: Field46 = value; break;
                    case 47: Field47 = value; break;
                    case 48: Field48 = value; break;
                    case 49: Field49 = value; break;
                    case 50: Field50 = value; break;
                    case 51: Field51 = value; break;
                    case 52: Field52 = value; break;
                    case 53: Field53 = value; break;
                    case 54: Field54 = value; break;
                    case 55: Field55 = value; break;
                    case 56: Field56 = value; break;
                    case 57: Field57 = value; break;
                    case 58: Field58 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray59) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray59)other);

        public readonly bool Equals(in FixedLengthCharArray59 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray59 left, in FixedLengthCharArray59 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray59 left, in FixedLengthCharArray59 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
              yield return Field46;
              yield return Field47;
              yield return Field48;
              yield return Field49;
              yield return Field50;
              yield return Field51;
              yield return Field52;
              yield return Field53;
              yield return Field54;
              yield return Field55;
              yield return Field56;
              yield return Field57;
              yield return Field58;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray59 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray59 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray59 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray59 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
                case 46: return ref array.Field46;
                case 47: return ref array.Field47;
                case 48: return ref array.Field48;
                case 49: return ref array.Field49;
                case 50: return ref array.Field50;
                case 51: return ref array.Field51;
                case 52: return ref array.Field52;
                case 53: return ref array.Field53;
                case 54: return ref array.Field54;
                case 55: return ref array.Field55;
                case 56: return ref array.Field56;
                case 57: return ref array.Field57;
                case 58: return ref array.Field58;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray59 array1, in FixedLengthCharArray59 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray59 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray59 array1, in FixedLengthCharArray59 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray59 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray59 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray59 array1, in FixedLengthCharArray59 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray59 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray59 array1, in FixedLengthCharArray59 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray59 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 60 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray60
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray60 _Zero = default;
		public static ref readonly FixedLengthCharArray60 Zero => ref _Zero;

		public const int ConstLength = 60;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray60(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
			, Char field20
			, Char field21
			, Char field22
			, Char field23
			, Char field24
			, Char field25
			, Char field26
			, Char field27
			, Char field28
			, Char field29
			, Char field30
			, Char field31
			, Char field32
			, Char field33
			, Char field34
			, Char field35
			, Char field36
			, Char field37
			, Char field38
			, Char field39
			, Char field40
			, Char field41
			, Char field42
			, Char field43
			, Char field44
			, Char field45
			, Char field46
			, Char field47
			, Char field48
			, Char field49
			, Char field50
			, Char field51
			, Char field52
			, Char field53
			, Char field54
			, Char field55
			, Char field56
			, Char field57
			, Char field58
			, Char field59
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
			Field46 = field46;
			Field47 = field47;
			Field48 = field48;
			Field49 = field49;
			Field50 = field50;
			Field51 = field51;
			Field52 = field52;
			Field53 = field53;
			Field54 = field54;
			Field55 = field55;
			Field56 = field56;
			Field57 = field57;
			Field58 = field58;
			Field59 = field59;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
		public Char Field20;
		public Char Field21;
		public Char Field22;
		public Char Field23;
		public Char Field24;
		public Char Field25;
		public Char Field26;
		public Char Field27;
		public Char Field28;
		public Char Field29;
		public Char Field30;
		public Char Field31;
		public Char Field32;
		public Char Field33;
		public Char Field34;
		public Char Field35;
		public Char Field36;
		public Char Field37;
		public Char Field38;
		public Char Field39;
		public Char Field40;
		public Char Field41;
		public Char Field42;
		public Char Field43;
		public Char Field44;
		public Char Field45;
		public Char Field46;
		public Char Field47;
		public Char Field48;
		public Char Field49;
		public Char Field50;
		public Char Field51;
		public Char Field52;
		public Char Field53;
		public Char Field54;
		public Char Field55;
		public Char Field56;
		public Char Field57;
		public Char Field58;
		public Char Field59;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                46 => Field46,
                47 => Field47,
                48 => Field48,
                49 => Field49,
                50 => Field50,
                51 => Field51,
                52 => Field52,
                53 => Field53,
                54 => Field54,
                55 => Field55,
                56 => Field56,
                57 => Field57,
                58 => Field58,
                59 => Field59,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
                    case 46: Field46 = value; break;
                    case 47: Field47 = value; break;
                    case 48: Field48 = value; break;
                    case 49: Field49 = value; break;
                    case 50: Field50 = value; break;
                    case 51: Field51 = value; break;
                    case 52: Field52 = value; break;
                    case 53: Field53 = value; break;
                    case 54: Field54 = value; break;
                    case 55: Field55 = value; break;
                    case 56: Field56 = value; break;
                    case 57: Field57 = value; break;
                    case 58: Field58 = value; break;
                    case 59: Field59 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray60) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray60)other);

        public readonly bool Equals(in FixedLengthCharArray60 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray60 left, in FixedLengthCharArray60 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray60 left, in FixedLengthCharArray60 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
              yield return Field46;
              yield return Field47;
              yield return Field48;
              yield return Field49;
              yield return Field50;
              yield return Field51;
              yield return Field52;
              yield return Field53;
              yield return Field54;
              yield return Field55;
              yield return Field56;
              yield return Field57;
              yield return Field58;
              yield return Field59;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray60 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray60 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray60 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray60 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
                case 46: return ref array.Field46;
                case 47: return ref array.Field47;
                case 48: return ref array.Field48;
                case 49: return ref array.Field49;
                case 50: return ref array.Field50;
                case 51: return ref array.Field51;
                case 52: return ref array.Field52;
                case 53: return ref array.Field53;
                case 54: return ref array.Field54;
                case 55: return ref array.Field55;
                case 56: return ref array.Field56;
                case 57: return ref array.Field57;
                case 58: return ref array.Field58;
                case 59: return ref array.Field59;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray60 array1, in FixedLengthCharArray60 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray60 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray60 array1, in FixedLengthCharArray60 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray60 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray60 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray60 array1, in FixedLengthCharArray60 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray60 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray60 array1, in FixedLengthCharArray60 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray60 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 61 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray61
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray61 _Zero = default;
		public static ref readonly FixedLengthCharArray61 Zero => ref _Zero;

		public const int ConstLength = 61;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray61(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
			, Char field20
			, Char field21
			, Char field22
			, Char field23
			, Char field24
			, Char field25
			, Char field26
			, Char field27
			, Char field28
			, Char field29
			, Char field30
			, Char field31
			, Char field32
			, Char field33
			, Char field34
			, Char field35
			, Char field36
			, Char field37
			, Char field38
			, Char field39
			, Char field40
			, Char field41
			, Char field42
			, Char field43
			, Char field44
			, Char field45
			, Char field46
			, Char field47
			, Char field48
			, Char field49
			, Char field50
			, Char field51
			, Char field52
			, Char field53
			, Char field54
			, Char field55
			, Char field56
			, Char field57
			, Char field58
			, Char field59
			, Char field60
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
			Field46 = field46;
			Field47 = field47;
			Field48 = field48;
			Field49 = field49;
			Field50 = field50;
			Field51 = field51;
			Field52 = field52;
			Field53 = field53;
			Field54 = field54;
			Field55 = field55;
			Field56 = field56;
			Field57 = field57;
			Field58 = field58;
			Field59 = field59;
			Field60 = field60;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
		public Char Field20;
		public Char Field21;
		public Char Field22;
		public Char Field23;
		public Char Field24;
		public Char Field25;
		public Char Field26;
		public Char Field27;
		public Char Field28;
		public Char Field29;
		public Char Field30;
		public Char Field31;
		public Char Field32;
		public Char Field33;
		public Char Field34;
		public Char Field35;
		public Char Field36;
		public Char Field37;
		public Char Field38;
		public Char Field39;
		public Char Field40;
		public Char Field41;
		public Char Field42;
		public Char Field43;
		public Char Field44;
		public Char Field45;
		public Char Field46;
		public Char Field47;
		public Char Field48;
		public Char Field49;
		public Char Field50;
		public Char Field51;
		public Char Field52;
		public Char Field53;
		public Char Field54;
		public Char Field55;
		public Char Field56;
		public Char Field57;
		public Char Field58;
		public Char Field59;
		public Char Field60;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                46 => Field46,
                47 => Field47,
                48 => Field48,
                49 => Field49,
                50 => Field50,
                51 => Field51,
                52 => Field52,
                53 => Field53,
                54 => Field54,
                55 => Field55,
                56 => Field56,
                57 => Field57,
                58 => Field58,
                59 => Field59,
                60 => Field60,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
                    case 46: Field46 = value; break;
                    case 47: Field47 = value; break;
                    case 48: Field48 = value; break;
                    case 49: Field49 = value; break;
                    case 50: Field50 = value; break;
                    case 51: Field51 = value; break;
                    case 52: Field52 = value; break;
                    case 53: Field53 = value; break;
                    case 54: Field54 = value; break;
                    case 55: Field55 = value; break;
                    case 56: Field56 = value; break;
                    case 57: Field57 = value; break;
                    case 58: Field58 = value; break;
                    case 59: Field59 = value; break;
                    case 60: Field60 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray61) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray61)other);

        public readonly bool Equals(in FixedLengthCharArray61 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray61 left, in FixedLengthCharArray61 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray61 left, in FixedLengthCharArray61 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
              yield return Field46;
              yield return Field47;
              yield return Field48;
              yield return Field49;
              yield return Field50;
              yield return Field51;
              yield return Field52;
              yield return Field53;
              yield return Field54;
              yield return Field55;
              yield return Field56;
              yield return Field57;
              yield return Field58;
              yield return Field59;
              yield return Field60;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray61 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray61 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray61 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray61 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
                case 46: return ref array.Field46;
                case 47: return ref array.Field47;
                case 48: return ref array.Field48;
                case 49: return ref array.Field49;
                case 50: return ref array.Field50;
                case 51: return ref array.Field51;
                case 52: return ref array.Field52;
                case 53: return ref array.Field53;
                case 54: return ref array.Field54;
                case 55: return ref array.Field55;
                case 56: return ref array.Field56;
                case 57: return ref array.Field57;
                case 58: return ref array.Field58;
                case 59: return ref array.Field59;
                case 60: return ref array.Field60;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray61 array1, in FixedLengthCharArray61 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray61 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray61 array1, in FixedLengthCharArray61 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray61 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray61 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray61 array1, in FixedLengthCharArray61 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray61 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray61 array1, in FixedLengthCharArray61 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray61 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 62 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray62
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray62 _Zero = default;
		public static ref readonly FixedLengthCharArray62 Zero => ref _Zero;

		public const int ConstLength = 62;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray62(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
			, Char field20
			, Char field21
			, Char field22
			, Char field23
			, Char field24
			, Char field25
			, Char field26
			, Char field27
			, Char field28
			, Char field29
			, Char field30
			, Char field31
			, Char field32
			, Char field33
			, Char field34
			, Char field35
			, Char field36
			, Char field37
			, Char field38
			, Char field39
			, Char field40
			, Char field41
			, Char field42
			, Char field43
			, Char field44
			, Char field45
			, Char field46
			, Char field47
			, Char field48
			, Char field49
			, Char field50
			, Char field51
			, Char field52
			, Char field53
			, Char field54
			, Char field55
			, Char field56
			, Char field57
			, Char field58
			, Char field59
			, Char field60
			, Char field61
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
			Field46 = field46;
			Field47 = field47;
			Field48 = field48;
			Field49 = field49;
			Field50 = field50;
			Field51 = field51;
			Field52 = field52;
			Field53 = field53;
			Field54 = field54;
			Field55 = field55;
			Field56 = field56;
			Field57 = field57;
			Field58 = field58;
			Field59 = field59;
			Field60 = field60;
			Field61 = field61;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
		public Char Field20;
		public Char Field21;
		public Char Field22;
		public Char Field23;
		public Char Field24;
		public Char Field25;
		public Char Field26;
		public Char Field27;
		public Char Field28;
		public Char Field29;
		public Char Field30;
		public Char Field31;
		public Char Field32;
		public Char Field33;
		public Char Field34;
		public Char Field35;
		public Char Field36;
		public Char Field37;
		public Char Field38;
		public Char Field39;
		public Char Field40;
		public Char Field41;
		public Char Field42;
		public Char Field43;
		public Char Field44;
		public Char Field45;
		public Char Field46;
		public Char Field47;
		public Char Field48;
		public Char Field49;
		public Char Field50;
		public Char Field51;
		public Char Field52;
		public Char Field53;
		public Char Field54;
		public Char Field55;
		public Char Field56;
		public Char Field57;
		public Char Field58;
		public Char Field59;
		public Char Field60;
		public Char Field61;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                46 => Field46,
                47 => Field47,
                48 => Field48,
                49 => Field49,
                50 => Field50,
                51 => Field51,
                52 => Field52,
                53 => Field53,
                54 => Field54,
                55 => Field55,
                56 => Field56,
                57 => Field57,
                58 => Field58,
                59 => Field59,
                60 => Field60,
                61 => Field61,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
                    case 46: Field46 = value; break;
                    case 47: Field47 = value; break;
                    case 48: Field48 = value; break;
                    case 49: Field49 = value; break;
                    case 50: Field50 = value; break;
                    case 51: Field51 = value; break;
                    case 52: Field52 = value; break;
                    case 53: Field53 = value; break;
                    case 54: Field54 = value; break;
                    case 55: Field55 = value; break;
                    case 56: Field56 = value; break;
                    case 57: Field57 = value; break;
                    case 58: Field58 = value; break;
                    case 59: Field59 = value; break;
                    case 60: Field60 = value; break;
                    case 61: Field61 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray62) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray62)other);

        public readonly bool Equals(in FixedLengthCharArray62 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray62 left, in FixedLengthCharArray62 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray62 left, in FixedLengthCharArray62 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
              yield return Field46;
              yield return Field47;
              yield return Field48;
              yield return Field49;
              yield return Field50;
              yield return Field51;
              yield return Field52;
              yield return Field53;
              yield return Field54;
              yield return Field55;
              yield return Field56;
              yield return Field57;
              yield return Field58;
              yield return Field59;
              yield return Field60;
              yield return Field61;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray62 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray62 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray62 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray62 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
                case 46: return ref array.Field46;
                case 47: return ref array.Field47;
                case 48: return ref array.Field48;
                case 49: return ref array.Field49;
                case 50: return ref array.Field50;
                case 51: return ref array.Field51;
                case 52: return ref array.Field52;
                case 53: return ref array.Field53;
                case 54: return ref array.Field54;
                case 55: return ref array.Field55;
                case 56: return ref array.Field56;
                case 57: return ref array.Field57;
                case 58: return ref array.Field58;
                case 59: return ref array.Field59;
                case 60: return ref array.Field60;
                case 61: return ref array.Field61;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray62 array1, in FixedLengthCharArray62 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray62 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray62 array1, in FixedLengthCharArray62 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray62 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray62 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray62 array1, in FixedLengthCharArray62 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray62 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray62 array1, in FixedLengthCharArray62 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray62 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 63 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray63
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray63 _Zero = default;
		public static ref readonly FixedLengthCharArray63 Zero => ref _Zero;

		public const int ConstLength = 63;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray63(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
			, Char field20
			, Char field21
			, Char field22
			, Char field23
			, Char field24
			, Char field25
			, Char field26
			, Char field27
			, Char field28
			, Char field29
			, Char field30
			, Char field31
			, Char field32
			, Char field33
			, Char field34
			, Char field35
			, Char field36
			, Char field37
			, Char field38
			, Char field39
			, Char field40
			, Char field41
			, Char field42
			, Char field43
			, Char field44
			, Char field45
			, Char field46
			, Char field47
			, Char field48
			, Char field49
			, Char field50
			, Char field51
			, Char field52
			, Char field53
			, Char field54
			, Char field55
			, Char field56
			, Char field57
			, Char field58
			, Char field59
			, Char field60
			, Char field61
			, Char field62
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
			Field46 = field46;
			Field47 = field47;
			Field48 = field48;
			Field49 = field49;
			Field50 = field50;
			Field51 = field51;
			Field52 = field52;
			Field53 = field53;
			Field54 = field54;
			Field55 = field55;
			Field56 = field56;
			Field57 = field57;
			Field58 = field58;
			Field59 = field59;
			Field60 = field60;
			Field61 = field61;
			Field62 = field62;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
		public Char Field20;
		public Char Field21;
		public Char Field22;
		public Char Field23;
		public Char Field24;
		public Char Field25;
		public Char Field26;
		public Char Field27;
		public Char Field28;
		public Char Field29;
		public Char Field30;
		public Char Field31;
		public Char Field32;
		public Char Field33;
		public Char Field34;
		public Char Field35;
		public Char Field36;
		public Char Field37;
		public Char Field38;
		public Char Field39;
		public Char Field40;
		public Char Field41;
		public Char Field42;
		public Char Field43;
		public Char Field44;
		public Char Field45;
		public Char Field46;
		public Char Field47;
		public Char Field48;
		public Char Field49;
		public Char Field50;
		public Char Field51;
		public Char Field52;
		public Char Field53;
		public Char Field54;
		public Char Field55;
		public Char Field56;
		public Char Field57;
		public Char Field58;
		public Char Field59;
		public Char Field60;
		public Char Field61;
		public Char Field62;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                46 => Field46,
                47 => Field47,
                48 => Field48,
                49 => Field49,
                50 => Field50,
                51 => Field51,
                52 => Field52,
                53 => Field53,
                54 => Field54,
                55 => Field55,
                56 => Field56,
                57 => Field57,
                58 => Field58,
                59 => Field59,
                60 => Field60,
                61 => Field61,
                62 => Field62,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
                    case 46: Field46 = value; break;
                    case 47: Field47 = value; break;
                    case 48: Field48 = value; break;
                    case 49: Field49 = value; break;
                    case 50: Field50 = value; break;
                    case 51: Field51 = value; break;
                    case 52: Field52 = value; break;
                    case 53: Field53 = value; break;
                    case 54: Field54 = value; break;
                    case 55: Field55 = value; break;
                    case 56: Field56 = value; break;
                    case 57: Field57 = value; break;
                    case 58: Field58 = value; break;
                    case 59: Field59 = value; break;
                    case 60: Field60 = value; break;
                    case 61: Field61 = value; break;
                    case 62: Field62 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray63) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray63)other);

        public readonly bool Equals(in FixedLengthCharArray63 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray63 left, in FixedLengthCharArray63 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray63 left, in FixedLengthCharArray63 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
              yield return Field46;
              yield return Field47;
              yield return Field48;
              yield return Field49;
              yield return Field50;
              yield return Field51;
              yield return Field52;
              yield return Field53;
              yield return Field54;
              yield return Field55;
              yield return Field56;
              yield return Field57;
              yield return Field58;
              yield return Field59;
              yield return Field60;
              yield return Field61;
              yield return Field62;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray63 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray63 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray63 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray63 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
                case 46: return ref array.Field46;
                case 47: return ref array.Field47;
                case 48: return ref array.Field48;
                case 49: return ref array.Field49;
                case 50: return ref array.Field50;
                case 51: return ref array.Field51;
                case 52: return ref array.Field52;
                case 53: return ref array.Field53;
                case 54: return ref array.Field54;
                case 55: return ref array.Field55;
                case 56: return ref array.Field56;
                case 57: return ref array.Field57;
                case 58: return ref array.Field58;
                case 59: return ref array.Field59;
                case 60: return ref array.Field60;
                case 61: return ref array.Field61;
                case 62: return ref array.Field62;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray63 array1, in FixedLengthCharArray63 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray63 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray63 array1, in FixedLengthCharArray63 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray63 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray63 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray63 array1, in FixedLengthCharArray63 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray63 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray63 array1, in FixedLengthCharArray63 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray63 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 64 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray64
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray64 _Zero = default;
		public static ref readonly FixedLengthCharArray64 Zero => ref _Zero;

		public const int ConstLength = 64;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray64(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
			, Char field20
			, Char field21
			, Char field22
			, Char field23
			, Char field24
			, Char field25
			, Char field26
			, Char field27
			, Char field28
			, Char field29
			, Char field30
			, Char field31
			, Char field32
			, Char field33
			, Char field34
			, Char field35
			, Char field36
			, Char field37
			, Char field38
			, Char field39
			, Char field40
			, Char field41
			, Char field42
			, Char field43
			, Char field44
			, Char field45
			, Char field46
			, Char field47
			, Char field48
			, Char field49
			, Char field50
			, Char field51
			, Char field52
			, Char field53
			, Char field54
			, Char field55
			, Char field56
			, Char field57
			, Char field58
			, Char field59
			, Char field60
			, Char field61
			, Char field62
			, Char field63
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
			Field46 = field46;
			Field47 = field47;
			Field48 = field48;
			Field49 = field49;
			Field50 = field50;
			Field51 = field51;
			Field52 = field52;
			Field53 = field53;
			Field54 = field54;
			Field55 = field55;
			Field56 = field56;
			Field57 = field57;
			Field58 = field58;
			Field59 = field59;
			Field60 = field60;
			Field61 = field61;
			Field62 = field62;
			Field63 = field63;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
		public Char Field20;
		public Char Field21;
		public Char Field22;
		public Char Field23;
		public Char Field24;
		public Char Field25;
		public Char Field26;
		public Char Field27;
		public Char Field28;
		public Char Field29;
		public Char Field30;
		public Char Field31;
		public Char Field32;
		public Char Field33;
		public Char Field34;
		public Char Field35;
		public Char Field36;
		public Char Field37;
		public Char Field38;
		public Char Field39;
		public Char Field40;
		public Char Field41;
		public Char Field42;
		public Char Field43;
		public Char Field44;
		public Char Field45;
		public Char Field46;
		public Char Field47;
		public Char Field48;
		public Char Field49;
		public Char Field50;
		public Char Field51;
		public Char Field52;
		public Char Field53;
		public Char Field54;
		public Char Field55;
		public Char Field56;
		public Char Field57;
		public Char Field58;
		public Char Field59;
		public Char Field60;
		public Char Field61;
		public Char Field62;
		public Char Field63;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                46 => Field46,
                47 => Field47,
                48 => Field48,
                49 => Field49,
                50 => Field50,
                51 => Field51,
                52 => Field52,
                53 => Field53,
                54 => Field54,
                55 => Field55,
                56 => Field56,
                57 => Field57,
                58 => Field58,
                59 => Field59,
                60 => Field60,
                61 => Field61,
                62 => Field62,
                63 => Field63,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
                    case 46: Field46 = value; break;
                    case 47: Field47 = value; break;
                    case 48: Field48 = value; break;
                    case 49: Field49 = value; break;
                    case 50: Field50 = value; break;
                    case 51: Field51 = value; break;
                    case 52: Field52 = value; break;
                    case 53: Field53 = value; break;
                    case 54: Field54 = value; break;
                    case 55: Field55 = value; break;
                    case 56: Field56 = value; break;
                    case 57: Field57 = value; break;
                    case 58: Field58 = value; break;
                    case 59: Field59 = value; break;
                    case 60: Field60 = value; break;
                    case 61: Field61 = value; break;
                    case 62: Field62 = value; break;
                    case 63: Field63 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray64) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray64)other);

        public readonly bool Equals(in FixedLengthCharArray64 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray64 left, in FixedLengthCharArray64 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray64 left, in FixedLengthCharArray64 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
              yield return Field46;
              yield return Field47;
              yield return Field48;
              yield return Field49;
              yield return Field50;
              yield return Field51;
              yield return Field52;
              yield return Field53;
              yield return Field54;
              yield return Field55;
              yield return Field56;
              yield return Field57;
              yield return Field58;
              yield return Field59;
              yield return Field60;
              yield return Field61;
              yield return Field62;
              yield return Field63;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray64 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray64 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray64 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray64 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
                case 46: return ref array.Field46;
                case 47: return ref array.Field47;
                case 48: return ref array.Field48;
                case 49: return ref array.Field49;
                case 50: return ref array.Field50;
                case 51: return ref array.Field51;
                case 52: return ref array.Field52;
                case 53: return ref array.Field53;
                case 54: return ref array.Field54;
                case 55: return ref array.Field55;
                case 56: return ref array.Field56;
                case 57: return ref array.Field57;
                case 58: return ref array.Field58;
                case 59: return ref array.Field59;
                case 60: return ref array.Field60;
                case 61: return ref array.Field61;
                case 62: return ref array.Field62;
                case 63: return ref array.Field63;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray64 array1, in FixedLengthCharArray64 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray64 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray64 array1, in FixedLengthCharArray64 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray64 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray64 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray64 array1, in FixedLengthCharArray64 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray64 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray64 array1, in FixedLengthCharArray64 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray64 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 65 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray65
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray65 _Zero = default;
		public static ref readonly FixedLengthCharArray65 Zero => ref _Zero;

		public const int ConstLength = 65;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray65(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
			, Char field20
			, Char field21
			, Char field22
			, Char field23
			, Char field24
			, Char field25
			, Char field26
			, Char field27
			, Char field28
			, Char field29
			, Char field30
			, Char field31
			, Char field32
			, Char field33
			, Char field34
			, Char field35
			, Char field36
			, Char field37
			, Char field38
			, Char field39
			, Char field40
			, Char field41
			, Char field42
			, Char field43
			, Char field44
			, Char field45
			, Char field46
			, Char field47
			, Char field48
			, Char field49
			, Char field50
			, Char field51
			, Char field52
			, Char field53
			, Char field54
			, Char field55
			, Char field56
			, Char field57
			, Char field58
			, Char field59
			, Char field60
			, Char field61
			, Char field62
			, Char field63
			, Char field64
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
			Field46 = field46;
			Field47 = field47;
			Field48 = field48;
			Field49 = field49;
			Field50 = field50;
			Field51 = field51;
			Field52 = field52;
			Field53 = field53;
			Field54 = field54;
			Field55 = field55;
			Field56 = field56;
			Field57 = field57;
			Field58 = field58;
			Field59 = field59;
			Field60 = field60;
			Field61 = field61;
			Field62 = field62;
			Field63 = field63;
			Field64 = field64;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
		public Char Field20;
		public Char Field21;
		public Char Field22;
		public Char Field23;
		public Char Field24;
		public Char Field25;
		public Char Field26;
		public Char Field27;
		public Char Field28;
		public Char Field29;
		public Char Field30;
		public Char Field31;
		public Char Field32;
		public Char Field33;
		public Char Field34;
		public Char Field35;
		public Char Field36;
		public Char Field37;
		public Char Field38;
		public Char Field39;
		public Char Field40;
		public Char Field41;
		public Char Field42;
		public Char Field43;
		public Char Field44;
		public Char Field45;
		public Char Field46;
		public Char Field47;
		public Char Field48;
		public Char Field49;
		public Char Field50;
		public Char Field51;
		public Char Field52;
		public Char Field53;
		public Char Field54;
		public Char Field55;
		public Char Field56;
		public Char Field57;
		public Char Field58;
		public Char Field59;
		public Char Field60;
		public Char Field61;
		public Char Field62;
		public Char Field63;
		public Char Field64;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                46 => Field46,
                47 => Field47,
                48 => Field48,
                49 => Field49,
                50 => Field50,
                51 => Field51,
                52 => Field52,
                53 => Field53,
                54 => Field54,
                55 => Field55,
                56 => Field56,
                57 => Field57,
                58 => Field58,
                59 => Field59,
                60 => Field60,
                61 => Field61,
                62 => Field62,
                63 => Field63,
                64 => Field64,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
                    case 46: Field46 = value; break;
                    case 47: Field47 = value; break;
                    case 48: Field48 = value; break;
                    case 49: Field49 = value; break;
                    case 50: Field50 = value; break;
                    case 51: Field51 = value; break;
                    case 52: Field52 = value; break;
                    case 53: Field53 = value; break;
                    case 54: Field54 = value; break;
                    case 55: Field55 = value; break;
                    case 56: Field56 = value; break;
                    case 57: Field57 = value; break;
                    case 58: Field58 = value; break;
                    case 59: Field59 = value; break;
                    case 60: Field60 = value; break;
                    case 61: Field61 = value; break;
                    case 62: Field62 = value; break;
                    case 63: Field63 = value; break;
                    case 64: Field64 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray65) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray65)other);

        public readonly bool Equals(in FixedLengthCharArray65 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray65 left, in FixedLengthCharArray65 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray65 left, in FixedLengthCharArray65 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
              yield return Field46;
              yield return Field47;
              yield return Field48;
              yield return Field49;
              yield return Field50;
              yield return Field51;
              yield return Field52;
              yield return Field53;
              yield return Field54;
              yield return Field55;
              yield return Field56;
              yield return Field57;
              yield return Field58;
              yield return Field59;
              yield return Field60;
              yield return Field61;
              yield return Field62;
              yield return Field63;
              yield return Field64;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray65 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray65 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray65 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray65 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
                case 46: return ref array.Field46;
                case 47: return ref array.Field47;
                case 48: return ref array.Field48;
                case 49: return ref array.Field49;
                case 50: return ref array.Field50;
                case 51: return ref array.Field51;
                case 52: return ref array.Field52;
                case 53: return ref array.Field53;
                case 54: return ref array.Field54;
                case 55: return ref array.Field55;
                case 56: return ref array.Field56;
                case 57: return ref array.Field57;
                case 58: return ref array.Field58;
                case 59: return ref array.Field59;
                case 60: return ref array.Field60;
                case 61: return ref array.Field61;
                case 62: return ref array.Field62;
                case 63: return ref array.Field63;
                case 64: return ref array.Field64;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray65 array1, in FixedLengthCharArray65 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray65 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray65 array1, in FixedLengthCharArray65 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray65 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray65 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray65 array1, in FixedLengthCharArray65 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray65 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray65 array1, in FixedLengthCharArray65 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray65 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 66 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray66
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray66 _Zero = default;
		public static ref readonly FixedLengthCharArray66 Zero => ref _Zero;

		public const int ConstLength = 66;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray66(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
			, Char field20
			, Char field21
			, Char field22
			, Char field23
			, Char field24
			, Char field25
			, Char field26
			, Char field27
			, Char field28
			, Char field29
			, Char field30
			, Char field31
			, Char field32
			, Char field33
			, Char field34
			, Char field35
			, Char field36
			, Char field37
			, Char field38
			, Char field39
			, Char field40
			, Char field41
			, Char field42
			, Char field43
			, Char field44
			, Char field45
			, Char field46
			, Char field47
			, Char field48
			, Char field49
			, Char field50
			, Char field51
			, Char field52
			, Char field53
			, Char field54
			, Char field55
			, Char field56
			, Char field57
			, Char field58
			, Char field59
			, Char field60
			, Char field61
			, Char field62
			, Char field63
			, Char field64
			, Char field65
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
			Field46 = field46;
			Field47 = field47;
			Field48 = field48;
			Field49 = field49;
			Field50 = field50;
			Field51 = field51;
			Field52 = field52;
			Field53 = field53;
			Field54 = field54;
			Field55 = field55;
			Field56 = field56;
			Field57 = field57;
			Field58 = field58;
			Field59 = field59;
			Field60 = field60;
			Field61 = field61;
			Field62 = field62;
			Field63 = field63;
			Field64 = field64;
			Field65 = field65;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
		public Char Field20;
		public Char Field21;
		public Char Field22;
		public Char Field23;
		public Char Field24;
		public Char Field25;
		public Char Field26;
		public Char Field27;
		public Char Field28;
		public Char Field29;
		public Char Field30;
		public Char Field31;
		public Char Field32;
		public Char Field33;
		public Char Field34;
		public Char Field35;
		public Char Field36;
		public Char Field37;
		public Char Field38;
		public Char Field39;
		public Char Field40;
		public Char Field41;
		public Char Field42;
		public Char Field43;
		public Char Field44;
		public Char Field45;
		public Char Field46;
		public Char Field47;
		public Char Field48;
		public Char Field49;
		public Char Field50;
		public Char Field51;
		public Char Field52;
		public Char Field53;
		public Char Field54;
		public Char Field55;
		public Char Field56;
		public Char Field57;
		public Char Field58;
		public Char Field59;
		public Char Field60;
		public Char Field61;
		public Char Field62;
		public Char Field63;
		public Char Field64;
		public Char Field65;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                46 => Field46,
                47 => Field47,
                48 => Field48,
                49 => Field49,
                50 => Field50,
                51 => Field51,
                52 => Field52,
                53 => Field53,
                54 => Field54,
                55 => Field55,
                56 => Field56,
                57 => Field57,
                58 => Field58,
                59 => Field59,
                60 => Field60,
                61 => Field61,
                62 => Field62,
                63 => Field63,
                64 => Field64,
                65 => Field65,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
                    case 46: Field46 = value; break;
                    case 47: Field47 = value; break;
                    case 48: Field48 = value; break;
                    case 49: Field49 = value; break;
                    case 50: Field50 = value; break;
                    case 51: Field51 = value; break;
                    case 52: Field52 = value; break;
                    case 53: Field53 = value; break;
                    case 54: Field54 = value; break;
                    case 55: Field55 = value; break;
                    case 56: Field56 = value; break;
                    case 57: Field57 = value; break;
                    case 58: Field58 = value; break;
                    case 59: Field59 = value; break;
                    case 60: Field60 = value; break;
                    case 61: Field61 = value; break;
                    case 62: Field62 = value; break;
                    case 63: Field63 = value; break;
                    case 64: Field64 = value; break;
                    case 65: Field65 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray66) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray66)other);

        public readonly bool Equals(in FixedLengthCharArray66 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray66 left, in FixedLengthCharArray66 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray66 left, in FixedLengthCharArray66 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
              yield return Field46;
              yield return Field47;
              yield return Field48;
              yield return Field49;
              yield return Field50;
              yield return Field51;
              yield return Field52;
              yield return Field53;
              yield return Field54;
              yield return Field55;
              yield return Field56;
              yield return Field57;
              yield return Field58;
              yield return Field59;
              yield return Field60;
              yield return Field61;
              yield return Field62;
              yield return Field63;
              yield return Field64;
              yield return Field65;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray66 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray66 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray66 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray66 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
                case 46: return ref array.Field46;
                case 47: return ref array.Field47;
                case 48: return ref array.Field48;
                case 49: return ref array.Field49;
                case 50: return ref array.Field50;
                case 51: return ref array.Field51;
                case 52: return ref array.Field52;
                case 53: return ref array.Field53;
                case 54: return ref array.Field54;
                case 55: return ref array.Field55;
                case 56: return ref array.Field56;
                case 57: return ref array.Field57;
                case 58: return ref array.Field58;
                case 59: return ref array.Field59;
                case 60: return ref array.Field60;
                case 61: return ref array.Field61;
                case 62: return ref array.Field62;
                case 63: return ref array.Field63;
                case 64: return ref array.Field64;
                case 65: return ref array.Field65;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray66 array1, in FixedLengthCharArray66 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray66 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray66 array1, in FixedLengthCharArray66 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray66 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray66 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray66 array1, in FixedLengthCharArray66 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray66 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray66 array1, in FixedLengthCharArray66 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray66 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 260 * sizeof(Char), CharSet = CharSet.Unicode)]
	public struct FixedLengthCharArray260
#if GENERATE_ENUMERABLE
		: IEnumerable<Char>
#endif
	{
		private static readonly FixedLengthCharArray260 _Zero = default;
		public static ref readonly FixedLengthCharArray260 Zero => ref _Zero;

		public const int ConstLength = 260;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthCharArray260(
			Char field0
			, Char field1
			, Char field2
			, Char field3
			, Char field4
			, Char field5
			, Char field6
			, Char field7
			, Char field8
			, Char field9
			, Char field10
			, Char field11
			, Char field12
			, Char field13
			, Char field14
			, Char field15
			, Char field16
			, Char field17
			, Char field18
			, Char field19
			, Char field20
			, Char field21
			, Char field22
			, Char field23
			, Char field24
			, Char field25
			, Char field26
			, Char field27
			, Char field28
			, Char field29
			, Char field30
			, Char field31
			, Char field32
			, Char field33
			, Char field34
			, Char field35
			, Char field36
			, Char field37
			, Char field38
			, Char field39
			, Char field40
			, Char field41
			, Char field42
			, Char field43
			, Char field44
			, Char field45
			, Char field46
			, Char field47
			, Char field48
			, Char field49
			, Char field50
			, Char field51
			, Char field52
			, Char field53
			, Char field54
			, Char field55
			, Char field56
			, Char field57
			, Char field58
			, Char field59
			, Char field60
			, Char field61
			, Char field62
			, Char field63
			, Char field64
			, Char field65
			, Char field66
			, Char field67
			, Char field68
			, Char field69
			, Char field70
			, Char field71
			, Char field72
			, Char field73
			, Char field74
			, Char field75
			, Char field76
			, Char field77
			, Char field78
			, Char field79
			, Char field80
			, Char field81
			, Char field82
			, Char field83
			, Char field84
			, Char field85
			, Char field86
			, Char field87
			, Char field88
			, Char field89
			, Char field90
			, Char field91
			, Char field92
			, Char field93
			, Char field94
			, Char field95
			, Char field96
			, Char field97
			, Char field98
			, Char field99
			, Char field100
			, Char field101
			, Char field102
			, Char field103
			, Char field104
			, Char field105
			, Char field106
			, Char field107
			, Char field108
			, Char field109
			, Char field110
			, Char field111
			, Char field112
			, Char field113
			, Char field114
			, Char field115
			, Char field116
			, Char field117
			, Char field118
			, Char field119
			, Char field120
			, Char field121
			, Char field122
			, Char field123
			, Char field124
			, Char field125
			, Char field126
			, Char field127
			, Char field128
			, Char field129
			, Char field130
			, Char field131
			, Char field132
			, Char field133
			, Char field134
			, Char field135
			, Char field136
			, Char field137
			, Char field138
			, Char field139
			, Char field140
			, Char field141
			, Char field142
			, Char field143
			, Char field144
			, Char field145
			, Char field146
			, Char field147
			, Char field148
			, Char field149
			, Char field150
			, Char field151
			, Char field152
			, Char field153
			, Char field154
			, Char field155
			, Char field156
			, Char field157
			, Char field158
			, Char field159
			, Char field160
			, Char field161
			, Char field162
			, Char field163
			, Char field164
			, Char field165
			, Char field166
			, Char field167
			, Char field168
			, Char field169
			, Char field170
			, Char field171
			, Char field172
			, Char field173
			, Char field174
			, Char field175
			, Char field176
			, Char field177
			, Char field178
			, Char field179
			, Char field180
			, Char field181
			, Char field182
			, Char field183
			, Char field184
			, Char field185
			, Char field186
			, Char field187
			, Char field188
			, Char field189
			, Char field190
			, Char field191
			, Char field192
			, Char field193
			, Char field194
			, Char field195
			, Char field196
			, Char field197
			, Char field198
			, Char field199
			, Char field200
			, Char field201
			, Char field202
			, Char field203
			, Char field204
			, Char field205
			, Char field206
			, Char field207
			, Char field208
			, Char field209
			, Char field210
			, Char field211
			, Char field212
			, Char field213
			, Char field214
			, Char field215
			, Char field216
			, Char field217
			, Char field218
			, Char field219
			, Char field220
			, Char field221
			, Char field222
			, Char field223
			, Char field224
			, Char field225
			, Char field226
			, Char field227
			, Char field228
			, Char field229
			, Char field230
			, Char field231
			, Char field232
			, Char field233
			, Char field234
			, Char field235
			, Char field236
			, Char field237
			, Char field238
			, Char field239
			, Char field240
			, Char field241
			, Char field242
			, Char field243
			, Char field244
			, Char field245
			, Char field246
			, Char field247
			, Char field248
			, Char field249
			, Char field250
			, Char field251
			, Char field252
			, Char field253
			, Char field254
			, Char field255
			, Char field256
			, Char field257
			, Char field258
			, Char field259
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
			Field32 = field32;
			Field33 = field33;
			Field34 = field34;
			Field35 = field35;
			Field36 = field36;
			Field37 = field37;
			Field38 = field38;
			Field39 = field39;
			Field40 = field40;
			Field41 = field41;
			Field42 = field42;
			Field43 = field43;
			Field44 = field44;
			Field45 = field45;
			Field46 = field46;
			Field47 = field47;
			Field48 = field48;
			Field49 = field49;
			Field50 = field50;
			Field51 = field51;
			Field52 = field52;
			Field53 = field53;
			Field54 = field54;
			Field55 = field55;
			Field56 = field56;
			Field57 = field57;
			Field58 = field58;
			Field59 = field59;
			Field60 = field60;
			Field61 = field61;
			Field62 = field62;
			Field63 = field63;
			Field64 = field64;
			Field65 = field65;
			Field66 = field66;
			Field67 = field67;
			Field68 = field68;
			Field69 = field69;
			Field70 = field70;
			Field71 = field71;
			Field72 = field72;
			Field73 = field73;
			Field74 = field74;
			Field75 = field75;
			Field76 = field76;
			Field77 = field77;
			Field78 = field78;
			Field79 = field79;
			Field80 = field80;
			Field81 = field81;
			Field82 = field82;
			Field83 = field83;
			Field84 = field84;
			Field85 = field85;
			Field86 = field86;
			Field87 = field87;
			Field88 = field88;
			Field89 = field89;
			Field90 = field90;
			Field91 = field91;
			Field92 = field92;
			Field93 = field93;
			Field94 = field94;
			Field95 = field95;
			Field96 = field96;
			Field97 = field97;
			Field98 = field98;
			Field99 = field99;
			Field100 = field100;
			Field101 = field101;
			Field102 = field102;
			Field103 = field103;
			Field104 = field104;
			Field105 = field105;
			Field106 = field106;
			Field107 = field107;
			Field108 = field108;
			Field109 = field109;
			Field110 = field110;
			Field111 = field111;
			Field112 = field112;
			Field113 = field113;
			Field114 = field114;
			Field115 = field115;
			Field116 = field116;
			Field117 = field117;
			Field118 = field118;
			Field119 = field119;
			Field120 = field120;
			Field121 = field121;
			Field122 = field122;
			Field123 = field123;
			Field124 = field124;
			Field125 = field125;
			Field126 = field126;
			Field127 = field127;
			Field128 = field128;
			Field129 = field129;
			Field130 = field130;
			Field131 = field131;
			Field132 = field132;
			Field133 = field133;
			Field134 = field134;
			Field135 = field135;
			Field136 = field136;
			Field137 = field137;
			Field138 = field138;
			Field139 = field139;
			Field140 = field140;
			Field141 = field141;
			Field142 = field142;
			Field143 = field143;
			Field144 = field144;
			Field145 = field145;
			Field146 = field146;
			Field147 = field147;
			Field148 = field148;
			Field149 = field149;
			Field150 = field150;
			Field151 = field151;
			Field152 = field152;
			Field153 = field153;
			Field154 = field154;
			Field155 = field155;
			Field156 = field156;
			Field157 = field157;
			Field158 = field158;
			Field159 = field159;
			Field160 = field160;
			Field161 = field161;
			Field162 = field162;
			Field163 = field163;
			Field164 = field164;
			Field165 = field165;
			Field166 = field166;
			Field167 = field167;
			Field168 = field168;
			Field169 = field169;
			Field170 = field170;
			Field171 = field171;
			Field172 = field172;
			Field173 = field173;
			Field174 = field174;
			Field175 = field175;
			Field176 = field176;
			Field177 = field177;
			Field178 = field178;
			Field179 = field179;
			Field180 = field180;
			Field181 = field181;
			Field182 = field182;
			Field183 = field183;
			Field184 = field184;
			Field185 = field185;
			Field186 = field186;
			Field187 = field187;
			Field188 = field188;
			Field189 = field189;
			Field190 = field190;
			Field191 = field191;
			Field192 = field192;
			Field193 = field193;
			Field194 = field194;
			Field195 = field195;
			Field196 = field196;
			Field197 = field197;
			Field198 = field198;
			Field199 = field199;
			Field200 = field200;
			Field201 = field201;
			Field202 = field202;
			Field203 = field203;
			Field204 = field204;
			Field205 = field205;
			Field206 = field206;
			Field207 = field207;
			Field208 = field208;
			Field209 = field209;
			Field210 = field210;
			Field211 = field211;
			Field212 = field212;
			Field213 = field213;
			Field214 = field214;
			Field215 = field215;
			Field216 = field216;
			Field217 = field217;
			Field218 = field218;
			Field219 = field219;
			Field220 = field220;
			Field221 = field221;
			Field222 = field222;
			Field223 = field223;
			Field224 = field224;
			Field225 = field225;
			Field226 = field226;
			Field227 = field227;
			Field228 = field228;
			Field229 = field229;
			Field230 = field230;
			Field231 = field231;
			Field232 = field232;
			Field233 = field233;
			Field234 = field234;
			Field235 = field235;
			Field236 = field236;
			Field237 = field237;
			Field238 = field238;
			Field239 = field239;
			Field240 = field240;
			Field241 = field241;
			Field242 = field242;
			Field243 = field243;
			Field244 = field244;
			Field245 = field245;
			Field246 = field246;
			Field247 = field247;
			Field248 = field248;
			Field249 = field249;
			Field250 = field250;
			Field251 = field251;
			Field252 = field252;
			Field253 = field253;
			Field254 = field254;
			Field255 = field255;
			Field256 = field256;
			Field257 = field257;
			Field258 = field258;
			Field259 = field259;
		}
#endif
		public Char Field0;
#if GENERATE_ALL_FIELDS
		public Char Field1;
		public Char Field2;
		public Char Field3;
		public Char Field4;
		public Char Field5;
		public Char Field6;
		public Char Field7;
		public Char Field8;
		public Char Field9;
		public Char Field10;
		public Char Field11;
		public Char Field12;
		public Char Field13;
		public Char Field14;
		public Char Field15;
		public Char Field16;
		public Char Field17;
		public Char Field18;
		public Char Field19;
		public Char Field20;
		public Char Field21;
		public Char Field22;
		public Char Field23;
		public Char Field24;
		public Char Field25;
		public Char Field26;
		public Char Field27;
		public Char Field28;
		public Char Field29;
		public Char Field30;
		public Char Field31;
		public Char Field32;
		public Char Field33;
		public Char Field34;
		public Char Field35;
		public Char Field36;
		public Char Field37;
		public Char Field38;
		public Char Field39;
		public Char Field40;
		public Char Field41;
		public Char Field42;
		public Char Field43;
		public Char Field44;
		public Char Field45;
		public Char Field46;
		public Char Field47;
		public Char Field48;
		public Char Field49;
		public Char Field50;
		public Char Field51;
		public Char Field52;
		public Char Field53;
		public Char Field54;
		public Char Field55;
		public Char Field56;
		public Char Field57;
		public Char Field58;
		public Char Field59;
		public Char Field60;
		public Char Field61;
		public Char Field62;
		public Char Field63;
		public Char Field64;
		public Char Field65;
		public Char Field66;
		public Char Field67;
		public Char Field68;
		public Char Field69;
		public Char Field70;
		public Char Field71;
		public Char Field72;
		public Char Field73;
		public Char Field74;
		public Char Field75;
		public Char Field76;
		public Char Field77;
		public Char Field78;
		public Char Field79;
		public Char Field80;
		public Char Field81;
		public Char Field82;
		public Char Field83;
		public Char Field84;
		public Char Field85;
		public Char Field86;
		public Char Field87;
		public Char Field88;
		public Char Field89;
		public Char Field90;
		public Char Field91;
		public Char Field92;
		public Char Field93;
		public Char Field94;
		public Char Field95;
		public Char Field96;
		public Char Field97;
		public Char Field98;
		public Char Field99;
		public Char Field100;
		public Char Field101;
		public Char Field102;
		public Char Field103;
		public Char Field104;
		public Char Field105;
		public Char Field106;
		public Char Field107;
		public Char Field108;
		public Char Field109;
		public Char Field110;
		public Char Field111;
		public Char Field112;
		public Char Field113;
		public Char Field114;
		public Char Field115;
		public Char Field116;
		public Char Field117;
		public Char Field118;
		public Char Field119;
		public Char Field120;
		public Char Field121;
		public Char Field122;
		public Char Field123;
		public Char Field124;
		public Char Field125;
		public Char Field126;
		public Char Field127;
		public Char Field128;
		public Char Field129;
		public Char Field130;
		public Char Field131;
		public Char Field132;
		public Char Field133;
		public Char Field134;
		public Char Field135;
		public Char Field136;
		public Char Field137;
		public Char Field138;
		public Char Field139;
		public Char Field140;
		public Char Field141;
		public Char Field142;
		public Char Field143;
		public Char Field144;
		public Char Field145;
		public Char Field146;
		public Char Field147;
		public Char Field148;
		public Char Field149;
		public Char Field150;
		public Char Field151;
		public Char Field152;
		public Char Field153;
		public Char Field154;
		public Char Field155;
		public Char Field156;
		public Char Field157;
		public Char Field158;
		public Char Field159;
		public Char Field160;
		public Char Field161;
		public Char Field162;
		public Char Field163;
		public Char Field164;
		public Char Field165;
		public Char Field166;
		public Char Field167;
		public Char Field168;
		public Char Field169;
		public Char Field170;
		public Char Field171;
		public Char Field172;
		public Char Field173;
		public Char Field174;
		public Char Field175;
		public Char Field176;
		public Char Field177;
		public Char Field178;
		public Char Field179;
		public Char Field180;
		public Char Field181;
		public Char Field182;
		public Char Field183;
		public Char Field184;
		public Char Field185;
		public Char Field186;
		public Char Field187;
		public Char Field188;
		public Char Field189;
		public Char Field190;
		public Char Field191;
		public Char Field192;
		public Char Field193;
		public Char Field194;
		public Char Field195;
		public Char Field196;
		public Char Field197;
		public Char Field198;
		public Char Field199;
		public Char Field200;
		public Char Field201;
		public Char Field202;
		public Char Field203;
		public Char Field204;
		public Char Field205;
		public Char Field206;
		public Char Field207;
		public Char Field208;
		public Char Field209;
		public Char Field210;
		public Char Field211;
		public Char Field212;
		public Char Field213;
		public Char Field214;
		public Char Field215;
		public Char Field216;
		public Char Field217;
		public Char Field218;
		public Char Field219;
		public Char Field220;
		public Char Field221;
		public Char Field222;
		public Char Field223;
		public Char Field224;
		public Char Field225;
		public Char Field226;
		public Char Field227;
		public Char Field228;
		public Char Field229;
		public Char Field230;
		public Char Field231;
		public Char Field232;
		public Char Field233;
		public Char Field234;
		public Char Field235;
		public Char Field236;
		public Char Field237;
		public Char Field238;
		public Char Field239;
		public Char Field240;
		public Char Field241;
		public Char Field242;
		public Char Field243;
		public Char Field244;
		public Char Field245;
		public Char Field246;
		public Char Field247;
		public Char Field248;
		public Char Field249;
		public Char Field250;
		public Char Field251;
		public Char Field252;
		public Char Field253;
		public Char Field254;
		public Char Field255;
		public Char Field256;
		public Char Field257;
		public Char Field258;
		public Char Field259;
#endif
        public Char this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                32 => Field32,
                33 => Field33,
                34 => Field34,
                35 => Field35,
                36 => Field36,
                37 => Field37,
                38 => Field38,
                39 => Field39,
                40 => Field40,
                41 => Field41,
                42 => Field42,
                43 => Field43,
                44 => Field44,
                45 => Field45,
                46 => Field46,
                47 => Field47,
                48 => Field48,
                49 => Field49,
                50 => Field50,
                51 => Field51,
                52 => Field52,
                53 => Field53,
                54 => Field54,
                55 => Field55,
                56 => Field56,
                57 => Field57,
                58 => Field58,
                59 => Field59,
                60 => Field60,
                61 => Field61,
                62 => Field62,
                63 => Field63,
                64 => Field64,
                65 => Field65,
                66 => Field66,
                67 => Field67,
                68 => Field68,
                69 => Field69,
                70 => Field70,
                71 => Field71,
                72 => Field72,
                73 => Field73,
                74 => Field74,
                75 => Field75,
                76 => Field76,
                77 => Field77,
                78 => Field78,
                79 => Field79,
                80 => Field80,
                81 => Field81,
                82 => Field82,
                83 => Field83,
                84 => Field84,
                85 => Field85,
                86 => Field86,
                87 => Field87,
                88 => Field88,
                89 => Field89,
                90 => Field90,
                91 => Field91,
                92 => Field92,
                93 => Field93,
                94 => Field94,
                95 => Field95,
                96 => Field96,
                97 => Field97,
                98 => Field98,
                99 => Field99,
                100 => Field100,
                101 => Field101,
                102 => Field102,
                103 => Field103,
                104 => Field104,
                105 => Field105,
                106 => Field106,
                107 => Field107,
                108 => Field108,
                109 => Field109,
                110 => Field110,
                111 => Field111,
                112 => Field112,
                113 => Field113,
                114 => Field114,
                115 => Field115,
                116 => Field116,
                117 => Field117,
                118 => Field118,
                119 => Field119,
                120 => Field120,
                121 => Field121,
                122 => Field122,
                123 => Field123,
                124 => Field124,
                125 => Field125,
                126 => Field126,
                127 => Field127,
                128 => Field128,
                129 => Field129,
                130 => Field130,
                131 => Field131,
                132 => Field132,
                133 => Field133,
                134 => Field134,
                135 => Field135,
                136 => Field136,
                137 => Field137,
                138 => Field138,
                139 => Field139,
                140 => Field140,
                141 => Field141,
                142 => Field142,
                143 => Field143,
                144 => Field144,
                145 => Field145,
                146 => Field146,
                147 => Field147,
                148 => Field148,
                149 => Field149,
                150 => Field150,
                151 => Field151,
                152 => Field152,
                153 => Field153,
                154 => Field154,
                155 => Field155,
                156 => Field156,
                157 => Field157,
                158 => Field158,
                159 => Field159,
                160 => Field160,
                161 => Field161,
                162 => Field162,
                163 => Field163,
                164 => Field164,
                165 => Field165,
                166 => Field166,
                167 => Field167,
                168 => Field168,
                169 => Field169,
                170 => Field170,
                171 => Field171,
                172 => Field172,
                173 => Field173,
                174 => Field174,
                175 => Field175,
                176 => Field176,
                177 => Field177,
                178 => Field178,
                179 => Field179,
                180 => Field180,
                181 => Field181,
                182 => Field182,
                183 => Field183,
                184 => Field184,
                185 => Field185,
                186 => Field186,
                187 => Field187,
                188 => Field188,
                189 => Field189,
                190 => Field190,
                191 => Field191,
                192 => Field192,
                193 => Field193,
                194 => Field194,
                195 => Field195,
                196 => Field196,
                197 => Field197,
                198 => Field198,
                199 => Field199,
                200 => Field200,
                201 => Field201,
                202 => Field202,
                203 => Field203,
                204 => Field204,
                205 => Field205,
                206 => Field206,
                207 => Field207,
                208 => Field208,
                209 => Field209,
                210 => Field210,
                211 => Field211,
                212 => Field212,
                213 => Field213,
                214 => Field214,
                215 => Field215,
                216 => Field216,
                217 => Field217,
                218 => Field218,
                219 => Field219,
                220 => Field220,
                221 => Field221,
                222 => Field222,
                223 => Field223,
                224 => Field224,
                225 => Field225,
                226 => Field226,
                227 => Field227,
                228 => Field228,
                229 => Field229,
                230 => Field230,
                231 => Field231,
                232 => Field232,
                233 => Field233,
                234 => Field234,
                235 => Field235,
                236 => Field236,
                237 => Field237,
                238 => Field238,
                239 => Field239,
                240 => Field240,
                241 => Field241,
                242 => Field242,
                243 => Field243,
                244 => Field244,
                245 => Field245,
                246 => Field246,
                247 => Field247,
                248 => Field248,
                249 => Field249,
                250 => Field250,
                251 => Field251,
                252 => Field252,
                253 => Field253,
                254 => Field254,
                255 => Field255,
                256 => Field256,
                257 => Field257,
                258 => Field258,
                259 => Field259,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
                    case 32: Field32 = value; break;
                    case 33: Field33 = value; break;
                    case 34: Field34 = value; break;
                    case 35: Field35 = value; break;
                    case 36: Field36 = value; break;
                    case 37: Field37 = value; break;
                    case 38: Field38 = value; break;
                    case 39: Field39 = value; break;
                    case 40: Field40 = value; break;
                    case 41: Field41 = value; break;
                    case 42: Field42 = value; break;
                    case 43: Field43 = value; break;
                    case 44: Field44 = value; break;
                    case 45: Field45 = value; break;
                    case 46: Field46 = value; break;
                    case 47: Field47 = value; break;
                    case 48: Field48 = value; break;
                    case 49: Field49 = value; break;
                    case 50: Field50 = value; break;
                    case 51: Field51 = value; break;
                    case 52: Field52 = value; break;
                    case 53: Field53 = value; break;
                    case 54: Field54 = value; break;
                    case 55: Field55 = value; break;
                    case 56: Field56 = value; break;
                    case 57: Field57 = value; break;
                    case 58: Field58 = value; break;
                    case 59: Field59 = value; break;
                    case 60: Field60 = value; break;
                    case 61: Field61 = value; break;
                    case 62: Field62 = value; break;
                    case 63: Field63 = value; break;
                    case 64: Field64 = value; break;
                    case 65: Field65 = value; break;
                    case 66: Field66 = value; break;
                    case 67: Field67 = value; break;
                    case 68: Field68 = value; break;
                    case 69: Field69 = value; break;
                    case 70: Field70 = value; break;
                    case 71: Field71 = value; break;
                    case 72: Field72 = value; break;
                    case 73: Field73 = value; break;
                    case 74: Field74 = value; break;
                    case 75: Field75 = value; break;
                    case 76: Field76 = value; break;
                    case 77: Field77 = value; break;
                    case 78: Field78 = value; break;
                    case 79: Field79 = value; break;
                    case 80: Field80 = value; break;
                    case 81: Field81 = value; break;
                    case 82: Field82 = value; break;
                    case 83: Field83 = value; break;
                    case 84: Field84 = value; break;
                    case 85: Field85 = value; break;
                    case 86: Field86 = value; break;
                    case 87: Field87 = value; break;
                    case 88: Field88 = value; break;
                    case 89: Field89 = value; break;
                    case 90: Field90 = value; break;
                    case 91: Field91 = value; break;
                    case 92: Field92 = value; break;
                    case 93: Field93 = value; break;
                    case 94: Field94 = value; break;
                    case 95: Field95 = value; break;
                    case 96: Field96 = value; break;
                    case 97: Field97 = value; break;
                    case 98: Field98 = value; break;
                    case 99: Field99 = value; break;
                    case 100: Field100 = value; break;
                    case 101: Field101 = value; break;
                    case 102: Field102 = value; break;
                    case 103: Field103 = value; break;
                    case 104: Field104 = value; break;
                    case 105: Field105 = value; break;
                    case 106: Field106 = value; break;
                    case 107: Field107 = value; break;
                    case 108: Field108 = value; break;
                    case 109: Field109 = value; break;
                    case 110: Field110 = value; break;
                    case 111: Field111 = value; break;
                    case 112: Field112 = value; break;
                    case 113: Field113 = value; break;
                    case 114: Field114 = value; break;
                    case 115: Field115 = value; break;
                    case 116: Field116 = value; break;
                    case 117: Field117 = value; break;
                    case 118: Field118 = value; break;
                    case 119: Field119 = value; break;
                    case 120: Field120 = value; break;
                    case 121: Field121 = value; break;
                    case 122: Field122 = value; break;
                    case 123: Field123 = value; break;
                    case 124: Field124 = value; break;
                    case 125: Field125 = value; break;
                    case 126: Field126 = value; break;
                    case 127: Field127 = value; break;
                    case 128: Field128 = value; break;
                    case 129: Field129 = value; break;
                    case 130: Field130 = value; break;
                    case 131: Field131 = value; break;
                    case 132: Field132 = value; break;
                    case 133: Field133 = value; break;
                    case 134: Field134 = value; break;
                    case 135: Field135 = value; break;
                    case 136: Field136 = value; break;
                    case 137: Field137 = value; break;
                    case 138: Field138 = value; break;
                    case 139: Field139 = value; break;
                    case 140: Field140 = value; break;
                    case 141: Field141 = value; break;
                    case 142: Field142 = value; break;
                    case 143: Field143 = value; break;
                    case 144: Field144 = value; break;
                    case 145: Field145 = value; break;
                    case 146: Field146 = value; break;
                    case 147: Field147 = value; break;
                    case 148: Field148 = value; break;
                    case 149: Field149 = value; break;
                    case 150: Field150 = value; break;
                    case 151: Field151 = value; break;
                    case 152: Field152 = value; break;
                    case 153: Field153 = value; break;
                    case 154: Field154 = value; break;
                    case 155: Field155 = value; break;
                    case 156: Field156 = value; break;
                    case 157: Field157 = value; break;
                    case 158: Field158 = value; break;
                    case 159: Field159 = value; break;
                    case 160: Field160 = value; break;
                    case 161: Field161 = value; break;
                    case 162: Field162 = value; break;
                    case 163: Field163 = value; break;
                    case 164: Field164 = value; break;
                    case 165: Field165 = value; break;
                    case 166: Field166 = value; break;
                    case 167: Field167 = value; break;
                    case 168: Field168 = value; break;
                    case 169: Field169 = value; break;
                    case 170: Field170 = value; break;
                    case 171: Field171 = value; break;
                    case 172: Field172 = value; break;
                    case 173: Field173 = value; break;
                    case 174: Field174 = value; break;
                    case 175: Field175 = value; break;
                    case 176: Field176 = value; break;
                    case 177: Field177 = value; break;
                    case 178: Field178 = value; break;
                    case 179: Field179 = value; break;
                    case 180: Field180 = value; break;
                    case 181: Field181 = value; break;
                    case 182: Field182 = value; break;
                    case 183: Field183 = value; break;
                    case 184: Field184 = value; break;
                    case 185: Field185 = value; break;
                    case 186: Field186 = value; break;
                    case 187: Field187 = value; break;
                    case 188: Field188 = value; break;
                    case 189: Field189 = value; break;
                    case 190: Field190 = value; break;
                    case 191: Field191 = value; break;
                    case 192: Field192 = value; break;
                    case 193: Field193 = value; break;
                    case 194: Field194 = value; break;
                    case 195: Field195 = value; break;
                    case 196: Field196 = value; break;
                    case 197: Field197 = value; break;
                    case 198: Field198 = value; break;
                    case 199: Field199 = value; break;
                    case 200: Field200 = value; break;
                    case 201: Field201 = value; break;
                    case 202: Field202 = value; break;
                    case 203: Field203 = value; break;
                    case 204: Field204 = value; break;
                    case 205: Field205 = value; break;
                    case 206: Field206 = value; break;
                    case 207: Field207 = value; break;
                    case 208: Field208 = value; break;
                    case 209: Field209 = value; break;
                    case 210: Field210 = value; break;
                    case 211: Field211 = value; break;
                    case 212: Field212 = value; break;
                    case 213: Field213 = value; break;
                    case 214: Field214 = value; break;
                    case 215: Field215 = value; break;
                    case 216: Field216 = value; break;
                    case 217: Field217 = value; break;
                    case 218: Field218 = value; break;
                    case 219: Field219 = value; break;
                    case 220: Field220 = value; break;
                    case 221: Field221 = value; break;
                    case 222: Field222 = value; break;
                    case 223: Field223 = value; break;
                    case 224: Field224 = value; break;
                    case 225: Field225 = value; break;
                    case 226: Field226 = value; break;
                    case 227: Field227 = value; break;
                    case 228: Field228 = value; break;
                    case 229: Field229 = value; break;
                    case 230: Field230 = value; break;
                    case 231: Field231 = value; break;
                    case 232: Field232 = value; break;
                    case 233: Field233 = value; break;
                    case 234: Field234 = value; break;
                    case 235: Field235 = value; break;
                    case 236: Field236 = value; break;
                    case 237: Field237 = value; break;
                    case 238: Field238 = value; break;
                    case 239: Field239 = value; break;
                    case 240: Field240 = value; break;
                    case 241: Field241 = value; break;
                    case 242: Field242 = value; break;
                    case 243: Field243 = value; break;
                    case 244: Field244 = value; break;
                    case 245: Field245 = value; break;
                    case 246: Field246 = value; break;
                    case 247: Field247 = value; break;
                    case 248: Field248 = value; break;
                    case 249: Field249 = value; break;
                    case 250: Field250 = value; break;
                    case 251: Field251 = value; break;
                    case 252: Field252 = value; break;
                    case 253: Field253 = value; break;
                    case 254: Field254 = value; break;
                    case 255: Field255 = value; break;
                    case 256: Field256 = value; break;
                    case 257: Field257 = value; break;
                    case 258: Field258 = value; break;
                    case 259: Field259 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthCharArray260) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthCharArray260)other);

        public readonly bool Equals(in FixedLengthCharArray260 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthCharArray260 left, in FixedLengthCharArray260 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthCharArray260 left, in FixedLengthCharArray260 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<Char> IEnumerable<Char>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
              yield return Field32;
              yield return Field33;
              yield return Field34;
              yield return Field35;
              yield return Field36;
              yield return Field37;
              yield return Field38;
              yield return Field39;
              yield return Field40;
              yield return Field41;
              yield return Field42;
              yield return Field43;
              yield return Field44;
              yield return Field45;
              yield return Field46;
              yield return Field47;
              yield return Field48;
              yield return Field49;
              yield return Field50;
              yield return Field51;
              yield return Field52;
              yield return Field53;
              yield return Field54;
              yield return Field55;
              yield return Field56;
              yield return Field57;
              yield return Field58;
              yield return Field59;
              yield return Field60;
              yield return Field61;
              yield return Field62;
              yield return Field63;
              yield return Field64;
              yield return Field65;
              yield return Field66;
              yield return Field67;
              yield return Field68;
              yield return Field69;
              yield return Field70;
              yield return Field71;
              yield return Field72;
              yield return Field73;
              yield return Field74;
              yield return Field75;
              yield return Field76;
              yield return Field77;
              yield return Field78;
              yield return Field79;
              yield return Field80;
              yield return Field81;
              yield return Field82;
              yield return Field83;
              yield return Field84;
              yield return Field85;
              yield return Field86;
              yield return Field87;
              yield return Field88;
              yield return Field89;
              yield return Field90;
              yield return Field91;
              yield return Field92;
              yield return Field93;
              yield return Field94;
              yield return Field95;
              yield return Field96;
              yield return Field97;
              yield return Field98;
              yield return Field99;
              yield return Field100;
              yield return Field101;
              yield return Field102;
              yield return Field103;
              yield return Field104;
              yield return Field105;
              yield return Field106;
              yield return Field107;
              yield return Field108;
              yield return Field109;
              yield return Field110;
              yield return Field111;
              yield return Field112;
              yield return Field113;
              yield return Field114;
              yield return Field115;
              yield return Field116;
              yield return Field117;
              yield return Field118;
              yield return Field119;
              yield return Field120;
              yield return Field121;
              yield return Field122;
              yield return Field123;
              yield return Field124;
              yield return Field125;
              yield return Field126;
              yield return Field127;
              yield return Field128;
              yield return Field129;
              yield return Field130;
              yield return Field131;
              yield return Field132;
              yield return Field133;
              yield return Field134;
              yield return Field135;
              yield return Field136;
              yield return Field137;
              yield return Field138;
              yield return Field139;
              yield return Field140;
              yield return Field141;
              yield return Field142;
              yield return Field143;
              yield return Field144;
              yield return Field145;
              yield return Field146;
              yield return Field147;
              yield return Field148;
              yield return Field149;
              yield return Field150;
              yield return Field151;
              yield return Field152;
              yield return Field153;
              yield return Field154;
              yield return Field155;
              yield return Field156;
              yield return Field157;
              yield return Field158;
              yield return Field159;
              yield return Field160;
              yield return Field161;
              yield return Field162;
              yield return Field163;
              yield return Field164;
              yield return Field165;
              yield return Field166;
              yield return Field167;
              yield return Field168;
              yield return Field169;
              yield return Field170;
              yield return Field171;
              yield return Field172;
              yield return Field173;
              yield return Field174;
              yield return Field175;
              yield return Field176;
              yield return Field177;
              yield return Field178;
              yield return Field179;
              yield return Field180;
              yield return Field181;
              yield return Field182;
              yield return Field183;
              yield return Field184;
              yield return Field185;
              yield return Field186;
              yield return Field187;
              yield return Field188;
              yield return Field189;
              yield return Field190;
              yield return Field191;
              yield return Field192;
              yield return Field193;
              yield return Field194;
              yield return Field195;
              yield return Field196;
              yield return Field197;
              yield return Field198;
              yield return Field199;
              yield return Field200;
              yield return Field201;
              yield return Field202;
              yield return Field203;
              yield return Field204;
              yield return Field205;
              yield return Field206;
              yield return Field207;
              yield return Field208;
              yield return Field209;
              yield return Field210;
              yield return Field211;
              yield return Field212;
              yield return Field213;
              yield return Field214;
              yield return Field215;
              yield return Field216;
              yield return Field217;
              yield return Field218;
              yield return Field219;
              yield return Field220;
              yield return Field221;
              yield return Field222;
              yield return Field223;
              yield return Field224;
              yield return Field225;
              yield return Field226;
              yield return Field227;
              yield return Field228;
              yield return Field229;
              yield return Field230;
              yield return Field231;
              yield return Field232;
              yield return Field233;
              yield return Field234;
              yield return Field235;
              yield return Field236;
              yield return Field237;
              yield return Field238;
              yield return Field239;
              yield return Field240;
              yield return Field241;
              yield return Field242;
              yield return Field243;
              yield return Field244;
              yield return Field245;
              yield return Field246;
              yield return Field247;
              yield return Field248;
              yield return Field249;
              yield return Field250;
              yield return Field251;
              yield return Field252;
              yield return Field253;
              yield return Field254;
              yield return Field255;
              yield return Field256;
              yield return Field257;
              yield return Field258;
              yield return Field259;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<Char>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<Char>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<Char>(in FixedLengthCharArray260 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<Char> AsSpan(this ref FixedLengthCharArray260 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<Char> AsReadOnlySpan(this in FixedLengthCharArray260 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref Char At(this ref FixedLengthCharArray260 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
                case 32: return ref array.Field32;
                case 33: return ref array.Field33;
                case 34: return ref array.Field34;
                case 35: return ref array.Field35;
                case 36: return ref array.Field36;
                case 37: return ref array.Field37;
                case 38: return ref array.Field38;
                case 39: return ref array.Field39;
                case 40: return ref array.Field40;
                case 41: return ref array.Field41;
                case 42: return ref array.Field42;
                case 43: return ref array.Field43;
                case 44: return ref array.Field44;
                case 45: return ref array.Field45;
                case 46: return ref array.Field46;
                case 47: return ref array.Field47;
                case 48: return ref array.Field48;
                case 49: return ref array.Field49;
                case 50: return ref array.Field50;
                case 51: return ref array.Field51;
                case 52: return ref array.Field52;
                case 53: return ref array.Field53;
                case 54: return ref array.Field54;
                case 55: return ref array.Field55;
                case 56: return ref array.Field56;
                case 57: return ref array.Field57;
                case 58: return ref array.Field58;
                case 59: return ref array.Field59;
                case 60: return ref array.Field60;
                case 61: return ref array.Field61;
                case 62: return ref array.Field62;
                case 63: return ref array.Field63;
                case 64: return ref array.Field64;
                case 65: return ref array.Field65;
                case 66: return ref array.Field66;
                case 67: return ref array.Field67;
                case 68: return ref array.Field68;
                case 69: return ref array.Field69;
                case 70: return ref array.Field70;
                case 71: return ref array.Field71;
                case 72: return ref array.Field72;
                case 73: return ref array.Field73;
                case 74: return ref array.Field74;
                case 75: return ref array.Field75;
                case 76: return ref array.Field76;
                case 77: return ref array.Field77;
                case 78: return ref array.Field78;
                case 79: return ref array.Field79;
                case 80: return ref array.Field80;
                case 81: return ref array.Field81;
                case 82: return ref array.Field82;
                case 83: return ref array.Field83;
                case 84: return ref array.Field84;
                case 85: return ref array.Field85;
                case 86: return ref array.Field86;
                case 87: return ref array.Field87;
                case 88: return ref array.Field88;
                case 89: return ref array.Field89;
                case 90: return ref array.Field90;
                case 91: return ref array.Field91;
                case 92: return ref array.Field92;
                case 93: return ref array.Field93;
                case 94: return ref array.Field94;
                case 95: return ref array.Field95;
                case 96: return ref array.Field96;
                case 97: return ref array.Field97;
                case 98: return ref array.Field98;
                case 99: return ref array.Field99;
                case 100: return ref array.Field100;
                case 101: return ref array.Field101;
                case 102: return ref array.Field102;
                case 103: return ref array.Field103;
                case 104: return ref array.Field104;
                case 105: return ref array.Field105;
                case 106: return ref array.Field106;
                case 107: return ref array.Field107;
                case 108: return ref array.Field108;
                case 109: return ref array.Field109;
                case 110: return ref array.Field110;
                case 111: return ref array.Field111;
                case 112: return ref array.Field112;
                case 113: return ref array.Field113;
                case 114: return ref array.Field114;
                case 115: return ref array.Field115;
                case 116: return ref array.Field116;
                case 117: return ref array.Field117;
                case 118: return ref array.Field118;
                case 119: return ref array.Field119;
                case 120: return ref array.Field120;
                case 121: return ref array.Field121;
                case 122: return ref array.Field122;
                case 123: return ref array.Field123;
                case 124: return ref array.Field124;
                case 125: return ref array.Field125;
                case 126: return ref array.Field126;
                case 127: return ref array.Field127;
                case 128: return ref array.Field128;
                case 129: return ref array.Field129;
                case 130: return ref array.Field130;
                case 131: return ref array.Field131;
                case 132: return ref array.Field132;
                case 133: return ref array.Field133;
                case 134: return ref array.Field134;
                case 135: return ref array.Field135;
                case 136: return ref array.Field136;
                case 137: return ref array.Field137;
                case 138: return ref array.Field138;
                case 139: return ref array.Field139;
                case 140: return ref array.Field140;
                case 141: return ref array.Field141;
                case 142: return ref array.Field142;
                case 143: return ref array.Field143;
                case 144: return ref array.Field144;
                case 145: return ref array.Field145;
                case 146: return ref array.Field146;
                case 147: return ref array.Field147;
                case 148: return ref array.Field148;
                case 149: return ref array.Field149;
                case 150: return ref array.Field150;
                case 151: return ref array.Field151;
                case 152: return ref array.Field152;
                case 153: return ref array.Field153;
                case 154: return ref array.Field154;
                case 155: return ref array.Field155;
                case 156: return ref array.Field156;
                case 157: return ref array.Field157;
                case 158: return ref array.Field158;
                case 159: return ref array.Field159;
                case 160: return ref array.Field160;
                case 161: return ref array.Field161;
                case 162: return ref array.Field162;
                case 163: return ref array.Field163;
                case 164: return ref array.Field164;
                case 165: return ref array.Field165;
                case 166: return ref array.Field166;
                case 167: return ref array.Field167;
                case 168: return ref array.Field168;
                case 169: return ref array.Field169;
                case 170: return ref array.Field170;
                case 171: return ref array.Field171;
                case 172: return ref array.Field172;
                case 173: return ref array.Field173;
                case 174: return ref array.Field174;
                case 175: return ref array.Field175;
                case 176: return ref array.Field176;
                case 177: return ref array.Field177;
                case 178: return ref array.Field178;
                case 179: return ref array.Field179;
                case 180: return ref array.Field180;
                case 181: return ref array.Field181;
                case 182: return ref array.Field182;
                case 183: return ref array.Field183;
                case 184: return ref array.Field184;
                case 185: return ref array.Field185;
                case 186: return ref array.Field186;
                case 187: return ref array.Field187;
                case 188: return ref array.Field188;
                case 189: return ref array.Field189;
                case 190: return ref array.Field190;
                case 191: return ref array.Field191;
                case 192: return ref array.Field192;
                case 193: return ref array.Field193;
                case 194: return ref array.Field194;
                case 195: return ref array.Field195;
                case 196: return ref array.Field196;
                case 197: return ref array.Field197;
                case 198: return ref array.Field198;
                case 199: return ref array.Field199;
                case 200: return ref array.Field200;
                case 201: return ref array.Field201;
                case 202: return ref array.Field202;
                case 203: return ref array.Field203;
                case 204: return ref array.Field204;
                case 205: return ref array.Field205;
                case 206: return ref array.Field206;
                case 207: return ref array.Field207;
                case 208: return ref array.Field208;
                case 209: return ref array.Field209;
                case 210: return ref array.Field210;
                case 211: return ref array.Field211;
                case 212: return ref array.Field212;
                case 213: return ref array.Field213;
                case 214: return ref array.Field214;
                case 215: return ref array.Field215;
                case 216: return ref array.Field216;
                case 217: return ref array.Field217;
                case 218: return ref array.Field218;
                case 219: return ref array.Field219;
                case 220: return ref array.Field220;
                case 221: return ref array.Field221;
                case 222: return ref array.Field222;
                case 223: return ref array.Field223;
                case 224: return ref array.Field224;
                case 225: return ref array.Field225;
                case 226: return ref array.Field226;
                case 227: return ref array.Field227;
                case 228: return ref array.Field228;
                case 229: return ref array.Field229;
                case 230: return ref array.Field230;
                case 231: return ref array.Field231;
                case 232: return ref array.Field232;
                case 233: return ref array.Field233;
                case 234: return ref array.Field234;
                case 235: return ref array.Field235;
                case 236: return ref array.Field236;
                case 237: return ref array.Field237;
                case 238: return ref array.Field238;
                case 239: return ref array.Field239;
                case 240: return ref array.Field240;
                case 241: return ref array.Field241;
                case 242: return ref array.Field242;
                case 243: return ref array.Field243;
                case 244: return ref array.Field244;
                case 245: return ref array.Field245;
                case 246: return ref array.Field246;
                case 247: return ref array.Field247;
                case 248: return ref array.Field248;
                case 249: return ref array.Field249;
                case 250: return ref array.Field250;
                case 251: return ref array.Field251;
                case 252: return ref array.Field252;
                case 253: return ref array.Field253;
                case 254: return ref array.Field254;
                case 255: return ref array.Field255;
                case 256: return ref array.Field256;
                case 257: return ref array.Field257;
                case 258: return ref array.Field258;
                case 259: return ref array.Field259;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthCharArray260 array1, in FixedLengthCharArray260 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthCharArray260 array, Char[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthCharArray260 array1, in FixedLengthCharArray260 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthCharArray260 array, Char value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref Char At(this ref FixedLengthCharArray260 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthCharArray260 array1, in FixedLengthCharArray260 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthCharArray260 array, Span<Char> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthCharArray260 array1, in FixedLengthCharArray260 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthCharArray260 array, Char value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 2 * sizeof(UInt32), CharSet = CharSet.Unicode)]
	public struct FixedLengthUInt32Array2
#if GENERATE_ENUMERABLE
		: IEnumerable<UInt32>
#endif
	{
		private static readonly FixedLengthUInt32Array2 _Zero = default;
		public static ref readonly FixedLengthUInt32Array2 Zero => ref _Zero;

		public const int ConstLength = 2;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthUInt32Array2(
			UInt32 field0
			, UInt32 field1
		)
		{
			Field0 = field0;
			Field1 = field1;
		}
#endif
		public UInt32 Field0;
#if GENERATE_ALL_FIELDS
		public UInt32 Field1;
#endif
        public UInt32 this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthUInt32Array2) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthUInt32Array2)other);

        public readonly bool Equals(in FixedLengthUInt32Array2 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthUInt32Array2 left, in FixedLengthUInt32Array2 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthUInt32Array2 left, in FixedLengthUInt32Array2 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<UInt32> IEnumerable<UInt32>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<UInt32>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<UInt32>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<UInt32>(in FixedLengthUInt32Array2 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<UInt32> AsSpan(this ref FixedLengthUInt32Array2 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<UInt32> AsReadOnlySpan(this in FixedLengthUInt32Array2 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref UInt32 At(this ref FixedLengthUInt32Array2 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthUInt32Array2 array1, in FixedLengthUInt32Array2 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthUInt32Array2 array, UInt32[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthUInt32Array2 array1, in FixedLengthUInt32Array2 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthUInt32Array2 array, UInt32 value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref UInt32 At(this ref FixedLengthUInt32Array2 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthUInt32Array2 array1, in FixedLengthUInt32Array2 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthUInt32Array2 array, Span<UInt32> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthUInt32Array2 array1, in FixedLengthUInt32Array2 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthUInt32Array2 array, UInt32 value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 4 * sizeof(UInt32), CharSet = CharSet.Unicode)]
	public struct FixedLengthUInt32Array4
#if GENERATE_ENUMERABLE
		: IEnumerable<UInt32>
#endif
	{
		private static readonly FixedLengthUInt32Array4 _Zero = default;
		public static ref readonly FixedLengthUInt32Array4 Zero => ref _Zero;

		public const int ConstLength = 4;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthUInt32Array4(
			UInt32 field0
			, UInt32 field1
			, UInt32 field2
			, UInt32 field3
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
		}
#endif
		public UInt32 Field0;
#if GENERATE_ALL_FIELDS
		public UInt32 Field1;
		public UInt32 Field2;
		public UInt32 Field3;
#endif
        public UInt32 this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthUInt32Array4) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthUInt32Array4)other);

        public readonly bool Equals(in FixedLengthUInt32Array4 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthUInt32Array4 left, in FixedLengthUInt32Array4 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthUInt32Array4 left, in FixedLengthUInt32Array4 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<UInt32> IEnumerable<UInt32>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<UInt32>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<UInt32>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<UInt32>(in FixedLengthUInt32Array4 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<UInt32> AsSpan(this ref FixedLengthUInt32Array4 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<UInt32> AsReadOnlySpan(this in FixedLengthUInt32Array4 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref UInt32 At(this ref FixedLengthUInt32Array4 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthUInt32Array4 array1, in FixedLengthUInt32Array4 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthUInt32Array4 array, UInt32[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthUInt32Array4 array1, in FixedLengthUInt32Array4 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthUInt32Array4 array, UInt32 value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref UInt32 At(this ref FixedLengthUInt32Array4 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthUInt32Array4 array1, in FixedLengthUInt32Array4 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthUInt32Array4 array, Span<UInt32> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthUInt32Array4 array1, in FixedLengthUInt32Array4 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthUInt32Array4 array, UInt32 value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 8 * sizeof(UInt32), CharSet = CharSet.Unicode)]
	public struct FixedLengthUInt32Array8
#if GENERATE_ENUMERABLE
		: IEnumerable<UInt32>
#endif
	{
		private static readonly FixedLengthUInt32Array8 _Zero = default;
		public static ref readonly FixedLengthUInt32Array8 Zero => ref _Zero;

		public const int ConstLength = 8;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthUInt32Array8(
			UInt32 field0
			, UInt32 field1
			, UInt32 field2
			, UInt32 field3
			, UInt32 field4
			, UInt32 field5
			, UInt32 field6
			, UInt32 field7
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
		}
#endif
		public UInt32 Field0;
#if GENERATE_ALL_FIELDS
		public UInt32 Field1;
		public UInt32 Field2;
		public UInt32 Field3;
		public UInt32 Field4;
		public UInt32 Field5;
		public UInt32 Field6;
		public UInt32 Field7;
#endif
        public UInt32 this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthUInt32Array8) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthUInt32Array8)other);

        public readonly bool Equals(in FixedLengthUInt32Array8 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthUInt32Array8 left, in FixedLengthUInt32Array8 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthUInt32Array8 left, in FixedLengthUInt32Array8 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<UInt32> IEnumerable<UInt32>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<UInt32>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<UInt32>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<UInt32>(in FixedLengthUInt32Array8 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<UInt32> AsSpan(this ref FixedLengthUInt32Array8 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<UInt32> AsReadOnlySpan(this in FixedLengthUInt32Array8 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref UInt32 At(this ref FixedLengthUInt32Array8 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthUInt32Array8 array1, in FixedLengthUInt32Array8 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthUInt32Array8 array, UInt32[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthUInt32Array8 array1, in FixedLengthUInt32Array8 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthUInt32Array8 array, UInt32 value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref UInt32 At(this ref FixedLengthUInt32Array8 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthUInt32Array8 array1, in FixedLengthUInt32Array8 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthUInt32Array8 array, Span<UInt32> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthUInt32Array8 array1, in FixedLengthUInt32Array8 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthUInt32Array8 array, UInt32 value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 16 * sizeof(UInt32), CharSet = CharSet.Unicode)]
	public struct FixedLengthUInt32Array16
#if GENERATE_ENUMERABLE
		: IEnumerable<UInt32>
#endif
	{
		private static readonly FixedLengthUInt32Array16 _Zero = default;
		public static ref readonly FixedLengthUInt32Array16 Zero => ref _Zero;

		public const int ConstLength = 16;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthUInt32Array16(
			UInt32 field0
			, UInt32 field1
			, UInt32 field2
			, UInt32 field3
			, UInt32 field4
			, UInt32 field5
			, UInt32 field6
			, UInt32 field7
			, UInt32 field8
			, UInt32 field9
			, UInt32 field10
			, UInt32 field11
			, UInt32 field12
			, UInt32 field13
			, UInt32 field14
			, UInt32 field15
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
		}
#endif
		public UInt32 Field0;
#if GENERATE_ALL_FIELDS
		public UInt32 Field1;
		public UInt32 Field2;
		public UInt32 Field3;
		public UInt32 Field4;
		public UInt32 Field5;
		public UInt32 Field6;
		public UInt32 Field7;
		public UInt32 Field8;
		public UInt32 Field9;
		public UInt32 Field10;
		public UInt32 Field11;
		public UInt32 Field12;
		public UInt32 Field13;
		public UInt32 Field14;
		public UInt32 Field15;
#endif
        public UInt32 this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthUInt32Array16) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthUInt32Array16)other);

        public readonly bool Equals(in FixedLengthUInt32Array16 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthUInt32Array16 left, in FixedLengthUInt32Array16 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthUInt32Array16 left, in FixedLengthUInt32Array16 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<UInt32> IEnumerable<UInt32>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<UInt32>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<UInt32>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<UInt32>(in FixedLengthUInt32Array16 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<UInt32> AsSpan(this ref FixedLengthUInt32Array16 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<UInt32> AsReadOnlySpan(this in FixedLengthUInt32Array16 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref UInt32 At(this ref FixedLengthUInt32Array16 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthUInt32Array16 array1, in FixedLengthUInt32Array16 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthUInt32Array16 array, UInt32[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthUInt32Array16 array1, in FixedLengthUInt32Array16 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthUInt32Array16 array, UInt32 value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref UInt32 At(this ref FixedLengthUInt32Array16 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthUInt32Array16 array1, in FixedLengthUInt32Array16 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthUInt32Array16 array, Span<UInt32> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthUInt32Array16 array1, in FixedLengthUInt32Array16 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthUInt32Array16 array, UInt32 value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
    [StructLayout(LayoutKind.Sequential, Pack = 1, Size = 32 * sizeof(UInt32), CharSet = CharSet.Unicode)]
	public struct FixedLengthUInt32Array32
#if GENERATE_ENUMERABLE
		: IEnumerable<UInt32>
#endif
	{
		private static readonly FixedLengthUInt32Array32 _Zero = default;
		public static ref readonly FixedLengthUInt32Array32 Zero => ref _Zero;

		public const int ConstLength = 32;
		public readonly int Length => ConstLength;
#if GENERATE_CTOR
		public FixedLengthUInt32Array32(
			UInt32 field0
			, UInt32 field1
			, UInt32 field2
			, UInt32 field3
			, UInt32 field4
			, UInt32 field5
			, UInt32 field6
			, UInt32 field7
			, UInt32 field8
			, UInt32 field9
			, UInt32 field10
			, UInt32 field11
			, UInt32 field12
			, UInt32 field13
			, UInt32 field14
			, UInt32 field15
			, UInt32 field16
			, UInt32 field17
			, UInt32 field18
			, UInt32 field19
			, UInt32 field20
			, UInt32 field21
			, UInt32 field22
			, UInt32 field23
			, UInt32 field24
			, UInt32 field25
			, UInt32 field26
			, UInt32 field27
			, UInt32 field28
			, UInt32 field29
			, UInt32 field30
			, UInt32 field31
		)
		{
			Field0 = field0;
			Field1 = field1;
			Field2 = field2;
			Field3 = field3;
			Field4 = field4;
			Field5 = field5;
			Field6 = field6;
			Field7 = field7;
			Field8 = field8;
			Field9 = field9;
			Field10 = field10;
			Field11 = field11;
			Field12 = field12;
			Field13 = field13;
			Field14 = field14;
			Field15 = field15;
			Field16 = field16;
			Field17 = field17;
			Field18 = field18;
			Field19 = field19;
			Field20 = field20;
			Field21 = field21;
			Field22 = field22;
			Field23 = field23;
			Field24 = field24;
			Field25 = field25;
			Field26 = field26;
			Field27 = field27;
			Field28 = field28;
			Field29 = field29;
			Field30 = field30;
			Field31 = field31;
		}
#endif
		public UInt32 Field0;
#if GENERATE_ALL_FIELDS
		public UInt32 Field1;
		public UInt32 Field2;
		public UInt32 Field3;
		public UInt32 Field4;
		public UInt32 Field5;
		public UInt32 Field6;
		public UInt32 Field7;
		public UInt32 Field8;
		public UInt32 Field9;
		public UInt32 Field10;
		public UInt32 Field11;
		public UInt32 Field12;
		public UInt32 Field13;
		public UInt32 Field14;
		public UInt32 Field15;
		public UInt32 Field16;
		public UInt32 Field17;
		public UInt32 Field18;
		public UInt32 Field19;
		public UInt32 Field20;
		public UInt32 Field21;
		public UInt32 Field22;
		public UInt32 Field23;
		public UInt32 Field24;
		public UInt32 Field25;
		public UInt32 Field26;
		public UInt32 Field27;
		public UInt32 Field28;
		public UInt32 Field29;
		public UInt32 Field30;
		public UInt32 Field31;
#endif
        public UInt32 this[int index]
        {
#if GENERATE_ALL_FIELDS
            readonly get => index switch
            {
                0 => Field0,
                1 => Field1,
                2 => Field2,
                3 => Field3,
                4 => Field4,
                5 => Field5,
                6 => Field6,
                7 => Field7,
                8 => Field8,
                9 => Field9,
                10 => Field10,
                11 => Field11,
                12 => Field12,
                13 => Field13,
                14 => Field14,
                15 => Field15,
                16 => Field16,
                17 => Field17,
                18 => Field18,
                19 => Field19,
                20 => Field20,
                21 => Field21,
                22 => Field22,
                23 => Field23,
                24 => Field24,
                25 => Field25,
                26 => Field26,
                27 => Field27,
                28 => Field28,
                29 => Field29,
                30 => Field30,
                31 => Field31,
                _ => throw new ArgumentOutOfRangeException(nameof(index)),
            };
            set
            {
                switch (index)
                {
                    case 0: Field0 = value; break;
                    case 1: Field1 = value; break;
                    case 2: Field2 = value; break;
                    case 3: Field3 = value; break;
                    case 4: Field4 = value; break;
                    case 5: Field5 = value; break;
                    case 6: Field6 = value; break;
                    case 7: Field7 = value; break;
                    case 8: Field8 = value; break;
                    case 9: Field9 = value; break;
                    case 10: Field10 = value; break;
                    case 11: Field11 = value; break;
                    case 12: Field12 = value; break;
                    case 13: Field13 = value; break;
                    case 14: Field14 = value; break;
                    case 15: Field15 = value; break;
                    case 16: Field16 = value; break;
                    case 17: Field17 = value; break;
                    case 18: Field18 = value; break;
                    case 19: Field19 = value; break;
                    case 20: Field20 = value; break;
                    case 21: Field21 = value; break;
                    case 22: Field22 = value; break;
                    case 23: Field23 = value; break;
                    case 24: Field24 = value; break;
                    case 25: Field25 = value; break;
                    case 26: Field26 = value; break;
                    case 27: Field27 = value; break;
                    case 28: Field28 = value; break;
                    case 29: Field29 = value; break;
                    case 30: Field30 = value; break;
                    case 31: Field31 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
#elif GENERATE_ASSPAN
			readonly get => FixedLengthArrayExtension.AsReadOnlySpan(in this)[index];
			set => FixedLengthArrayExtension.AsSpan(ref this)[index] = value;
#else
            readonly get => (index < Length) ? Unsafe.Add(ref Unsafe.AsRef(in Field0), index) :
                    throw new ArgumentOutOfRangeException(nameof(index));
            set => Unsafe.Add(ref Field0, index) = (index < Length) ? value :
                    throw new ArgumentOutOfRangeException(nameof(index));
#endif
        }
#if GENERATE_ASSPAN || GENERATE_ALL_FIELDS
        public readonly override bool Equals(object other)
            => other is null || !(other is FixedLengthUInt32Array32) ? false :
			   FixedLengthArrayExtension.Equals(in this, (FixedLengthUInt32Array32)other);

        public readonly bool Equals(in FixedLengthUInt32Array32 other)
			=> FixedLengthArrayExtension.Equals(in this, in other);
		
        public static bool operator ==(in FixedLengthUInt32Array32 left, in FixedLengthUInt32Array32 right)
            => left.Equals(right);

        public static bool operator !=(in FixedLengthUInt32Array32 left, in FixedLengthUInt32Array32 right)
            => !(left == right);
#endif

#if GENERATE_ASSPAN
        public override readonly int GetHashCode()
        {
			var span = FixedLengthArrayExtension.AsReadOnlySpan(this);
			int hash = 0;
            for(int i = 0; i < span.Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)span[i].GetHashCode(), i));
			}
			return hash;
        }
#else
        public override readonly int GetHashCode()
        {
			int hash = 0;
            for(int i = 0; i < Length;i++ )
			{
				hash = FixedLengthArray.Combine(hash, (int)FixedLengthArray.RotateToLeft((uint)this[i].GetHashCode(), i));
			}
			return hash;
        }
#endif

#if GENERATE_ENUMERABLE
		readonly IEnumerator<UInt32> IEnumerable<UInt32>.GetEnumerator()
		{
              yield return Field0;
              yield return Field1;
              yield return Field2;
              yield return Field3;
              yield return Field4;
              yield return Field5;
              yield return Field6;
              yield return Field7;
              yield return Field8;
              yield return Field9;
              yield return Field10;
              yield return Field11;
              yield return Field12;
              yield return Field13;
              yield return Field14;
              yield return Field15;
              yield return Field16;
              yield return Field17;
              yield return Field18;
              yield return Field19;
              yield return Field20;
              yield return Field21;
              yield return Field22;
              yield return Field23;
              yield return Field24;
              yield return Field25;
              yield return Field26;
              yield return Field27;
              yield return Field28;
              yield return Field29;
              yield return Field30;
              yield return Field31;
		}

		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			=> ((IEnumerable<UInt32>)this).GetEnumerator();
#endif

#if GENERATE_ASSPAN
		public readonly ReadOnlySpan<UInt32>.Enumerator GetEnumerator()
			=> FixedLengthArrayExtension.AsReadOnlySpan(this).GetEnumerator();

        public static implicit operator ReadOnlySpan<UInt32>(in FixedLengthUInt32Array32 self)
            => self.AsReadOnlySpan();
#endif
	}

    public static partial class FixedLengthArrayExtension
    {
#if GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static Span<UInt32> AsSpan(this ref FixedLengthUInt32Array32 array)
            => FixedLengthArray.CreateSpan(ref array.Field0, array.Length);

		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<UInt32> AsReadOnlySpan(this in FixedLengthUInt32Array32 array)
            => FixedLengthArray.CreateReadOnlySpan(array.Field0, array.Length);
#endif

#if GENERATE_ALL_FIELDS 
        public static ref UInt32 At(this ref FixedLengthUInt32Array32 array, int index)
        {
            switch (index)
            {
                case 0: return ref array.Field0;
                case 1: return ref array.Field1;
                case 2: return ref array.Field2;
                case 3: return ref array.Field3;
                case 4: return ref array.Field4;
                case 5: return ref array.Field5;
                case 6: return ref array.Field6;
                case 7: return ref array.Field7;
                case 8: return ref array.Field8;
                case 9: return ref array.Field9;
                case 10: return ref array.Field10;
                case 11: return ref array.Field11;
                case 12: return ref array.Field12;
                case 13: return ref array.Field13;
                case 14: return ref array.Field14;
                case 15: return ref array.Field15;
                case 16: return ref array.Field16;
                case 17: return ref array.Field17;
                case 18: return ref array.Field18;
                case 19: return ref array.Field19;
                case 20: return ref array.Field20;
                case 21: return ref array.Field21;
                case 22: return ref array.Field22;
                case 23: return ref array.Field23;
                case 24: return ref array.Field24;
                case 25: return ref array.Field25;
                case 26: return ref array.Field26;
                case 27: return ref array.Field27;
                case 28: return ref array.Field28;
                case 29: return ref array.Field29;
                case 30: return ref array.Field30;
                case 31: return ref array.Field31;
				default: throw new ArgumentOutOfRangeException(nameof(index));
            }
        }
        public static int CompareTo(this in FixedLengthUInt32Array32 array1, in FixedLengthUInt32Array32 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				int result = array1[i].CompareTo(array2[i]);
				if(result != 0)
					return result;
			}
			return 0;
		}
        public static void CopyTo(this in FixedLengthUInt32Array32 array, UInt32[] dest, int offset = 0)
        {
            for(int i = 0; i < array.Length;i++ )
			{
				dest[offset + i] = array[i];
			}
        }
        public static bool Equals(in FixedLengthUInt32Array32 array1, in FixedLengthUInt32Array32 array2)
		{
			for(int i = 0; i < array1.Length;i++ )
			{
				if(array1[i] != array2[i])
					return false;
			}
			return true;
		}
        public static void Fill(this ref FixedLengthUInt32Array32 array, UInt32 value = default)
        {
			for(int i = 0; i < array.Length;i++ )
			{
				array[i] = value;
			}
        }
#elif GENERATE_ASSPAN
		[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static ref UInt32 At(this ref FixedLengthUInt32Array32 array, int index)
            => ref AsSpan(ref array)[index];

        public static int CompareTo(this in FixedLengthUInt32Array32 array1, in FixedLengthUInt32Array32 array2)
			=> AsReadOnlySpan(array1).SequenceCompareTo(AsReadOnlySpan(array2));

        public static void CopyTo(this in FixedLengthUInt32Array32 array, Span<UInt32> destination)
            => AsReadOnlySpan(array).CopyTo(destination);

        public static bool Equals(in FixedLengthUInt32Array32 array1, in FixedLengthUInt32Array32 array2)
			=> AsReadOnlySpan(array1).SequenceEqual(AsReadOnlySpan(array2));

        public static void Fill(this ref FixedLengthUInt32Array32 array, UInt32 value = default)
            => AsSpan(ref array).Fill(value);
#endif
    }
}
